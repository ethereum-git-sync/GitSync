{
  "url": "https://api.github.com/repos/ethereum/EIPs/issues/1161",
  "repository_url": "https://api.github.com/repos/ethereum/EIPs",
  "labels_url": "https://api.github.com/repos/ethereum/EIPs/issues/1161/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/EIPs/issues/1161/comments",
  "events_url": "https://api.github.com/repos/ethereum/EIPs/issues/1161/events",
  "html_url": "https://github.com/ethereum/EIPs/issues/1161",
  "id": 333484375,
  "node_id": "MDU6SXNzdWUzMzM0ODQzNzU=",
  "number": 1161,
  "title": "EIP 1154: Oracle interface",
  "user": {
    "login": "cag",
    "id": 298447,
    "node_id": "MDQ6VXNlcjI5ODQ0Nw==",
    "avatar_url": "https://avatars.githubusercontent.com/u/298447?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/cag",
    "html_url": "https://github.com/cag",
    "followers_url": "https://api.github.com/users/cag/followers",
    "following_url": "https://api.github.com/users/cag/following{/other_user}",
    "gists_url": "https://api.github.com/users/cag/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/cag/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/cag/subscriptions",
    "organizations_url": "https://api.github.com/users/cag/orgs",
    "repos_url": "https://api.github.com/users/cag/repos",
    "events_url": "https://api.github.com/users/cag/events{/privacy}",
    "received_events_url": "https://api.github.com/users/cag/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [

  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 34,
  "created_at": "2018-06-19T01:02:16Z",
  "updated_at": "2019-07-23T21:41:08Z",
  "closed_at": "2019-07-23T21:10:05Z",
  "author_association": "CONTRIBUTOR",
  "active_lock_reason": null,
  "body": "This is the official discussions thread for EIP #1154. The draft can be read [here](https://eips.ethereum.org/EIPS/eip-1154).",
  "closed_by": {
    "login": "nicksavers",
    "id": 7483198,
    "node_id": "MDQ6VXNlcjc0ODMxOTg=",
    "avatar_url": "https://avatars.githubusercontent.com/u/7483198?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nicksavers",
    "html_url": "https://github.com/nicksavers",
    "followers_url": "https://api.github.com/users/nicksavers/followers",
    "following_url": "https://api.github.com/users/nicksavers/following{/other_user}",
    "gists_url": "https://api.github.com/users/nicksavers/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nicksavers/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nicksavers/subscriptions",
    "organizations_url": "https://api.github.com/users/nicksavers/orgs",
    "repos_url": "https://api.github.com/users/nicksavers/repos",
    "events_url": "https://api.github.com/users/nicksavers/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nicksavers/received_events",
    "type": "User",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/1161/reactions",
    "total_count": 2,
    "+1": 2,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/EIPs/issues/1161/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/398244033",
    "html_url": "https://github.com/ethereum/EIPs/issues/1161#issuecomment-398244033",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1161",
    "id": 398244033,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM5ODI0NDAzMw==",
    "user": {
      "login": "cag",
      "id": 298447,
      "node_id": "MDQ6VXNlcjI5ODQ0Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/298447?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cag",
      "html_url": "https://github.com/cag",
      "followers_url": "https://api.github.com/users/cag/followers",
      "following_url": "https://api.github.com/users/cag/following{/other_user}",
      "gists_url": "https://api.github.com/users/cag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cag/subscriptions",
      "organizations_url": "https://api.github.com/users/cag/orgs",
      "repos_url": "https://api.github.com/users/cag/repos",
      "events_url": "https://api.github.com/users/cag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cag/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-06-19T01:19:20Z",
    "updated_at": "2018-06-27T16:47:32Z",
    "author_association": "CONTRIBUTOR",
    "body": "So far, @Arachnid has commented on this EIP a bit in the PR. The discussion is reproduced here for convenience and expanded upon:\r\n\r\n> Can you provide example use-cases? What sort of oracles is this intended to support? Who would benefit from standardising such an interface?\r\n\r\nThe use case I had in mind originally was for answering questions about \"real-world events\", where each ID can be correlated with a specification of a question and its answers (so most likely for prediction markets, basically).\r\n\r\nBoth the ID and the results are intentionally unstructured so that things like time series data (via splitting the ID) and different sorts of results (like one of a few, any subset of up to 256, or some value in a range with up to 256 bits of granularity) can be represented.\r\n\r\nAnother use case could be for decision-making processes, where the results given by the oracle represent decisions made by the oracle (e.g. futarchies).\r\n\r\n> Can you expand on this in the EIP? And maybe make the title of the EIP more specific?\r\n\r\n- [x] Expand on use cases and types of oracles supported\r\n- [ ] Specify title better (I'm afraid I'm not terribly imaginative, so I will take suggestions here)\r\n\r\n> This seems to assume one particular type of oracle - one that returns exactly 32 bytes of data, and is a trusted party. There are many other types of oracle; what about them?\r\n\r\nRegarding the trusted party factor: I've intentionally decided to start drafting the spec in as strict a manner as possible. With that said, there isn't a clear mandate about the authorization model, so it's not necessarily a single account which is authorized to make the report. Also, mechanisms like multisignature wallets, side/child chains, or something else may be used to distribute the trust if it was mandated to be a single account.\r\n\r\nRegarding the 32 bytes of data: I am still debating and open to making the result an arbitrary-size blob of `bytes`. My contention is two-fold:\r\n\r\n1. Putting much more than a word of result data (say like a paragraph) is probably not very actionable. Large amounts of input data is more suitable for, say, the field of machine learning, instead of smart contracts.\r\n2. You can carve out an index byte in the ID if you want to pass 256 consecutive words to the handler, so it doesn't necessarily limit the result size in some sense, but at that point, I'd seriously ask whether this should even be going on the chain.\r\n\r\n> Services like Oraclize would seem to demonstrate uses for more than 32 bytes of onchain data, however.\r\n\r\nYes, it is true that Oraclize does support more than 32 bytes of onchain data, and this is something which I personally am not settled on as well, but I would also be interested in hearing from the community whether or not they've got any use cases for more than 32 bytes.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/398244033/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/400232207",
    "html_url": "https://github.com/ethereum/EIPs/issues/1161#issuecomment-400232207",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1161",
    "id": 400232207,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwMDIzMjIwNw==",
    "user": {
      "login": "edmundedgar",
      "id": 75964,
      "node_id": "MDQ6VXNlcjc1OTY0",
      "avatar_url": "https://avatars.githubusercontent.com/u/75964?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/edmundedgar",
      "html_url": "https://github.com/edmundedgar",
      "followers_url": "https://api.github.com/users/edmundedgar/followers",
      "following_url": "https://api.github.com/users/edmundedgar/following{/other_user}",
      "gists_url": "https://api.github.com/users/edmundedgar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/edmundedgar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/edmundedgar/subscriptions",
      "organizations_url": "https://api.github.com/users/edmundedgar/orgs",
      "repos_url": "https://api.github.com/users/edmundedgar/repos",
      "events_url": "https://api.github.com/users/edmundedgar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/edmundedgar/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-06-26T08:51:33Z",
    "updated_at": "2018-06-26T11:46:24Z",
    "author_association": "NONE",
    "body": "Agree with @cag on the `bytes32` thing, I know that's how Oraclize *serves* the data (as a string, which it's then up to you to parse), but I reckon what contract authors are usually doing as soon as they get that data is to squidge whatever they get from there back into 32 bytes so they can actually use it...\r\n\r\nWe've assumed everything is a `bytes32` for Reality Check; On our current scheme (implemented in our dapp, the contract only knows somebody sent it a `bytes32`, it doesn't understand what's in it) this is intended to map as follows:\r\n * 0 or 1 for true/false\r\n * the number for an unsigned number (optionally with decimals)\r\n * the number in twos-complement for a signed number (optionally with decimals)\r\n * 0-based array for a single-choice question\r\n * 1-based bitmask for multi-choice questions (all zeros means none were selected)\r\n\r\nOne hairy thing about this is that you often end up wanting to express \"this question is invalid\" or \"I couldn't answer this question\". ~~In Augur they call this \"`-1`\".~~ (This is a slightly different thing to `isOutcomeSet()` which I would interpret as \"have you reached a conclusion about this question\" - which we handle separately). The natural thing is to encode it as `0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff`, but that clashes with an actual `-1` as a signed number...",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/400232207/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/400236399",
    "html_url": "https://github.com/ethereum/EIPs/issues/1161#issuecomment-400236399",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1161",
    "id": 400236399,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwMDIzNjM5OQ==",
    "user": {
      "login": "edmundedgar",
      "id": 75964,
      "node_id": "MDQ6VXNlcjc1OTY0",
      "avatar_url": "https://avatars.githubusercontent.com/u/75964?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/edmundedgar",
      "html_url": "https://github.com/edmundedgar",
      "followers_url": "https://api.github.com/users/edmundedgar/followers",
      "following_url": "https://api.github.com/users/edmundedgar/following{/other_user}",
      "gists_url": "https://api.github.com/users/edmundedgar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/edmundedgar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/edmundedgar/subscriptions",
      "organizations_url": "https://api.github.com/users/edmundedgar/orgs",
      "repos_url": "https://api.github.com/users/edmundedgar/repos",
      "events_url": "https://api.github.com/users/edmundedgar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/edmundedgar/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-06-26T09:05:11Z",
    "updated_at": "2018-06-26T09:05:30Z",
    "author_association": "NONE",
    "body": "On `getOutcome()` and `isOutcomeSet()`, Reality Check calls `revert()` in its equivalent to `getOutcome()` - ours is currently called `getFinalAnswer()` - if the outcome isn't set. This is intended to avoid the need to call the contract twice in a transaction, although you still want to be able to call `isOutcomeSet()` to find out what's going on, most likely for UI purposes but possibly for use in a contract.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/400236399/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/400265724",
    "html_url": "https://github.com/ethereum/EIPs/issues/1161#issuecomment-400265724",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1161",
    "id": 400265724,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwMDI2NTcyNA==",
    "user": {
      "login": "jleeh",
      "id": 10528926,
      "node_id": "MDQ6VXNlcjEwNTI4OTI2",
      "avatar_url": "https://avatars.githubusercontent.com/u/10528926?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jleeh",
      "html_url": "https://github.com/jleeh",
      "followers_url": "https://api.github.com/users/jleeh/followers",
      "following_url": "https://api.github.com/users/jleeh/following{/other_user}",
      "gists_url": "https://api.github.com/users/jleeh/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jleeh/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jleeh/subscriptions",
      "organizations_url": "https://api.github.com/users/jleeh/orgs",
      "repos_url": "https://api.github.com/users/jleeh/repos",
      "events_url": "https://api.github.com/users/jleeh/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jleeh/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-06-26T10:52:30Z",
    "updated_at": "2018-06-26T10:54:39Z",
    "author_association": "NONE",
    "body": "I disagree with this being restricted to just `bytes32` as that is a limitation with what current Oracle solutions report back with, and will have the following side-effects:\r\n- Code duplication in each of the contracts that implement this interface, having methods for typecasting `bytes32` values to `uint`, `int`, `bool` etc.\r\n- Increased gas cost for either the Oracle reporting or the contract that uses this by forcing them to include the value conversion when calling this contract.\r\n\r\nIn my opinion, it should be the responsibility of the Oracle reporting back to send the data in the right type to begin with as-in: `int`, `uint` etc. This would result in this interface having methods for each data type, but then there's no incurred cost to either the Oracle/end-user who needs that data. Critical with decentralised Oracle projects, as on-chain value aggregation and reputation mechanisms will increase the gas cost to any user before that.\r\n\r\nWith @cag mentioning ChainLink, writing back to on-chain contracts with different value types is something it already supports with the following: `int256`, `uint256` and `bytes32`. Again, it's not limited to those, it's simply what's already supported in its pre-release state.\r\n\r\nTo sum up, I don't think we should be implementing strict Oracle standards before we've really seen any established decentralised Oracle projects functioning yet. I feel it's too limiting before we've really seen what Oracles will be used for and how.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/400265724/reactions",
      "total_count": 3,
      "+1": 3,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/400276424",
    "html_url": "https://github.com/ethereum/EIPs/issues/1161#issuecomment-400276424",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1161",
    "id": 400276424,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwMDI3NjQyNA==",
    "user": {
      "login": "edmundedgar",
      "id": 75964,
      "node_id": "MDQ6VXNlcjc1OTY0",
      "avatar_url": "https://avatars.githubusercontent.com/u/75964?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/edmundedgar",
      "html_url": "https://github.com/edmundedgar",
      "followers_url": "https://api.github.com/users/edmundedgar/followers",
      "following_url": "https://api.github.com/users/edmundedgar/following{/other_user}",
      "gists_url": "https://api.github.com/users/edmundedgar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/edmundedgar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/edmundedgar/subscriptions",
      "organizations_url": "https://api.github.com/users/edmundedgar/orgs",
      "repos_url": "https://api.github.com/users/edmundedgar/repos",
      "events_url": "https://api.github.com/users/edmundedgar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/edmundedgar/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-06-26T11:38:49Z",
    "updated_at": "2018-06-26T11:40:33Z",
    "author_association": "NONE",
    "body": "@jleeh I'm all for saving gas and we jumped through all kinds of hoops to make Reality Check economical but the gas cost of these conversions is extremely small - here's a demo contract that just logs an event, one with a bytes32->uint conversion and one without:\r\n\r\nhttps://pastebin.com/D55x8e9K\r\n\r\nsolc --gas gastest.sol\r\n\r\n======= contract.sol:GasDemo =======\r\nGas estimation:\r\nconstruction:\r\n   117 + 69000 = 69117\r\nexternal:\r\n   convUint(bytes32):\t1313\r\n   noconv(uint256):\t1258\r\n\r\nSo in that case we're literally talking 55 gas, less with optimization. A simple send is 21,000 - the difference really isn't worth bothering with. The code to do this is also trivial.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/400276424/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/400277592",
    "html_url": "https://github.com/ethereum/EIPs/issues/1161#issuecomment-400277592",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1161",
    "id": 400277592,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwMDI3NzU5Mg==",
    "user": {
      "login": "MicahZoltu",
      "id": 886059,
      "node_id": "MDQ6VXNlcjg4NjA1OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886059?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MicahZoltu",
      "html_url": "https://github.com/MicahZoltu",
      "followers_url": "https://api.github.com/users/MicahZoltu/followers",
      "following_url": "https://api.github.com/users/MicahZoltu/following{/other_user}",
      "gists_url": "https://api.github.com/users/MicahZoltu/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MicahZoltu/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MicahZoltu/subscriptions",
      "organizations_url": "https://api.github.com/users/MicahZoltu/orgs",
      "repos_url": "https://api.github.com/users/MicahZoltu/repos",
      "events_url": "https://api.github.com/users/MicahZoltu/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MicahZoltu/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-06-26T11:43:56Z",
    "updated_at": "2018-06-26T11:43:56Z",
    "author_association": "MEMBER",
    "body": "> In Augur they call this \"-1\". (This is a slightly different thing to isOutcomeSet() which I would interpret as \"have you reached a conclusion about this question\" - which we handle separately).\r\n\r\nThis isn't accurate, Augur doesn't represent results as a single value, it represents them as an array of values.  This is because the result is a distribution of assets to token holders, and that distribution may not be 100%/0%.\r\n\r\nInvalid is represented by an equal distribution to all parties (along with a special flag to differentiate from a valid exactly-middle resolutios.).",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/400277592/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/400289855",
    "html_url": "https://github.com/ethereum/EIPs/issues/1161#issuecomment-400289855",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1161",
    "id": 400289855,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwMDI4OTg1NQ==",
    "user": {
      "login": "jleeh",
      "id": 10528926,
      "node_id": "MDQ6VXNlcjEwNTI4OTI2",
      "avatar_url": "https://avatars.githubusercontent.com/u/10528926?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jleeh",
      "html_url": "https://github.com/jleeh",
      "followers_url": "https://api.github.com/users/jleeh/followers",
      "following_url": "https://api.github.com/users/jleeh/following{/other_user}",
      "gists_url": "https://api.github.com/users/jleeh/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jleeh/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jleeh/subscriptions",
      "organizations_url": "https://api.github.com/users/jleeh/orgs",
      "repos_url": "https://api.github.com/users/jleeh/repos",
      "events_url": "https://api.github.com/users/jleeh/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jleeh/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-06-26T12:29:51Z",
    "updated_at": "2018-06-26T12:34:21Z",
    "author_association": "NONE",
    "body": "@edmundedgar Good point, just tested the same for `int256` with a twos compliment hex and got the same also, 55 gas difference.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/400289855/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/400516926",
    "html_url": "https://github.com/ethereum/EIPs/issues/1161#issuecomment-400516926",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1161",
    "id": 400516926,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwMDUxNjkyNg==",
    "user": {
      "login": "se3000",
      "id": 573827,
      "node_id": "MDQ6VXNlcjU3MzgyNw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/573827?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/se3000",
      "html_url": "https://github.com/se3000",
      "followers_url": "https://api.github.com/users/se3000/followers",
      "following_url": "https://api.github.com/users/se3000/following{/other_user}",
      "gists_url": "https://api.github.com/users/se3000/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/se3000/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/se3000/subscriptions",
      "organizations_url": "https://api.github.com/users/se3000/orgs",
      "repos_url": "https://api.github.com/users/se3000/repos",
      "events_url": "https://api.github.com/users/se3000/events{/privacy}",
      "received_events_url": "https://api.github.com/users/se3000/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-06-27T01:50:04Z",
    "updated_at": "2018-06-27T01:50:04Z",
    "author_association": "NONE",
    "body": "@edmundedgar one scenario we consider is something like parsing bytes32 [`\"425.53\"`](https://www.bitstamp.net/api/v2/ticker/ethusd) into a uint256. How would you handle that? You can cheaply change the type, but the content isn't preserved. Based on what you describe above, it seems like a type is specified in the request and then converted by the Oracle Handler. Chainlink does something similar and assumes the response is a single EVM word([function sig takes bytes32](https://github.com/smartcontractkit/chainlink/blob/master/solidity/contracts/Oracle.sol#L101) but all that matters is that it's an EVM word) and then the conversion pretty much comes for free when [invoking the callback function](https://github.com/smartcontractkit/chainlink/blob/master/solidity/contracts/Oracle.sol#L113).\r\n\r\nI'll confirm your suspicion that people are immediately parsing bytes32 into other types as soon as they arrive. We started with only bytes32 and got a lot of feedback parsing was a pain point. In our view, some conversions are cheaper than others, but they're all practically free for the Oracle Operator to compute, so it's better to be handled there. Also, contracts are complicated enough as it is, reducing the code they require to parse a response is beneficial for security and cost.\r\n\r\nFor the Oracle Operator to do this, being explicit about the type is important. We put the expected type it in the query to make it clear for all parties involved what will be reported. For example, if a Consumer checks `if reportedEtherPrice > 100000`, and one party is expecting a uint256 but it arrives formatted as bytes32, they will always be disappointed because even a right padded `\"1\"` would evaluate to greater than left padded 100000.\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/400516926/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/400520480",
    "html_url": "https://github.com/ethereum/EIPs/issues/1161#issuecomment-400520480",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1161",
    "id": 400520480,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwMDUyMDQ4MA==",
    "user": {
      "login": "se3000",
      "id": 573827,
      "node_id": "MDQ6VXNlcjU3MzgyNw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/573827?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/se3000",
      "html_url": "https://github.com/se3000",
      "followers_url": "https://api.github.com/users/se3000/followers",
      "following_url": "https://api.github.com/users/se3000/following{/other_user}",
      "gists_url": "https://api.github.com/users/se3000/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/se3000/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/se3000/subscriptions",
      "organizations_url": "https://api.github.com/users/se3000/orgs",
      "repos_url": "https://api.github.com/users/se3000/repos",
      "events_url": "https://api.github.com/users/se3000/events{/privacy}",
      "received_events_url": "https://api.github.com/users/se3000/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-06-27T02:14:17Z",
    "updated_at": "2018-06-27T02:14:17Z",
    "author_association": "NONE",
    "body": "@cag some thoughts on specification and how we talk about this stuff at Chainlink: We're all for [ubiquitous language](https://martinfowler.com/bliki/UbiquitousLanguage.html) and so try to be pretty explicit about naming things. Because there's two parts to an Oracle, the on-chain and off-chain part, we specifically refer to the on-chain part as the \"Oracle Contract\", and have historically called the \"Oracle Handler\" an \"Oracle Node\" or \"Oracle Operator\". Those names might not be appropriate for a more general spec, but I think \"Oracle\" alone can be vague when discussing interactions.\r\n\r\nWe also refer to \"Consumer\" for the contract that receives the Result, and the \"Requester\" for the initiator in a Pull style interaction. They're often the same contract, but could be different, like if a request comes in from an Externally Owned Account. We also specify two interactions for the Pull based model, \"Requesting\" and \"Fulfillment.\"\r\n\r\nI'm with @jleeh that more concrete use cases would be helpful before standardizing, but this seems like the best place to get the conversation rolling.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/400520480/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/400521924",
    "html_url": "https://github.com/ethereum/EIPs/issues/1161#issuecomment-400521924",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1161",
    "id": 400521924,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwMDUyMTkyNA==",
    "user": {
      "login": "edmundedgar",
      "id": 75964,
      "node_id": "MDQ6VXNlcjc1OTY0",
      "avatar_url": "https://avatars.githubusercontent.com/u/75964?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/edmundedgar",
      "html_url": "https://github.com/edmundedgar",
      "followers_url": "https://api.github.com/users/edmundedgar/followers",
      "following_url": "https://api.github.com/users/edmundedgar/following{/other_user}",
      "gists_url": "https://api.github.com/users/edmundedgar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/edmundedgar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/edmundedgar/subscriptions",
      "organizations_url": "https://api.github.com/users/edmundedgar/orgs",
      "repos_url": "https://api.github.com/users/edmundedgar/repos",
      "events_url": "https://api.github.com/users/edmundedgar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/edmundedgar/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-06-27T02:23:36Z",
    "updated_at": "2018-06-27T02:28:55Z",
    "author_association": "NONE",
    "body": "@se3000 We're doing what seems to be the standard Ethereum way to handle decimals which is to specify a number of decimals and deliver data multiplied by that like that - ie if you expect a USD price to a precision of 0.1 cents, you would ask the oracle for a number in milli-dollars, do everything in the contract in milli-dollars and only do the conversion to USD in the UI. I think this is also what you're advocating. As you're suggesting, it feels icky to do anything involving *parsing* stuff in the contract. \r\n\r\nBut the upshot of this is that when you interact with a contract, you need to know what the question specifies in terms of how it will interpret the data. If you've asked for a `uint256` expecting 4 decimals, and the question actually asks the oracle to supply a `uint256` using 13 decimals, you're going to have a bad day. I think this means that you can't usefully protect users of a contract by supplying data with different function signatures to distinguish times they want a `bool` from times they want a `uint256` from times they want an `int256`, because they still need to look to the specific question asked to find out what *kind* of `uint256` it is.\r\n\r\nIn other words, you need to distinguish different types of data, and it might be useful to have a common understanding of what they are, but that doesn't map cleanly to Solidity types, and often the consumer contract (as opposed to its user / UI code) won't need to know what the data type is either, so it seems simpler to deliver everything as a `bytes32`.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/400521924/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/400799201",
    "html_url": "https://github.com/ethereum/EIPs/issues/1161#issuecomment-400799201",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1161",
    "id": 400799201,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwMDc5OTIwMQ==",
    "user": {
      "login": "cag",
      "id": 298447,
      "node_id": "MDQ6VXNlcjI5ODQ0Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/298447?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cag",
      "html_url": "https://github.com/cag",
      "followers_url": "https://api.github.com/users/cag/followers",
      "following_url": "https://api.github.com/users/cag/following{/other_user}",
      "gists_url": "https://api.github.com/users/cag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cag/subscriptions",
      "organizations_url": "https://api.github.com/users/cag/orgs",
      "repos_url": "https://api.github.com/users/cag/repos",
      "events_url": "https://api.github.com/users/cag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cag/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-06-27T19:20:34Z",
    "updated_at": "2018-09-05T16:07:43Z",
    "author_association": "CONTRIBUTOR",
    "body": "There shouldn't be a conversion gas cost, as the EVM doesn't have a conception of \"type\" in its memory, just that the Solidity compiler enforces type semantics, and there are EVM opcodes which assume a piece of memory is typed in some way and does an operation accordingly. I think the gas difference is an accident of function selector order and maybe implementation details regarding stack memory use. For example, Remix reports that in the following version of the GasDemo, `funcA` is actually the more expensive function by 2 gas (probably `funcA` is the function selector being checked _after_ `funcB`, and the temporary `uint u` was removed):\r\n\r\n<details><summary>GasDemo Example</summary>\r\n\r\n```solidity\r\ncontract GasDemo {\r\n    event MyEvent(uint256 u);\r\n\r\n    function funcA(uint256 u) {\r\n        emit MyEvent(u);\r\n    }\r\n\r\n    function funcB(bytes32 b) {\r\n        emit MyEvent(uint256(b));\r\n    }\r\n}\r\n```\r\n\r\n</details>\r\n\r\n---\r\n\r\nFixed-point is a popular way of dealing with numbers that may have fractional parts, and whether it is binary or decimal, and how many fractional bits/decimal places get encoded often depends on the use case (or maybe on a whim ¯\\\\\\_(ツ)_/¯). Still, I would say no matter what the details of the encoding, it is more efficient than using a string to represent numerical values on the blockchain.\r\n\r\nGnosis' use case for oracles is limited to the \"one-of-many possibilities\" and \"signed integer (possibly with fixed-point)\" result representations listed by @edmundedgar (I am considering stealing that list for the proposal). In this use case, the ID in the proposal corresponds to an IPFS document which specifies what the oracle reports on and how the result should be interpreted.\r\n\r\n---\r\n\r\n@MicahZoltu I know that I mentioned potentially cutting out a byte from the ID to support reporting up to 256 words, but does it make sense for Augur to report values via something like this proposal?\r\n\r\n---\r\n\r\nI'm wondering if it would make sense to standardize both push and pull type oracles in this EIP. If so, the terminology for oracle should be refined, as @se3000 notes.\r\n\r\nStill, I am shy of using the term \"oracle contract\", as the oracle may just be somebody with an ordinary Ethereum account. Maybe it should be \"push-type oracles\" and \"pull-type oracles\"?\r\n\r\nI am using \"oracle\" in the spirit of the definition \"a priest or priestess acting as a medium through whom advice or prophecy was sought from the gods in classical antiquity.\"",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/400799201/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/400837418",
    "html_url": "https://github.com/ethereum/EIPs/issues/1161#issuecomment-400837418",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1161",
    "id": 400837418,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwMDgzNzQxOA==",
    "user": {
      "login": "edmundedgar",
      "id": 75964,
      "node_id": "MDQ6VXNlcjc1OTY0",
      "avatar_url": "https://avatars.githubusercontent.com/u/75964?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/edmundedgar",
      "html_url": "https://github.com/edmundedgar",
      "followers_url": "https://api.github.com/users/edmundedgar/followers",
      "following_url": "https://api.github.com/users/edmundedgar/following{/other_user}",
      "gists_url": "https://api.github.com/users/edmundedgar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/edmundedgar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/edmundedgar/subscriptions",
      "organizations_url": "https://api.github.com/users/edmundedgar/orgs",
      "repos_url": "https://api.github.com/users/edmundedgar/repos",
      "events_url": "https://api.github.com/users/edmundedgar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/edmundedgar/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-06-27T21:38:08Z",
    "updated_at": "2018-06-27T21:38:08Z",
    "author_association": "NONE",
    "body": "@cag One thing we haven't really discussed here is how the question is formatted, except that it has a question, a type and may specify decimals - in the Gnosis context, what the content of that IPFS file looks like.\r\n\r\nI don't know if that's too specific for the EIP which currently mainly talks about how the data is delivered, but I'd at least like to make sure that Reality Check supports something that Gnosis supports, or vice versa.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/400837418/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/401053594",
    "html_url": "https://github.com/ethereum/EIPs/issues/1161#issuecomment-401053594",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1161",
    "id": 401053594,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwMTA1MzU5NA==",
    "user": {
      "login": "MicahZoltu",
      "id": 886059,
      "node_id": "MDQ6VXNlcjg4NjA1OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886059?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MicahZoltu",
      "html_url": "https://github.com/MicahZoltu",
      "followers_url": "https://api.github.com/users/MicahZoltu/followers",
      "following_url": "https://api.github.com/users/MicahZoltu/following{/other_user}",
      "gists_url": "https://api.github.com/users/MicahZoltu/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MicahZoltu/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MicahZoltu/subscriptions",
      "organizations_url": "https://api.github.com/users/MicahZoltu/orgs",
      "repos_url": "https://api.github.com/users/MicahZoltu/repos",
      "events_url": "https://api.github.com/users/MicahZoltu/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MicahZoltu/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-06-28T14:26:29Z",
    "updated_at": "2018-06-28T14:26:29Z",
    "author_association": "MEMBER",
    "body": "Augur's native output is an array of numbers where the length of the array is the number of possible outcomes (not including invalid, though in hindsight I think invalid should have been its own outcome) that sum up to a number the market creator chooses associated with the market.  This results in each outcome receiving a fraction of the winnings proportionate to the reported number for that outcome divided by the number associated with the market.  e.g., `[7500, 2500]` means that holders of share `0` receive `7500/10000` while holders of share `1` receive `[2500/10000]`, or 75% and 25%.\r\n\r\nThat being said, if someone wanted to create an adapter contract that converts between Augur native output and this it wouldn't be particularly hard, assuming the denominator (10,000 in the example above) times the number of outcomes is less than 2^256.  Depending on how close you get to 2^256, you may have to resort to some clever bit packing, but in theory you could compress the result down to a single 256-bit value.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/401053594/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/407934438",
    "html_url": "https://github.com/ethereum/EIPs/issues/1161#issuecomment-407934438",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1161",
    "id": 407934438,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwNzkzNDQzOA==",
    "user": {
      "login": "cag",
      "id": 298447,
      "node_id": "MDQ6VXNlcjI5ODQ0Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/298447?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cag",
      "html_url": "https://github.com/cag",
      "followers_url": "https://api.github.com/users/cag/followers",
      "following_url": "https://api.github.com/users/cag/following{/other_user}",
      "gists_url": "https://api.github.com/users/cag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cag/subscriptions",
      "organizations_url": "https://api.github.com/users/cag/orgs",
      "repos_url": "https://api.github.com/users/cag/repos",
      "events_url": "https://api.github.com/users/cag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cag/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-07-26T00:05:41Z",
    "updated_at": "2018-07-26T21:27:18Z",
    "author_association": "CONTRIBUTOR",
    "body": "I'm sorry for the late response! Life's been... kinda crazy for me lately. Anyway...\r\n\r\n---\r\n\r\n@MicahZoltu Congrats on the Augur launch!\r\n\r\nCorrect me if I'm wrong, but I'm guessing that Augur results really only make sense in the context of this EIP if we're talking about a single universe right?\r\n\r\nAdditionally, in order for results to be interpreted in the way that was suggested by @edmundedgar, there would have to be an adapter which converted stuff like [0, 1] -> 1, [0, 0, 0, 1, 0, 0] -> 3, and [2500, 7500] -> 2500 (for Y/N, categorical, and scalar with four digits of granularity respectively)? I'm asking to see if this is possible, i.e. whether adding that list of suggested interpretations of the EVM word would still accommodate Augur's eligibility (outside of the scenario where a single word cannot describe the final state of the result).\r\n\r\n---\r\n\r\n@se3000 I've reread your comment and realized that there might have been a miscommunication! So in this spec, the oracle handler might map more correctly to what you are referring to as a consumer. I'm wondering if this is a fault of the terminology not being as readily apparent.\r\n\r\nI'd like people's opinion on whether `OracleHandler` may be better called an `OracleConsumer` or something along those lines.\r\n\r\n---\r\n\r\n@edmundedgar About the IPFS file format for the description of what the oracle reports on, I personally think that it's out of scope for this EIP. Also, certain oracles (purely on-chain oracles, for example), may use a completely different ID strategy. For example, an oracle contract which reports on, say, blockchain difficulty for a certain block, may use the block number as the ID for the report.\r\n\r\nI'd like to incorporate your list of result interpretations as _suggestions_ in the EIP: I think there are too many ways to structure the result for that list to be considered exhaustive - e.g. consider a case where you have 4 uint64s in order to describe a value in 4D space. Maybe that's a bit far-fetched though.\r\n\r\n---\r\n\r\nOne little task:\r\n\r\n- [x] Define \"report\" as a pair (ID, result)",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/407934438/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/407982555",
    "html_url": "https://github.com/ethereum/EIPs/issues/1161#issuecomment-407982555",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1161",
    "id": 407982555,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwNzk4MjU1NQ==",
    "user": {
      "login": "edmundedgar",
      "id": 75964,
      "node_id": "MDQ6VXNlcjc1OTY0",
      "avatar_url": "https://avatars.githubusercontent.com/u/75964?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/edmundedgar",
      "html_url": "https://github.com/edmundedgar",
      "followers_url": "https://api.github.com/users/edmundedgar/followers",
      "following_url": "https://api.github.com/users/edmundedgar/following{/other_user}",
      "gists_url": "https://api.github.com/users/edmundedgar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/edmundedgar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/edmundedgar/subscriptions",
      "organizations_url": "https://api.github.com/users/edmundedgar/orgs",
      "repos_url": "https://api.github.com/users/edmundedgar/repos",
      "events_url": "https://api.github.com/users/edmundedgar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/edmundedgar/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-07-26T05:40:40Z",
    "updated_at": "2018-07-26T05:40:40Z",
    "author_association": "NONE",
    "body": "I like \"OracleConsumer\"",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/407982555/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/407983081",
    "html_url": "https://github.com/ethereum/EIPs/issues/1161#issuecomment-407983081",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1161",
    "id": 407983081,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwNzk4MzA4MQ==",
    "user": {
      "login": "edmundedgar",
      "id": 75964,
      "node_id": "MDQ6VXNlcjc1OTY0",
      "avatar_url": "https://avatars.githubusercontent.com/u/75964?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/edmundedgar",
      "html_url": "https://github.com/edmundedgar",
      "followers_url": "https://api.github.com/users/edmundedgar/followers",
      "following_url": "https://api.github.com/users/edmundedgar/following{/other_user}",
      "gists_url": "https://api.github.com/users/edmundedgar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/edmundedgar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/edmundedgar/subscriptions",
      "organizations_url": "https://api.github.com/users/edmundedgar/orgs",
      "repos_url": "https://api.github.com/users/edmundedgar/repos",
      "events_url": "https://api.github.com/users/edmundedgar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/edmundedgar/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-07-26T05:43:58Z",
    "updated_at": "2018-07-26T05:44:42Z",
    "author_association": "NONE",
    "body": "> @edmundedgar About the IPFS file format for the description of what the oracle reports on, I personally think that it's out of scope for this EIP. Also, certain oracles (purely on-chain oracles, for example), may use a completely different ID strategy. For example, an oracle contract which reports on, say, blockchain difficulty for a certain block, may use the block number as the ID for the report.\r\n\r\nYes, that's something we saw at the workshop. Basically nobody else is involved in structuring information (as opposed to structuring where information comes from), so in practice even if we \"standardize\" it nobody except us will be using the \"standard\", so probably better to keep it out of a process for now.\r\n\r\n> I'd like to incorporate your list of result interpretations as suggestions in the EIP: I think there are too many ways to structure the result for that list to be considered exhaustive - e.g. consider a case where you have 4 uint64s in order to describe a value in 4D space. Maybe that's a bit far-fetched though\r\n\r\nYes, using them as suggestions makes sense. It certainly doesn't describe all possible cases, and our system is also designed to be extensible so you're not constrained by that list. BTW we've dropped the (signed) \"int\" case for now because describing its \"null\" case is hairy, maybe just leave that out.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/407983081/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/407988983",
    "html_url": "https://github.com/ethereum/EIPs/issues/1161#issuecomment-407988983",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1161",
    "id": 407988983,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwNzk4ODk4Mw==",
    "user": {
      "login": "MicahZoltu",
      "id": 886059,
      "node_id": "MDQ6VXNlcjg4NjA1OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886059?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MicahZoltu",
      "html_url": "https://github.com/MicahZoltu",
      "followers_url": "https://api.github.com/users/MicahZoltu/followers",
      "following_url": "https://api.github.com/users/MicahZoltu/following{/other_user}",
      "gists_url": "https://api.github.com/users/MicahZoltu/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MicahZoltu/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MicahZoltu/subscriptions",
      "organizations_url": "https://api.github.com/users/MicahZoltu/orgs",
      "repos_url": "https://api.github.com/users/MicahZoltu/repos",
      "events_url": "https://api.github.com/users/MicahZoltu/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MicahZoltu/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-07-26T06:18:45Z",
    "updated_at": "2018-07-26T06:19:14Z",
    "author_association": "MEMBER",
    "body": "> Additionally, in order for results to be interpreted in the way that was suggested by @edmundedgar, there would have to be an adapter which converted stuff like [0, 1] -> 1, [0, 0, 0, 1, 0, 0] -> 3, and [2500, 7500] -> 2500 (for Y/N, categorical, and scalar with four digits of granularity respectively)? I'm asking to see if this is possible, i.e. whether adding that list of suggested interpretations of the EVM word would still accommodate Augur's eligibility (outside of the scenario where a single word cannot describe the final state of the result).\r\n\r\nAccording to the contracts, the following is a valid reporting array: `[0, 1500, 2500, 5000, 1000]`\r\n\r\nThe reporting array is simply how to divide shares up among shareholders after the market ends.  An example (not yet supported in the UI) for where the above may make sense is a market for \"percentage of votes by presidential candidate\".  Users can go long or short on any candidate at any price, and make money based on how far they were in the right direction.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/407988983/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/408231820",
    "html_url": "https://github.com/ethereum/EIPs/issues/1161#issuecomment-408231820",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1161",
    "id": 408231820,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwODIzMTgyMA==",
    "user": {
      "login": "cag",
      "id": 298447,
      "node_id": "MDQ6VXNlcjI5ODQ0Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/298447?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cag",
      "html_url": "https://github.com/cag",
      "followers_url": "https://api.github.com/users/cag/followers",
      "following_url": "https://api.github.com/users/cag/following{/other_user}",
      "gists_url": "https://api.github.com/users/cag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cag/subscriptions",
      "organizations_url": "https://api.github.com/users/cag/orgs",
      "repos_url": "https://api.github.com/users/cag/repos",
      "events_url": "https://api.github.com/users/cag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cag/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-07-26T20:54:00Z",
    "updated_at": "2018-07-27T01:18:50Z",
    "author_association": "CONTRIBUTOR",
    "body": "I got one more candidate: `OracleReceiver`. Here's my reasoning behind the proposal:\r\n\r\n1. `OracleHandler` is too ambiguous: to handle does not evoke the right sense of what implementations of this interface should do.\r\n2. `OracleConsumer` is closer, but I had a silly image of a creature eating the oracle in my mind. Joking aside, this also may suggest the [producer-consumer problem](https://en.wikipedia.org/wiki/Producer%E2%80%93consumer_problem). I don't believe this captures the entire space of possible implementations, as the producer-consumer problem assumes the existence of a message queue.\r\n3. `OracleReceiver` may be bootstrapped off of the concept of [receivers](https://en.wikipedia.org/wiki/Receiver_(information_theory)) in information theory. This is the closest sense of what this interface should accomplish.\r\n\r\n---\r\n\r\n@edmundedgar I don't quite understand what you mean by a null case for a two's-complement representation. It's my understanding that every integer from [-2^255, 2^255-1] is one to one and onto the space of possible EVM words.\r\n\r\n---\r\n\r\n@MicahZoltu Duly noted; I've not even considered the possibility of distributions being an output! With that said, the full general case I believe should still be supported, either with clever bit-packing or with indexing the ID space with the market address and outcome index if the numerators are too large for a single word. So yeah, that \"value in 4D space\" remark would make sense in this case.\r\n\r\nThis may also bolster changing the result type to an arbitrary-size `bytes`.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/408231820/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/408340856",
    "html_url": "https://github.com/ethereum/EIPs/issues/1161#issuecomment-408340856",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1161",
    "id": 408340856,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwODM0MDg1Ng==",
    "user": {
      "login": "edmundedgar",
      "id": 75964,
      "node_id": "MDQ6VXNlcjc1OTY0",
      "avatar_url": "https://avatars.githubusercontent.com/u/75964?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/edmundedgar",
      "html_url": "https://github.com/edmundedgar",
      "followers_url": "https://api.github.com/users/edmundedgar/followers",
      "following_url": "https://api.github.com/users/edmundedgar/following{/other_user}",
      "gists_url": "https://api.github.com/users/edmundedgar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/edmundedgar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/edmundedgar/subscriptions",
      "organizations_url": "https://api.github.com/users/edmundedgar/orgs",
      "repos_url": "https://api.github.com/users/edmundedgar/repos",
      "events_url": "https://api.github.com/users/edmundedgar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/edmundedgar/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-07-27T07:49:44Z",
    "updated_at": "2018-07-27T07:49:44Z",
    "author_association": "NONE",
    "body": "@cag The issue with the null case is simply that the answer to a lot of questions are either a number or \"We couldn't decide\" or \"This question didn't make sense\". We hack this with boolean, uint or multiple-selection types by denoting that the final value, 0ffff....ffff, represents \"invalid\", and marginally shrinking the range of numbers we can represent. But if we want to handle negative numbers, that value comes back as \"-1\", which is an important part of the range you'd normally want to use. So for int types we'd have to either have a different representation for \"invalid\" depending on the type (eg we could use the number right in the middle of the range, representing the smallest possible number in the range) or come up with a different scheme, and there are some arguments for different schemes, like the ability to set a custom range.\r\n\r\nAlternatively we could have a different value for \"invalid\" separately from the result like Augur does, which is probably the correct way to do it, but this creates more complexity.\r\n\r\nFor now we just decided to drop representation of negative numbers, since probably nobody needs it, and worry about it later.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/408340856/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/408549872",
    "html_url": "https://github.com/ethereum/EIPs/issues/1161#issuecomment-408549872",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1161",
    "id": 408549872,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwODU0OTg3Mg==",
    "user": {
      "login": "cwhinfrey",
      "id": 11652019,
      "node_id": "MDQ6VXNlcjExNjUyMDE5",
      "avatar_url": "https://avatars.githubusercontent.com/u/11652019?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cwhinfrey",
      "html_url": "https://github.com/cwhinfrey",
      "followers_url": "https://api.github.com/users/cwhinfrey/followers",
      "following_url": "https://api.github.com/users/cwhinfrey/following{/other_user}",
      "gists_url": "https://api.github.com/users/cwhinfrey/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cwhinfrey/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cwhinfrey/subscriptions",
      "organizations_url": "https://api.github.com/users/cwhinfrey/orgs",
      "repos_url": "https://api.github.com/users/cwhinfrey/repos",
      "events_url": "https://api.github.com/users/cwhinfrey/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cwhinfrey/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-07-27T22:03:22Z",
    "updated_at": "2018-07-27T22:03:22Z",
    "author_association": "NONE",
    "body": "I believe there are some cases where the `id` will not be used. For example, if an oracle contract is created for a single event it may have no need for an `id` for that event. I think the design decision to include `id` makes sense to cover both oracle contracts that cover single events and multiple events. Would it may make sense to standardize what should be passed as the `id` when it is not used and a contract simply has a `result`? It could be as simple as \"0 is be passed in for the `id` when the `id` is not applicable, otherwise the function reverts.\" ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/408549872/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/410099438",
    "html_url": "https://github.com/ethereum/EIPs/issues/1161#issuecomment-410099438",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1161",
    "id": 410099438,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQxMDA5OTQzOA==",
    "user": {
      "login": "cag",
      "id": 298447,
      "node_id": "MDQ6VXNlcjI5ODQ0Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/298447?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cag",
      "html_url": "https://github.com/cag",
      "followers_url": "https://api.github.com/users/cag/followers",
      "following_url": "https://api.github.com/users/cag/following{/other_user}",
      "gists_url": "https://api.github.com/users/cag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cag/subscriptions",
      "organizations_url": "https://api.github.com/users/cag/orgs",
      "repos_url": "https://api.github.com/users/cag/repos",
      "events_url": "https://api.github.com/users/cag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cag/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-08-02T23:32:45Z",
    "updated_at": "2018-09-05T16:31:53Z",
    "author_association": "CONTRIBUTOR",
    "body": "After a few discussions with people, `OracleConsumer` seems to be the rough consensus for terminology for what is previously known as an `OracleHandler`.\r\n\r\n---\r\n\r\n@edmundedgar There is the possibility of just saying that the range of the results given by the oracle is [0, result_granularity), and the oracle consumer or user-facing application could just map that to whatever range those values should represent.\r\n\r\n---\r\n\r\n@cwhinfrey I wonder if this clause from the draft covers single-use oracles:\r\n\r\n> receiveResult MAY revert if the id or result cannot be handled by the handler.\r\n\r\nAlso, thanks for this [implementation](https://github.com/levelkdev/tidbit)! I'll include it into the EIP draft at some point...\r\n\r\n---\r\n\r\nPing @josojo to talk about `bytes32` vs `bytes` as the result type, and to link in the people who want to see this draft incorporate extra data in some way.\r\n\r\nAlso, I was talking with @InfiniteStyles and he pointed out to me that `bytes` currently do not have a native Solidity deserialization method (https://github.com/ethereum/solidity/issues/3876). However, this is actively being addressed: https://github.com/ethereum/solidity/pull/4390\r\n\r\n---\r\n\r\n- [x] Change oracle handler to oracle consumer\r\n- [x] Put tidbit into Implementations section",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/410099438/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/410594373",
    "html_url": "https://github.com/ethereum/EIPs/issues/1161#issuecomment-410594373",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1161",
    "id": 410594373,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQxMDU5NDM3Mw==",
    "user": {
      "login": "josojo",
      "id": 7348154,
      "node_id": "MDQ6VXNlcjczNDgxNTQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7348154?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/josojo",
      "html_url": "https://github.com/josojo",
      "followers_url": "https://api.github.com/users/josojo/followers",
      "following_url": "https://api.github.com/users/josojo/following{/other_user}",
      "gists_url": "https://api.github.com/users/josojo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/josojo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/josojo/subscriptions",
      "organizations_url": "https://api.github.com/users/josojo/orgs",
      "repos_url": "https://api.github.com/users/josojo/repos",
      "events_url": "https://api.github.com/users/josojo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/josojo/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-08-06T05:38:59Z",
    "updated_at": "2018-08-06T05:41:29Z",
    "author_association": "NONE",
    "body": "**Web3 oracle workshop summary - 23/24 of July**\r\n\r\nDuring the oracle workshop organized by the web3 foundation in London, we also discussed this EIP. Participants of the discussion were representatives from oralize.it, realitykeys, chainlink,  appliedblockchain, thomsenreuters, consensys and web3 foundation.\r\n\r\n\r\nWe agreed that such a standard would be beneficial and we should introduce one. However, it seems unlikely that we can find one standard that fits all use cases.\r\n\r\nWe agreed that the proposed standard\r\n```\r\ninterface OracleHandler {\r\n    function receiveResult(bytes32 id, bytes32 result) external;\r\n}\r\n```\r\nis sufficient in most cases and a very efficient standard. \r\nHowever, if larger data needs to send to the OracleHandler, it might be more convenient (and gas efficient) to provide the result as a bytes variable and not as a bytes32 variable.\r\nAlso, metadata might be required for some oracle solutions. E.g. oraclize.it provides also authenticity proofs. \r\nFor these cases, we are proposing a second function:\r\n```\r\ninterface OracleHandler {\r\n    function receiveResult(bytes32 id, bytes result, bytes metadata) external;\r\n}\r\n```\r\n\r\nThe metadata could be handed in as a part of the results, but it will be cheaper gas wise to get them with a second variable than parsing the result every time. However, if metadata is not required, the costs for calling this function are higher with this additional metadata parameter. \r\n\r\nThis second proposal has the benefit that this interface is more flexible and overcomes many restrictions of the first proposal. Hence, the second proposal is more inclusive and forward-compatible than the bytes32 solution. The additional gas costs for the second proposal should be of the magnitude of only some 100 gas.\r\n\r\nThe consensus of the workshop was that the standard should support both methods. The bytes32 result solution was appreciated for its leanness. Other additional data as authenticity proofs could be checked in this setup by other contracts preprocessing the oracle data and only calling the oracleHandler after successful preprocessing. The 2nd proposed solution was appreciated as it is the most inclusive solution. It shines with flexibility and future-compatibility.\r\n\r\nThe participants also agreed that we need push and pull oracle interface standards, as both methods have unique selling points. The upper definitions are obviously only push interfaces. For pull interface, we agreed to the proposed standard. Additionally, returning bytes instead of bytes32 might be helpful as well:\r\n\r\n```\r\ninterface Oracle {\r\n    function resultFor(bytes32 id) external view returns (bytes32 result);\r\n}\r\n```\r\n```\r\ninterface Oracle {\r\n    function resultFor(bytes32 id) external view returns (bytes result);\r\n}\r\n```\r\n\r\nWe also mentioned that declaring these functions as view might be a restriction, which is not valid for all use cases. \r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/410594373/reactions",
      "total_count": 4,
      "+1": 4,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/411184149",
    "html_url": "https://github.com/ethereum/EIPs/issues/1161#issuecomment-411184149",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1161",
    "id": 411184149,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQxMTE4NDE0OQ==",
    "user": {
      "login": "cag",
      "id": 298447,
      "node_id": "MDQ6VXNlcjI5ODQ0Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/298447?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cag",
      "html_url": "https://github.com/cag",
      "followers_url": "https://api.github.com/users/cag/followers",
      "following_url": "https://api.github.com/users/cag/following{/other_user}",
      "gists_url": "https://api.github.com/users/cag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cag/subscriptions",
      "organizations_url": "https://api.github.com/users/cag/orgs",
      "repos_url": "https://api.github.com/users/cag/repos",
      "events_url": "https://api.github.com/users/cag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cag/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-08-07T20:04:42Z",
    "updated_at": "2018-09-05T16:40:46Z",
    "author_association": "CONTRIBUTOR",
    "body": "> However, if larger data needs to send to the OracleHandler, it might be more convenient (and gas efficient) to provide the result as a bytes variable and not as a bytes32 variable.\r\n\r\nI am fine with changing the type of the result to `bytes` contingent on `decode` getting implemented in Solidity. I don't expect developers to roll their own encoding/decoding functionality every time they want to implement this standard though, so last call for this EIP is postponed until at least then.\r\n\r\n- [x] Change type of result to `bytes`\r\n\r\n---\r\n\r\n> [It] will be cheaper gas wise to get [the metadata] with a second variable than parsing the result every time. However, if metadata is not required, the costs for calling this function are higher with this additional metadata parameter.\r\n\r\nThis is probably the main trade-off for adding the additional `metadata` parameter. In this case, is the savings from having to do something like `data, metadata = decode(result, (bytes, bytes))` worth defining the extra parameter?\r\n\r\nAs noted earlier, this is already a tradeoff from just directly interpreting a `bytes32` as a `uint`, but while I can see the use case for that tradeoff, adding the additional `metadata` parameter seems like it is adding another parameter which most people will ignore, _and_ as is noted:\r\n\r\n> The metadata could be handed in as a part of the results\r\n\r\nAlso pull oracles would have to be modified to either have an additional `function metadataFor(bytes32 id) external view returns (bytes metadata)` or to have `resultFor` return a pair of bytes if both they and this proposal get incorporated into this standard.\r\n\r\nPing @D-Nice to discuss this more.\r\n\r\n---\r\n\r\nAlso, I want to note that single-use oracles, like what @cwhinfrey proposed earlier in this thread, already would ignore the `id` parameter, so taking the previous argument further might mean that oracle consumers should just expect to `receiveReport(bytes report)` from an oracle, and then the consumer would just decide whether or not to accept the report and what to do with it. This may complicate matters for pull oracles though (like how would a specific report be selected?).\r\n\r\n---\r\n\r\nIt seems like there is a lot of demand for pull oracles.\r\n\r\nOne of my concerns in potentially adding pull oracles to the standard is the possibility of fragmenting the ecosystem for standard oracle consumers. What this means, practically speaking, is that oracle consumers may have to support both waiting to hear the result from an oracle and reaching out to an oracle and pulling the result from the oracle.\r\n\r\nIf we move the burden of implementation onto the oracle, then we'd have to pick a single interface to standardize around. If the push interface is chosen, then all pull oracles would also have to have some sort of `function reportTo(OracleConsumer recipient, bytes32 id)`, but if a pull interface is chosen, then the oracle has to be a contract (no more ordinary accounts being oracles).\r\n\r\nIn any case, it's possible to specify both to some level of mandatory-ness, but then, there are a few scenarios:\r\n\r\n1. Oracle consumer expected to handle both\r\n  * ✔ Less requirements for oracles\r\n  * ✘ More requirements for oracle consumers\r\n2. Oracle consumer can handle either\r\n  * ✔ Less requirements for everyone\r\n  * ✘ Oracle and oracle consumer compatibility depends on both sharing at least one mode of communication\r\n3. Oracles must at least be push\r\n  * ✔ Ordinary account support\r\n  * ✔ At least one guaranteed interface for oracle consumers\r\n  * ✘ More requirements for _standard_ pull oracles\r\n  * ✘ Doesn't feel as natural for certain pull oracles\r\n4. Oracles must at least be pull\r\n  * ✔ At least one guaranteed interface for oracle consumers\r\n  * ✘ More requirements for _standard_ push oracles\r\n  * ✘ No ordinary accounts can be standard oracles\r\n\r\nIn some of the pros and cons listed above, _standard_ is emphasized because I anticipate the use of this standard would very much include adapters for existing oracles, and for those oracles, another contract containing code to adapt the existing oracle to either a mandatory pull or push interface would have to be deployed anyway.\r\n\r\nAnyway, if there is enough demand for also including the pull interface into the standard, my vote is for scenario (3).\r\n\r\n---\r\n\r\n> We also mentioned that declaring these functions as view might be a restriction, which is not valid for all use cases.\r\n\r\nCurious as to what those use cases may be...",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/411184149/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/411326542",
    "html_url": "https://github.com/ethereum/EIPs/issues/1161#issuecomment-411326542",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1161",
    "id": 411326542,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQxMTMyNjU0Mg==",
    "user": {
      "login": "se3000",
      "id": 573827,
      "node_id": "MDQ6VXNlcjU3MzgyNw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/573827?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/se3000",
      "html_url": "https://github.com/se3000",
      "followers_url": "https://api.github.com/users/se3000/followers",
      "following_url": "https://api.github.com/users/se3000/following{/other_user}",
      "gists_url": "https://api.github.com/users/se3000/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/se3000/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/se3000/subscriptions",
      "organizations_url": "https://api.github.com/users/se3000/orgs",
      "repos_url": "https://api.github.com/users/se3000/repos",
      "events_url": "https://api.github.com/users/se3000/events{/privacy}",
      "received_events_url": "https://api.github.com/users/se3000/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-08-08T08:19:33Z",
    "updated_at": "2018-08-08T08:19:33Z",
    "author_association": "NONE",
    "body": "@josojo thanks for the summarizing. I agree with @cag on the metadata point. I actually thought that the majority at the meeting were in favor of leaving it off, although there were certainly a couple in favor of it. We discussed the `bytes` being a flexible type that could be decoded manually for now, and possibly automatically if `abi.decode` lands in solidity v0.5. Given its flexibility, metadata could easily be included in the result parameter.\r\n\r\nAs discussed, I put together [some numbers around gas costs](https://github.com/se3000/gas-tests/blob/master/test/GasABI.js) for including the extra parameter as opposed to parsing it. Full disclosure: I've seen some fuzziness in truffle gas estimations in the past, but it has been off on the order of 10s, not 100s. (PRs welcome!) Based on those examples, it looks like including an extra bytes type metadata parameter is __actually roughly +600 gas__ per request. Alternatively, parsing a single bytes array into two bytes arrays is __~300 gas__.\r\n\r\nNot only is parsing bytes cheaper, but I think it is more fair to the users of the standard. A required metadata parameter would raise the cost of using the standard for all that do __not__ need it, as opposed to putting the (lesser) cost on those that choose to use it.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/411326542/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/411524241",
    "html_url": "https://github.com/ethereum/EIPs/issues/1161#issuecomment-411524241",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1161",
    "id": 411524241,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQxMTUyNDI0MQ==",
    "user": {
      "login": "D-Nice",
      "id": 2888248,
      "node_id": "MDQ6VXNlcjI4ODgyNDg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2888248?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/D-Nice",
      "html_url": "https://github.com/D-Nice",
      "followers_url": "https://api.github.com/users/D-Nice/followers",
      "following_url": "https://api.github.com/users/D-Nice/following{/other_user}",
      "gists_url": "https://api.github.com/users/D-Nice/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/D-Nice/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/D-Nice/subscriptions",
      "organizations_url": "https://api.github.com/users/D-Nice/orgs",
      "repos_url": "https://api.github.com/users/D-Nice/repos",
      "events_url": "https://api.github.com/users/D-Nice/events{/privacy}",
      "received_events_url": "https://api.github.com/users/D-Nice/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-08-08T19:29:18Z",
    "updated_at": "2018-08-08T19:29:18Z",
    "author_association": "NONE",
    "body": "Regarding the workshop, I do not think it is fair to assume the majority were against it. I only noted one party against it, two for it (Oraclize being one of those), and the other two parties either indifferent or abstaining from it, albeit one of the abstaining has a definite usecase for the metadata as well, at least if I followed their presentation correctly.\r\n\r\n@se3000 thanks for working on the gas cost tests and bringing them forward. I have expanded on your work with some more comprehensive test cases, and slightly more realistic results/metadata, in most cases I think we can agree that the elements won't be a single byte for both. The link to them is here: https://github.com/D-Nice/gas-tests\r\n\r\nTo give a quick overview, it replaced the single byte result + metadata assumption, into two identical IPFS multihashes (most Oraclize proof bytes are IPFS multihashes, and it was convenient to use as the result for something greater than a single word size). From our expanded upon tests, even with the most ideal and unrealistic parsing solution, where we expect a consistently formatted array of 2 elements with 2 word sizes, the **parsing costs ~300 more gas** than just using results + metadata (proper non-naiive parsing would of course amplify this much more). The increased cost for non-metadata utilizing Oralces is more consistent at 600 gas, however, they also have the option of using the bytes32 single element variable as an alternative, while metadata Oracles have no alternative, hence us requesting 2 bytes. \r\n\r\nYou can check the tests for more specificity, but at no point do metadata Oracles gain any competitive advantage over their non-metadata counter parts. In fact, we'd be putting ourselves at a disadvantage by going with the single bytes solution as it would **cost ~3000 more gas** for us than non-metadata Oracles (this doesn't even account for the additional computations that may be needed to handle or store certain proof types), whilst the result + metadata solution saves **us ~300 gas at least** and non-metadata Oracles will still be more **efficient by ~2000 gas** even with this implementation. If a compromise can't be made over this, then maybe our groups are not ready for a standard.\r\n\r\nI will look to list the Pros and Cons I see of the result + metadata solution.\r\n\r\n#### PROS\r\n\r\n- more efficient for metadata Oracles utilizing it (metadata Oracles as is will have higher on-chain costs to use due to this feature, thereby non-metadata Oracles still retain an on-chain efficiency advantage).\r\n\r\n- allows for results to be consistent across any Oracle type (if every Oracle provides their result completely differently, there is no point in a formal standard, and someone might as well just come up with a wrapper to try uniting production Oracles when they need them). \r\n\r\n- allows for extensibility and future proofing for ABI decoding and other features (non-metadata Oracles may eventually find some useful on-chain verification mechanism to include in the metadata, encoded ABI bytes could be defined in the metadata parameter, signatures for the included data can be included).\r\n\r\n#### CONS\r\n\r\n- sunken cost for non-metadata Oracles (they do have an alternative with utilizing the even more efficient bytes32 alternative if that is a worry).\r\n\r\n- awkward unutilized field for certain non-metadata Oracles\r\n\r\n\r\nOf course, please do assume I am being biased, and feel free to populate the PROS and CONS as you may see them.\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/411524241/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/413079251",
    "html_url": "https://github.com/ethereum/EIPs/issues/1161#issuecomment-413079251",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1161",
    "id": 413079251,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQxMzA3OTI1MQ==",
    "user": {
      "login": "cag",
      "id": 298447,
      "node_id": "MDQ6VXNlcjI5ODQ0Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/298447?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cag",
      "html_url": "https://github.com/cag",
      "followers_url": "https://api.github.com/users/cag/followers",
      "following_url": "https://api.github.com/users/cag/following{/other_user}",
      "gists_url": "https://api.github.com/users/cag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cag/subscriptions",
      "organizations_url": "https://api.github.com/users/cag/orgs",
      "repos_url": "https://api.github.com/users/cag/repos",
      "events_url": "https://api.github.com/users/cag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cag/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-08-15T02:56:01Z",
    "updated_at": "2018-09-05T18:28:36Z",
    "author_association": "CONTRIBUTOR",
    "body": "I tried golf-gas-testing the proposed metadata addition. I wrote the following test contracts:\r\n\r\nhttps://gist.github.com/cag/ca2b2046c75bd1b001e45c16e3890226\r\n\r\nI also used the following test data:\r\n\r\nInput type | Test contents\r\n-- | --\r\nSingle word result | 0x6c65726e65726372616d626f73616e646c61726b6f6662616279626f6f6d6572\r\nDynamic result (3 words/96B) | 0x0000000000000000000000000000000000000000000000000000000000000060 64656361676f6e73756e617573706963696f7573636f7272656374696f6e636f77796f7574736d617274696e67726569737375696e6762726f6f6d6c696b65646164726f636b646976696e6973656861737479686561726b656e656468696e74\r\nSingle word meta | 0xc9f5e4290844e94101ba068b4858d916e0f10cb7cf1fbbe4f3a1f286fed0a9da\r\nDynamic metadata (rsv-length/65B) | 0x0000000000000000000000000000000000000000000000000000000000000041 ebb1ee12c4c189b3ea9cc3c6ef6e0a07772e20518045ba5a1c61c280897e51e71f2cd48ec806af44f509872db983b6d4f59af61ca55534ee155ee5b246af6d37aa\r\n\r\nThis led to the following results:\r\n\r\n\r\nScenario | Single param TX cost | Double param TX cost | Winner | Delta\r\n-- | -- | -- | -- | --\r\nSingle word result, no metadata | 25165 | 25555 | Single | 390\r\nSingle word result, single word metadata | 27654 | 28108 | Single | 454\r\nSingle word result, dynamic metadata | 31902 | 31309 | Double | 593\r\nDynamic result, no metadata | 30598 | 30988 | Single | 390\r\nDynamic result, single word metadata | 33785 | 33550 | Double | 235\r\nDynamic result, dynamic metadata | 37870 | 36742 | Double | 1128\r\n\r\nSome of the contracts I've written can probably be golfed more, but yeah, check it out.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/413079251/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/413530199",
    "html_url": "https://github.com/ethereum/EIPs/issues/1161#issuecomment-413530199",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1161",
    "id": 413530199,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQxMzUzMDE5OQ==",
    "user": {
      "login": "se3000",
      "id": 573827,
      "node_id": "MDQ6VXNlcjU3MzgyNw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/573827?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/se3000",
      "html_url": "https://github.com/se3000",
      "followers_url": "https://api.github.com/users/se3000/followers",
      "following_url": "https://api.github.com/users/se3000/following{/other_user}",
      "gists_url": "https://api.github.com/users/se3000/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/se3000/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/se3000/subscriptions",
      "organizations_url": "https://api.github.com/users/se3000/orgs",
      "repos_url": "https://api.github.com/users/se3000/repos",
      "events_url": "https://api.github.com/users/se3000/events{/privacy}",
      "received_events_url": "https://api.github.com/users/se3000/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-08-16T12:34:39Z",
    "updated_at": "2018-08-16T12:34:39Z",
    "author_association": "NONE",
    "body": "@D-Nice it looks like the main the difference you're seeing when [comparing the price with metadata to the price without metadata](https://github.com/D-Nice/gas-tests/blob/master/test/GasABI.js#L79) [is due to the gas pricing of Ethereum](https://github.com/se3000/gas-tests/blob/master/contracts/DynamicDynMetaConsumer.sol#L25), not the difference in proposed interfaces. Typically in Ethereum usage costs more, and that's always the case when sending data in a transaction. Changing that is probably outside the scope of this PR, so I think it'd be more insightful to stick to 1:1 comparisons.\r\n\r\n> [Pro: metadata] allows for results to be consistent across any Oracle type\r\n\r\nMetadata is inconsistent and oracle specific. I think this would make responses less consistent then if metadata was handled before reporting the result to the oracle. More on this later.\r\n\r\n> [Pro: metadata] allows for extensibility and future proofing for ABI decoding and other features\r\n\r\nHow so? There would be another field. What about that is more or less future proof for ABI decoding? [My example](https://github.com/se3000/gas-tests/blob/master/contracts/GasABI.sol#L7) already decodes 2 `bytes` arrays, and additional optional fields could easily be added.\r\n\r\n> [Con: metadata] is a sunken cost for non-metadata Oracles\r\n\r\nThis is not a sunk cost. It is an ongoing cost that is placed on non-metadata oracles on every request they send. If anything it seems more like an [externalized cost](https://en.wikipedia.org/wiki/Cost_externalizing).\r\n\r\n> they do have an alternative with utilizing the even more efficient bytes32 alternative\r\n\r\nThe method we're discussing is being added to handle requests that need more than 32 bytes of data. This alternative will not work.\r\n\r\n@cag thanks for checking the numbers, very insightful. I'd previously assumed that it was a fixed cost because I'm only assigning pointers to preallocated data, but it looks like there's a gas cost in there that I'm missing and sending more data raises the parsing cost. I dug into \"Dynamic result, dynamic metadata\" example and couldn't help but golf, because who doesn't love a good optimization? I wrote an [alternate version](https://github.com/se3000/gas-tests/blob/master/contracts/DynamicDynMetaConsumer.sol#L25) that moves pointers, the parsing cost is [about half](https://github.com/se3000/gas-tests/blob/master/test/DynamicDynMetaConsumer.js#L46) of [your example](https://github.com/se3000/gas-tests/blob/master/test/DynamicDynMetaConsumer.js#L38). Notably, as more data is passed in the cost grows more quickly when allocating new memory than when moving pointers. Doubling the length of both inputs consumes [~1200 more](https://github.com/se3000/gas-tests/blob/master/test/DynamicDynMetaConsumer.js#L66) with new memory, as opposed to [~300 more](https://github.com/se3000/gas-tests/blob/master/test/DynamicDynMetaConsumer.js#L80) with pointers.\r\n\r\nGas details aside, I continue to believe that the cost of optional fields should be put on the people using the fields, not externalized on the non-users.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/413530199/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/413541919",
    "html_url": "https://github.com/ethereum/EIPs/issues/1161#issuecomment-413541919",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1161",
    "id": 413541919,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQxMzU0MTkxOQ==",
    "user": {
      "login": "se3000",
      "id": 573827,
      "node_id": "MDQ6VXNlcjU3MzgyNw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/573827?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/se3000",
      "html_url": "https://github.com/se3000",
      "followers_url": "https://api.github.com/users/se3000/followers",
      "following_url": "https://api.github.com/users/se3000/following{/other_user}",
      "gists_url": "https://api.github.com/users/se3000/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/se3000/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/se3000/subscriptions",
      "organizations_url": "https://api.github.com/users/se3000/orgs",
      "repos_url": "https://api.github.com/users/se3000/repos",
      "events_url": "https://api.github.com/users/se3000/events{/privacy}",
      "received_events_url": "https://api.github.com/users/se3000/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-08-16T13:16:58Z",
    "updated_at": "2018-08-16T13:16:58Z",
    "author_association": "NONE",
    "body": "Taking a step back, there was a question only briefly touched on at the workshop, which I think it'd be helpful to hear from the wider community: **should an Oracle send data that it can see is false?** It seems to me that it should be the Oracle's responsibility to ensure the data they are sending is correct, so if there is a proof to run on-chain, they should verify it before passing along data.\r\n\r\nIf the Oracle doesn't process the metadata, and pushes that work on to the consumer, then the Consumer loses the interoperability that this standard aims to achieve. Hypothetically, Chainlink decides to use metadata and sends the m-of-n ratio of oracles reported over requested. A Consumer wants to use both Chainlink and Oraclize interchangeably. They now have to deploy both Oraclize metadata checking logic and Chainlink metadata checking logic. Apart from the inefficient duplication of contract code in every Consumer Contract, what happens if a third metadata oracle shows up? The Consumer Contract has to be redeployed, or they can't use the new oracle. Same thing if one oracle updates their metadata format/verification. Obviously redeployment is non-trivial for many dapps. Also, how does the consumer differentiate which type of metadata they're receiving? Maybe we should add a metametadata field? 😉\r\n\r\nMetadata seems intrinsically proprietary, or at the very least non-standardized. For this reason, it seems like metadata should be handled by the oracle before reaching the consumer, or by some higher level on-chain proxy. Consumers should only have to concern themselves with receiving the data and handling it, otherwise they lose interoperability and become dependent on a limited number of parties.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/413541919/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/413616791",
    "html_url": "https://github.com/ethereum/EIPs/issues/1161#issuecomment-413616791",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1161",
    "id": 413616791,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQxMzYxNjc5MQ==",
    "user": {
      "login": "cag",
      "id": 298447,
      "node_id": "MDQ6VXNlcjI5ODQ0Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/298447?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cag",
      "html_url": "https://github.com/cag",
      "followers_url": "https://api.github.com/users/cag/followers",
      "following_url": "https://api.github.com/users/cag/following{/other_user}",
      "gists_url": "https://api.github.com/users/cag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cag/subscriptions",
      "organizations_url": "https://api.github.com/users/cag/orgs",
      "repos_url": "https://api.github.com/users/cag/repos",
      "events_url": "https://api.github.com/users/cag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cag/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-08-16T17:07:00Z",
    "updated_at": "2018-09-05T18:30:20Z",
    "author_association": "CONTRIBUTOR",
    "body": "@se3000 Thanks for the optimization! I see that it uses the same implementation strategy as what you've originally posted (my derp). I'll update the table accordingly...\r\n\r\n- [x] Update table with new measurements using more efficient implementations.\r\n\r\nWith that said, it seems the dominant gas cost comes from the size of the data itself, and not from the parsing of said data.\r\n\r\n---\r\n\r\n> If the Oracle doesn't process the metadata, and pushes that work on to the consumer, then the Consumer loses the interoperability that this standard aims to achieve.\r\n\r\nArguably, this interoperability does not exist in the first place, as the result format isn't specified.\r\n\r\n---\r\n\r\n> should an Oracle send data that it can see is false?\r\n\r\nRight now, the spec indicates:\r\n\r\n> receiveResult MUST revert if receiveResult has been called with the same id before.\r\n\r\nIn line with this requirement, I vote that any adapters for systems using proof metadata should verify the proof before making a report.\r\n\r\nThat said, I do see a potential use case for removing the aforementioned requirement from the spec. What if the consumer needs to punish entities making wrong reports about a subject? That's a case in which the consumer would have to receive the proof metadata as well as report on the same id multiple times.\r\n\r\nStill, I also don't see mechanisms for ensuring data quality (e.g. punitive measures) as the oracle consumer's responsibility, but rather a topic which the oracle should address.\r\n\r\nIn general, any oracle system which requires additional on-chain processing of metadata should justify the inclusion of that cost by simply producing better data. Oracle consumers will want the best data, and the gas cost differences between parsing one or two `bytes` parameters will pale in comparison with the gas cost of processing proof metadata and its value proposition of delivering better data.\r\n\r\nAnyway, I'm still not sold on adding the `metadata` parameter.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/413616791/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/418836592",
    "html_url": "https://github.com/ethereum/EIPs/issues/1161#issuecomment-418836592",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1161",
    "id": 418836592,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQxODgzNjU5Mg==",
    "user": {
      "login": "cag",
      "id": 298447,
      "node_id": "MDQ6VXNlcjI5ODQ0Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/298447?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cag",
      "html_url": "https://github.com/cag",
      "followers_url": "https://api.github.com/users/cag/followers",
      "following_url": "https://api.github.com/users/cag/following{/other_user}",
      "gists_url": "https://api.github.com/users/cag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cag/subscriptions",
      "organizations_url": "https://api.github.com/users/cag/orgs",
      "repos_url": "https://api.github.com/users/cag/repos",
      "events_url": "https://api.github.com/users/cag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cag/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-09-05T18:38:49Z",
    "updated_at": "2018-09-05T18:38:49Z",
    "author_association": "CONTRIBUTOR",
    "body": "@se3000 A small note about your optimization:\r\n\r\n```solidity\r\ncontract DynamicDynMetaConsumer {\r\n    event LogStuff(bytes b, bytes m);\r\n\r\n    function receiveResult(bytes res) external {\r\n        bytes memory resCopy = res; // <- See this line\r\n        bytes memory b;\r\n        bytes memory m;\r\n        assembly {\r\n          b := add(resCopy, 0x20)\r\n          m := add(add(b, 0x20), mload(b))\r\n        }\r\n        emit LogStuff(b, m);\r\n    }\r\n}\r\n```\r\n\r\nThe latest version of Solidity does not automatically copy dynamic types from calldata to memory for a given symbol, instead leaving this up to the contract writer to do so. Still, pointer moving after the data has been copied is the most efficient way I've seen for handling this case.\r\n\r\n---\r\n\r\nI'd also like to remark that the single word cases for both results and metadata readily generalize to _fixed format_ cases, in that their efficiency only relies on the fact that the memory layout in calldata is completely known up front.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/418836592/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
