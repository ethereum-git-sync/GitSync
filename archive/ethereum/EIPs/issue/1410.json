{
  "url": "https://api.github.com/repos/ethereum/EIPs/issues/1410",
  "repository_url": "https://api.github.com/repos/ethereum/EIPs",
  "labels_url": "https://api.github.com/repos/ethereum/EIPs/issues/1410/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/EIPs/issues/1410/comments",
  "events_url": "https://api.github.com/repos/ethereum/EIPs/issues/1410/events",
  "html_url": "https://github.com/ethereum/EIPs/issues/1410",
  "id": 360071511,
  "node_id": "MDU6SXNzdWUzNjAwNzE1MTE=",
  "number": 1410,
  "title": "ERC 1410: Partially Fungible Token Standard",
  "user": {
    "login": "adamdossa",
    "id": 2633913,
    "node_id": "MDQ6VXNlcjI2MzM5MTM=",
    "avatar_url": "https://avatars.githubusercontent.com/u/2633913?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/adamdossa",
    "html_url": "https://github.com/adamdossa",
    "followers_url": "https://api.github.com/users/adamdossa/followers",
    "following_url": "https://api.github.com/users/adamdossa/following{/other_user}",
    "gists_url": "https://api.github.com/users/adamdossa/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/adamdossa/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/adamdossa/subscriptions",
    "organizations_url": "https://api.github.com/users/adamdossa/orgs",
    "repos_url": "https://api.github.com/users/adamdossa/repos",
    "events_url": "https://api.github.com/users/adamdossa/events{/privacy}",
    "received_events_url": "https://api.github.com/users/adamdossa/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 2328627851,
      "node_id": "MDU6TGFiZWwyMzI4NjI3ODUx",
      "url": "https://api.github.com/repos/ethereum/EIPs/labels/stale",
      "name": "stale",
      "color": "000000",
      "default": false,
      "description": ""
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 38,
  "created_at": "2018-09-13T21:22:30Z",
  "updated_at": "2021-12-18T21:11:41Z",
  "closed_at": "2021-12-18T21:11:41Z",
  "author_association": "NONE",
  "active_lock_reason": null,
  "body": "---\r\n\r\neip: ERC-1410\r\ntitle: Partially Fungible Token Standard (part of the ERC-1400 Security Token Standards)\r\nauthor: Adam Dossa (@adamdossa), Pablo Ruiz (@pabloruiz55), Fabian Vogelsteller (@frozeman), Stephane Gosselin (@thegostep)\r\ndiscussions-to: #1411\r\nstatus: Draft\r\ntype: Standards Track\r\ncategory: ERC\r\ncreated: 2018-09-13\r\nrequire: ERC-1066 (#1066)\r\n\r\n---\r\n\r\n## Simple Summary\r\n\r\nA standard interface for organising an owners tokens into a set of partitions.\r\n\r\n## Abstract\r\n\r\nThis standard sits under the ERC-1400 (#1411) umbrella set of standards related to security tokens.\r\n\r\nDescribes an interface to support an owners tokens being grouped into partitions, with each partition being represented by an identifying key and a balance.\r\n\r\nTokens are operated upon at a partition granularity, but data about the overall supply of tokens and overall balances of owners is also tracked.\r\n\r\nThis standard can be combined with ERC-20 (#20) or ERC-777 (#777) to provide an additional layer of granular transparency as to the behaviour of a token contract on different partitions of a token holders balance.\r\n\r\n## Motivation\r\n\r\nBeing able to associate metadata with individual fungible tokens is useful when building functionality associated with those tokens.\r\n\r\nFor example, knowing when an individual token was minted allows vesting or lockup logic to be implemented for a portion of a token holders balance.\r\n\r\nTokens that represent securities often require metadata to be attached to individual tokens, such as restrictions associated with the share.\r\n\r\nBeing able to associate arbitrary metadata with groups of tokens held by users is useful in a variety of use-cases. It can be used for token provenance (i.e. recording the previous owner(s) of tokens) or to attach data to a token which is then used to determine any transfer restrictions of that token.\r\n\r\nIn general it may be that whilst tokens are fungible under some circumstances, they are not under others (for example in-game credits and deposited balances). Being able to define such groupings and operate on them whilst maintaining data about the overall distribution of a token irrespective of this is useful in modelling these types of assets.\r\n\r\nHaving a standard way to identify groupings of tokens within an overall balance helps provides token holders transparency over their balances.\r\n\r\n## Rationale\r\n\r\nA Partially-Fungible Token allows for attaching metadata to a partial balance of a token holder. These partial balances are called partitions and are indexed by a `bytes32 _partition` key which can be associated with metadata on-chain or off-chain.\r\n\r\nThe specification for this metadata, beyond the existence of the `_partition` key to identify it, does not form part of this standard. The token holders address can be paired with the partition to use as a metadata key if data varies across token holders with the same partition (e.g. a \"restricted\" partition may be associated with different lock up dates for each token holder).\r\n\r\nFor an individual owner, each token in a partition therefore shares common metadata.\r\n\r\nToken fungibility includes metadata so we have:\r\n  - for a specific user, tokens within a given partition are fungible\r\n  - for a specific user, tokens from different partitions may not be fungible\r\n\r\nNote - partitions with the same `bytes32` key across different users may be associated with different metadata depending on the implementation.\r\n\r\n## Backwards Compatibility\r\n\r\nThis standard is un-opinionated on ERC-20 vs. ERC-777. It can be easily combined with either standard, and we expect this to usually be the case. We don't define the standard token view functions (`name`, `symbol`, `decimals`) as a consequence.\r\n\r\nIn order to remain backwards compatible with ERC-20 / ERC-777 (and other fungible token standards) it is necessary to define what partition or partitions are used when a `transfer` / `send` operation is executed (i.e. when not explicitly specifying the partition). However this is seen as an implementation detail (could be via a fixed list, or programatically determined). One option is to simple iterate over all `partitionsOf` for the token holder, although this approach needs to be cognisant of block gas limits.\r\n\r\n## Specification\r\n\r\n### Token Information\r\n\r\n#### balanceOf\r\n\r\nAggregates a token holders balances across all partitions. Equivalent to `balanceOf` in the ERC-20/777 specification.\r\n\r\nMUST count the sum of all partition balances assigned to a token holder.\r\n\r\n``` solidity\r\nfunction balanceOf(address _tokenHolder) external view returns (uint256);\r\n```\r\n\r\n#### balanceOfByPartition\r\n\r\nAs well as querying total balances across all partitions through `balanceOf` there may be a need to determine the balance of a specific partition.\r\n\r\nFor a given token holder, the sum of `balanceOfByPartition` across `partitionsOf` MUST be equal to `balanceOf`.\r\n\r\n``` solidity\r\nfunction balanceOfByPartition(bytes32 _partition, address _tokenHolder) external view returns (uint256);\r\n```\r\n\r\n#### partitionsOf\r\n\r\nA token holder may have their balance split into several partitions (partitions) - this function will return all of the partitions that could be associated with a particular token holder address. This can include empty partitions, but MUST include any partitions which have a non-zero balance.\r\n\r\n``` solidity\r\nfunction partitionsOf(address _tokenHolder) external view returns (bytes32[]);\r\n```\r\n\r\n#### totalSupply\r\n\r\nReturns the total amount of tokens issued across all token holders and partitions.\r\n\r\nMUST count all tokens tracked by this contract.\r\n\r\n``` solidity\r\nfunction totalSupply() external view returns (uint256);\r\n```\r\n\r\n### Tokens Transfers\r\n\r\nToken transfers always have an associated source and destination partition, as well as the usual amounts and sender / receiver addresses.\r\n\r\nAs an example, a permissioned token may use partition metadata to enforce transfer restrictions based on:\r\n  - the `_partition` value\r\n  - any additional data associated with the `_partition` value (e.g. a lockup timestamp that may be associated with `_partition`)\r\n  - any details associated with the sender or receiver of tokens (e.g. has their identity been established)\r\n  - the amount of tokens being transferred (e.g. does it respect any daily or other period-based volume restrictions)\r\n  - the `_data` parameter allows the caller to supply any additional authorisation or details associated with the transfer (e.g. signed data from an authorised entity who is permissioned to authorise the transfer)\r\n\r\nOther use-cases include tracking provenance of tokens by associating previous holders with destination partitions.\r\n\r\n#### transferByPartition\r\n\r\nThis function MUST throw if the transfer of tokens is not successful for any reason.\r\n\r\nWhen transferring tokens from a particular partition, it is useful to know on-chain (i.e. not just via an event being fired) the destination partition of those tokens. The destination partition will be determined by the implementation of this function and will vary depending on use-case.\r\n\r\nThe function MUST return the `bytes32 _partition` of the receiver.\r\n\r\nThe `bytes _data` allows arbitrary data to be submitted alongside the transfer, for the token contract to interpret or record. This could be signed data authorising the transfer (e.g. a dynamic whitelist), or provide some input for the token contract to determine the receivers partition.\r\n\r\nThis function MUST emit a `TransferByPartition` event for successful transfers.\r\n\r\n``` solidity\r\nfunction transferByPartition(bytes32 _partition, address _to, uint256 _value, bytes _data) external returns (bytes32);\r\n```\r\n\r\n#### operatorTransferByPartition\r\n\r\nAllows an operator to transfer security tokens on behalf of a token holder, within a specified partition.\r\n\r\nThis function MUST revert if called by an address lacking the appropriate approval as defined by `isOperatorForPartition` or `isOperator`.\r\n\r\nThis function MUST emit a `TransferByPartition` event for successful token transfers, and include the operator address.\r\n\r\nThe return data is interpreted consistently with `transferByPartition`.\r\n\r\n``` solidity\r\nfunction operatorTransferByPartition(bytes32 _partition, address _from, address _to, uint256 _value, bytes _data, bytes _operatorData) external returns (bytes32);\r\n```\r\n\r\n#### canTransferByPartition\r\n\r\nTransfers of partially fungible tokens may fail for a number of reasons, relating either to the token holders partial balance, or rules associated with the partition being transferred.\r\n\r\nThe standard provides an on-chain function to determine whether a transfer will succeed, and return details indicating the reason if the transfer is not valid.\r\n\r\nThese rules can either be defined using smart contracts and on-chain data, or rely on `_data` passed as part of the `transferByPartition` function which could represent authorisation for the transfer (e.g. a signed message by a transfer agent attesting to the validity of this specific transfer).\r\n\r\nThe function will return both a ESC (Ethereum Status Code) following the EIP-1066 standard, and an additional `bytes32` parameter that can be used to define application specific reason codes with additional details (for example the transfer restriction rule responsible for making the transfer operation invalid).\r\n\r\nIt also returns the destination partition of the tokens being transferred in an analogous way to `transferByPartition`.\r\n\r\n``` solidity\r\nfunction canTransferByPartition(address _from, address _to, bytes32 _partition, uint256 _value, bytes _data) external view returns (byte, bytes32, bytes32);\r\n```\r\n\r\n### Operators\r\n\r\nOperators can be authorised by individual token holders for either all partitions, or a specific partition.\r\n\r\n  - a specific token holder and all partitions (`authorizeOperator`, `revokeOperator`, `isOperator`)\r\n  - a specific token holder for a specific partition (`authorizeOperatorByPartition`, `revokeOperatorByPartition`, `isOperatorForPartition`)\r\n\r\n#### authorizeOperator\r\n\r\nAllows a token holder to set an operator for their tokens across all partitions.\r\n\r\nMUST authorise an operator for all partitions of `msg.sender`\r\n\r\nThis function MUST emit the event `AuthorizedOperator` every time it is called.\r\n\r\n``` solidity\r\nfunction authorizeOperator(address _operator) external;\r\n```\r\n\r\n#### revokeOperator\r\n\r\nAllows a token holder to revoke an operator for their tokens across all partitions.\r\n\r\nNB - it is possible the operator will retain authorisation over this token holder and some partitions through `authorizeOperatorByPartition`.\r\n\r\nMUST revoke authorisation of an operator previously given for all partitions of `msg.sender`\r\n\r\nThis function MUST emit the event `RevokedOperator` every time it is called.\r\n\r\n``` solidity\r\nfunction revokeOperator(address _operator) external;\r\n```\r\n\r\n#### isOperator\r\n\r\nReturns whether a specified address is an operator for the given token holder and all partitions.\r\n\r\nThis should return TRUE if the address is an operator under any of the above categories.\r\n\r\nMUST query whether `_operator` is an operator for all partitions of `_tokenHolder`.\r\n\r\n``` solidity\r\nfunction isOperator(address _operator, address _tokenHolder) external view returns (bool);\r\n```\r\n\r\n#### authorizeOperatorByPartition\r\n\r\nAllows a token holder to set an operator for their tokens on a specific partition.\r\n\r\nThis function MUST emit the event `AuthorizedOperatorByPartition` every time it is called.\r\n\r\n``` solidity\r\nfunction authorizeOperatorByPartition(bytes32 _partition, address _operator) external;\r\n```\r\n\r\n#### revokeOperatorByPartition\r\n\r\nAllows a token holder to revoke an operator for their tokens on a specific partition.\r\n\r\nNB - it is possible the operator will retain authorisation over this token holder and partition through either `defaultOperatorsByPartition` or `defaultOperators`.\r\n\r\nThis function MUST emit the event `RevokedOperatorByPartition` every time it is called.\r\n\r\n``` solidity\r\nfunction revokeOperatorByPartition(bytes32 _partition, address _operator) external;\r\n```\r\n\r\n#### isOperatorForPartition\r\n\r\nReturns whether a specified address is an operator for the given token holder and partition.\r\n\r\nThis should return TRUE if the address is an operator under any of the above categories.\r\n\r\n``` solidity\r\nfunction isOperatorForPartition(bytes32 _partition, address _operator, address _tokenHolder) external view returns (bool);\r\n```\r\n\r\n## Interface\r\n\r\n``` solidity\r\n/// @title ERC-1410 Partially Fungible Token Standard\r\n/// @dev See https://github.com/SecurityTokenStandard/EIP-Spec\r\n\r\ninterface IERC1410 {\r\n\r\n    // Token Information\r\n    function balanceOf(address _tokenHolder) external view returns (uint256);\r\n    function balanceOfByPartition(bytes32 _partition, address _tokenHolder) external view returns (uint256);\r\n    function partitionsOf(address _tokenHolder) external view returns (bytes32[]);\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    // Token Transfers\r\n    function transferByPartition(bytes32 _partition, address _to, uint256 _value, bytes _data) external returns (bytes32);\r\n    function operatorTransferByPartition(bytes32 _partition, address _from, address _to, uint256 _value, bytes _data, bytes _operatorData) external returns (bytes32);\r\n    function canTransferByPartition(address _from, address _to, bytes32 _partition, uint256 _value, bytes _data) external view returns (byte, bytes32, bytes32);    \r\n\r\n    // Operator Information\r\n    function isOperator(address _operator, address _tokenHolder) external view returns (bool);\r\n    function isOperatorForPartition(bytes32 _partition, address _operator, address _tokenHolder) external view returns (bool);\r\n\r\n    // Operator Management\r\n    function authorizeOperator(address _operator) external;\r\n    function revokeOperator(address _operator) external;\r\n    function authorizeOperatorByPartition(bytes32 _partition, address _operator) external;\r\n    function revokeOperatorByPartition(bytes32 _partition, address _operator) external;\r\n\r\n    // Issuance / Redemption\r\n    function issueByPartition(bytes32 _partition, address _tokenHolder, uint256 _value, bytes _data) external;\r\n    function redeemByPartition(bytes32 _partition, uint256 _value, bytes _data) external;\r\n    function operatorRedeemByPartition(bytes32 _partition, address _tokenHolder, uint256 _value, bytes _operatorData) external;\r\n\r\n    // Transfer Events\r\n    event TransferByPartition(\r\n        bytes32 indexed _fromPartition,\r\n        address _operator,\r\n        address indexed _from,\r\n        address indexed _to,\r\n        uint256 _value,\r\n        bytes _data,\r\n        bytes _operatorData\r\n    );\r\n\r\n    // Operator Events\r\n    event AuthorizedOperator(address indexed operator, address indexed tokenHolder);\r\n    event RevokedOperator(address indexed operator, address indexed tokenHolder);\r\n    event AuthorizedOperatorByPartition(bytes32 indexed partition, address indexed operator, address indexed tokenHolder);\r\n    event RevokedOperatorByPartition(bytes32 indexed partition, address indexed operator, address indexed tokenHolder);\r\n\r\n    // Issuance / Redemption Events\r\n    event IssuedByPartition(bytes32 indexed partition, address indexed operator, address indexed to, uint256 amount, bytes data, bytes operatorData);\r\n    event RedeemedByPartition(bytes32 indexed partition, address indexed operator, address indexed from, uint256 amount, bytes operatorData);\r\n\r\n}\r\n```",
  "closed_by": {
    "login": "github-actions[bot]",
    "id": 41898282,
    "node_id": "MDM6Qm90NDE4OTgyODI=",
    "avatar_url": "https://avatars.githubusercontent.com/in/15368?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/github-actions%5Bbot%5D",
    "html_url": "https://github.com/apps/github-actions",
    "followers_url": "https://api.github.com/users/github-actions%5Bbot%5D/followers",
    "following_url": "https://api.github.com/users/github-actions%5Bbot%5D/following{/other_user}",
    "gists_url": "https://api.github.com/users/github-actions%5Bbot%5D/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/github-actions%5Bbot%5D/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/github-actions%5Bbot%5D/subscriptions",
    "organizations_url": "https://api.github.com/users/github-actions%5Bbot%5D/orgs",
    "repos_url": "https://api.github.com/users/github-actions%5Bbot%5D/repos",
    "events_url": "https://api.github.com/users/github-actions%5Bbot%5D/events{/privacy}",
    "received_events_url": "https://api.github.com/users/github-actions%5Bbot%5D/received_events",
    "type": "Bot",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/1410/reactions",
    "total_count": 10,
    "+1": 10,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/EIPs/issues/1410/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/421425886",
    "html_url": "https://github.com/ethereum/EIPs/issues/1410#issuecomment-421425886",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1410",
    "id": 421425886,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQyMTQyNTg4Ng==",
    "user": {
      "login": "fubuloubu",
      "id": 3859395,
      "node_id": "MDQ6VXNlcjM4NTkzOTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3859395?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fubuloubu",
      "html_url": "https://github.com/fubuloubu",
      "followers_url": "https://api.github.com/users/fubuloubu/followers",
      "following_url": "https://api.github.com/users/fubuloubu/following{/other_user}",
      "gists_url": "https://api.github.com/users/fubuloubu/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fubuloubu/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fubuloubu/subscriptions",
      "organizations_url": "https://api.github.com/users/fubuloubu/orgs",
      "repos_url": "https://api.github.com/users/fubuloubu/repos",
      "events_url": "https://api.github.com/users/fubuloubu/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fubuloubu/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-09-14T17:16:56Z",
    "updated_at": "2018-09-14T17:22:02Z",
    "author_association": "MEMBER",
    "body": "Operators may not be required when using this ERC. I would suggest the functionality relating to operators be separated in the interface and described as optional to support use cases where it is not required for the functionality of an SFT.\r\n\r\nThe implication of this is that the `SentByTranche` and `BurnedByTranche` events may need separate operator-specific versions to account for the additional data required by having operators.\r\n\r\ne.g. `SentByTrancheOperator` and `BurnedByTrancheOperator`",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/421425886/reactions",
      "total_count": 7,
      "+1": 5,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 2,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/421497705",
    "html_url": "https://github.com/ethereum/EIPs/issues/1410#issuecomment-421497705",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1410",
    "id": 421497705,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQyMTQ5NzcwNQ==",
    "user": {
      "login": "fubuloubu",
      "id": 3859395,
      "node_id": "MDQ6VXNlcjM4NTkzOTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3859395?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fubuloubu",
      "html_url": "https://github.com/fubuloubu",
      "followers_url": "https://api.github.com/users/fubuloubu/followers",
      "following_url": "https://api.github.com/users/fubuloubu/following{/other_user}",
      "gists_url": "https://api.github.com/users/fubuloubu/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fubuloubu/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fubuloubu/subscriptions",
      "organizations_url": "https://api.github.com/users/fubuloubu/orgs",
      "repos_url": "https://api.github.com/users/fubuloubu/repos",
      "events_url": "https://api.github.com/users/fubuloubu/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fubuloubu/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-09-14T22:12:12Z",
    "updated_at": "2018-09-14T22:13:19Z",
    "author_association": "MEMBER",
    "body": "`setDefaultTranche` takes as an argument multiple tranches... That doesn't make sense to me. You shouldn't be able to specify multiple \"defaults\" because a default means only one choice is delegated. Is the intention to allow the user to specify an order to the which the tranches should resolve? (i.e. this one first, then that one, then that one over there, ... and finally, this one!)\r\n\r\nIf that is the case, I would use some other terminology because that is confusing.\r\n\r\n---\r\n\r\nAlso, I think that the \"multiple send\" variants of the functions specified by the standard (`sendByTranches` and `operatorSendByTranches`) should perhaps be optional or suggested. It has not been typical to a standard to define a mechanism for multiple transfers as there may be multiple ways one might like to perform it.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/421497705/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/421941401",
    "html_url": "https://github.com/ethereum/EIPs/issues/1410#issuecomment-421941401",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1410",
    "id": 421941401,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQyMTk0MTQwMQ==",
    "user": {
      "login": "adamdossa",
      "id": 2633913,
      "node_id": "MDQ6VXNlcjI2MzM5MTM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2633913?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/adamdossa",
      "html_url": "https://github.com/adamdossa",
      "followers_url": "https://api.github.com/users/adamdossa/followers",
      "following_url": "https://api.github.com/users/adamdossa/following{/other_user}",
      "gists_url": "https://api.github.com/users/adamdossa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/adamdossa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/adamdossa/subscriptions",
      "organizations_url": "https://api.github.com/users/adamdossa/orgs",
      "repos_url": "https://api.github.com/users/adamdossa/repos",
      "events_url": "https://api.github.com/users/adamdossa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/adamdossa/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-09-17T09:24:15Z",
    "updated_at": "2018-09-17T09:24:15Z",
    "author_association": "NONE",
    "body": "@fubuloubu\r\n\r\nre. `setDefaultTranche`\r\n\r\nMy thinking was that you may want to be able to transfer from multiple tranches when using the `send` / `transfer` functions defined in ERC777 / ERC20.\r\n\r\nFor example, you could define a users default tranches as `tranchesOf(user)` which would effectively make the token transparent from an ERC777 / ERC20 perspective (with the exception of any additional logic used under the covers by `sendByTranche` to manage transfers).\r\n\r\nThis does however imply that the ordering of `defaultTranches` is important, i.e.:\r\n\r\nSuppose Alice calls `transfer(Bob, 100)` with `defaultTranches` being [`tranche_1`, `tranche_2`], then this could be interpreted as:\r\n\r\n1. transfer up to 100 tokens from `tranche_1`\r\n2. transfer any remaining tokens (100 - (number of tokens submitted in 1.)) from `tranche_2`\r\n3. if it wasn't possible to transfer a total of 100 tokens, then revert\r\n\r\n`sendByTranches` could then be interpreted in the same way, although it would then make sense to change the signature from:  \r\n`function sendByTranches(bytes32[] _tranches, address[] _tos, uint256[] _amounts, bytes _data) external returns (bytes32[]);`  \r\nto:  \r\n`function sendByTranches(bytes32[] _tranches, address _to, uint256 _amount, bytes _data) external returns (bytes32);`  \r\nso that it is consistent with this.\r\n\r\nThis opens up another question which is whether the `sendByTranche` functions should return (bytes32[], uint256[]) to cover the case that the token contract transfers the balances into multiple tranches for the receiver so should return the set of tranches, and the balances transferred into each.\r\n\r\nThese \"multiple send\" functions are then a bit different to the more common `batchTransfer` type functions as they are still a single atomic action (transferring tokens from `msg.sender` to another user) just that the source tranches and corresponding destination tranches may not be singular.\r\n\r\nInterested in your thoughts on the above! Will think about the best way to clarify the operators within this EIP.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/421941401/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/422020074",
    "html_url": "https://github.com/ethereum/EIPs/issues/1410#issuecomment-422020074",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1410",
    "id": 422020074,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQyMjAyMDA3NA==",
    "user": {
      "login": "fubuloubu",
      "id": 3859395,
      "node_id": "MDQ6VXNlcjM4NTkzOTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3859395?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fubuloubu",
      "html_url": "https://github.com/fubuloubu",
      "followers_url": "https://api.github.com/users/fubuloubu/followers",
      "following_url": "https://api.github.com/users/fubuloubu/following{/other_user}",
      "gists_url": "https://api.github.com/users/fubuloubu/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fubuloubu/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fubuloubu/subscriptions",
      "organizations_url": "https://api.github.com/users/fubuloubu/orgs",
      "repos_url": "https://api.github.com/users/fubuloubu/repos",
      "events_url": "https://api.github.com/users/fubuloubu/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fubuloubu/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-09-17T13:39:13Z",
    "updated_at": "2018-09-17T13:39:13Z",
    "author_association": "MEMBER",
    "body": "Yeah, the ordering thing I think is very important if you are attempting to define complex transfers within the standard. If you left it as one default, that would be equally as useful if the transfers were more straightforward.\r\n\r\nWhen I was originally thinking of my own PFT use case, I was considering the \"tranches\" to be an enumeration, such that I could specify a global order within the standard by just numbering them in that way. It makes sense that different users may want to specify different orders though, it just becomes much more difficult to deal with.\r\n\r\nRemoving the ability to send multiple tranches is an option that may be useful. It makes the underlying implementation a bit simpler to deal with, although clients would then need to submit multiple requests if moving from different tranches. But, in my opinion, clearer is better.\r\n\r\nLastly, the event `SentByTranche` does not compile with 0.4.25. You can only have 3 indexed arguments to an event. It seems like you are attempting to define a \"conversion\" inside that event, basically that you can send from one tranch and into another. I would think conversions would have more complex rules governing when they are appropriate to conduct. A separate event may be better to convey this.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/422020074/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/424502820",
    "html_url": "https://github.com/ethereum/EIPs/issues/1410#issuecomment-424502820",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1410",
    "id": 424502820,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQyNDUwMjgyMA==",
    "user": {
      "login": "fubuloubu",
      "id": 3859395,
      "node_id": "MDQ6VXNlcjM4NTkzOTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3859395?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fubuloubu",
      "html_url": "https://github.com/fubuloubu",
      "followers_url": "https://api.github.com/users/fubuloubu/followers",
      "following_url": "https://api.github.com/users/fubuloubu/following{/other_user}",
      "gists_url": "https://api.github.com/users/fubuloubu/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fubuloubu/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fubuloubu/subscriptions",
      "organizations_url": "https://api.github.com/users/fubuloubu/orgs",
      "repos_url": "https://api.github.com/users/fubuloubu/repos",
      "events_url": "https://api.github.com/users/fubuloubu/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fubuloubu/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-09-25T21:11:07Z",
    "updated_at": "2018-09-25T21:11:07Z",
    "author_association": "MEMBER",
    "body": "Another potential use case: Coin voting\r\n\r\nA token could have a voting flow that would taint coins already used for voting, \"locking\" them against the possibility of future voting by disallowing re-use of tainted tokens until the voting was over. This would be an excellent tool against concerns arising from non-locking token votes, where users can simply transfer their tokens to a new address to get around vote sanctions on token holders.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/424502820/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/424820649",
    "html_url": "https://github.com/ethereum/EIPs/issues/1410#issuecomment-424820649",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1410",
    "id": 424820649,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQyNDgyMDY0OQ==",
    "user": {
      "login": "adamdossa",
      "id": 2633913,
      "node_id": "MDQ6VXNlcjI2MzM5MTM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2633913?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/adamdossa",
      "html_url": "https://github.com/adamdossa",
      "followers_url": "https://api.github.com/users/adamdossa/followers",
      "following_url": "https://api.github.com/users/adamdossa/following{/other_user}",
      "gists_url": "https://api.github.com/users/adamdossa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/adamdossa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/adamdossa/subscriptions",
      "organizations_url": "https://api.github.com/users/adamdossa/orgs",
      "repos_url": "https://api.github.com/users/adamdossa/repos",
      "events_url": "https://api.github.com/users/adamdossa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/adamdossa/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-09-26T18:24:12Z",
    "updated_at": "2018-09-26T18:24:12Z",
    "author_association": "NONE",
    "body": "@all We have scheduled a second community call for 11am EST, Tuesday, October 2nd.\r\n\r\nWe will try using Zoom this time as we hit the 25 attendee limit on Google Hangouts on the last call. \r\n\r\nEthereum Magicians thread for the call is at:\r\nhttps://ethereum-magicians.org/t/community-call-erc1400-feedback-discussion-questions/1475\r\nwe will make sure this stays updated.\r\n\r\nPlease use the HackMD document linked here to add any agenda items and your details if you're able to attend.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/424820649/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/425182331",
    "html_url": "https://github.com/ethereum/EIPs/issues/1410#issuecomment-425182331",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1410",
    "id": 425182331,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQyNTE4MjMzMQ==",
    "user": {
      "login": "adamdossa",
      "id": 2633913,
      "node_id": "MDQ6VXNlcjI2MzM5MTM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2633913?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/adamdossa",
      "html_url": "https://github.com/adamdossa",
      "followers_url": "https://api.github.com/users/adamdossa/followers",
      "following_url": "https://api.github.com/users/adamdossa/following{/other_user}",
      "gists_url": "https://api.github.com/users/adamdossa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/adamdossa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/adamdossa/subscriptions",
      "organizations_url": "https://api.github.com/users/adamdossa/orgs",
      "repos_url": "https://api.github.com/users/adamdossa/repos",
      "events_url": "https://api.github.com/users/adamdossa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/adamdossa/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-09-27T17:45:35Z",
    "updated_at": "2018-09-27T17:45:35Z",
    "author_association": "NONE",
    "body": "@fubuloubu - re. tranches as an enumeration - I’ve been thinking of them more like primary keys for metadata. So they could be something like `gold`, `silver` & `bronze`. Alternatively if you have more than one type of metadata you can still partition by tranches by using a hash of the metadata types as the tranche name (e.g. `hash(locked, voting)`, `hash(unlocked, voting)`) - this way if a token holder receives tokens with the same metadata types, they’ll continue to be grouped together.\r\n\r\nI wrote a medium article explaining a bit more along these lines:\r\nhttps://blog.polymath.network/what-do-in-game-credits-plasma-cash-and-security-tokens-have-in-common-1b490843ab85\r\n\r\nI cleaned up the:  \r\n```\r\nfunction sendByTranches(bytes32[] _tranches, address _to, uint256[] _amounts, bytes _data) external returns (bytes32[]);\r\nfunction operatorSendByTranches(bytes32[] _tranches, address _from, address _to, uint256[] _amounts, bytes _data, bytes _operatorData) external returns (bytes32[]);\r\n```\r\nto take multiple tranche values but a single destination address.\r\n\r\nI split out the change of tranche from the `SentByTranche` event and de-indexed the `operator` (which fields are indexed kind of feels like an implementation detail).\r\n\r\nI moved the `redeemByTranche` and `operatorRedeemByTranche` up to the security token standard so as to not specify minting / burning mechanics at the PFT level.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/425182331/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/425226067",
    "html_url": "https://github.com/ethereum/EIPs/issues/1410#issuecomment-425226067",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1410",
    "id": 425226067,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQyNTIyNjA2Nw==",
    "user": {
      "login": "fubuloubu",
      "id": 3859395,
      "node_id": "MDQ6VXNlcjM4NTkzOTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3859395?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fubuloubu",
      "html_url": "https://github.com/fubuloubu",
      "followers_url": "https://api.github.com/users/fubuloubu/followers",
      "following_url": "https://api.github.com/users/fubuloubu/following{/other_user}",
      "gists_url": "https://api.github.com/users/fubuloubu/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fubuloubu/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fubuloubu/subscriptions",
      "organizations_url": "https://api.github.com/users/fubuloubu/orgs",
      "repos_url": "https://api.github.com/users/fubuloubu/repos",
      "events_url": "https://api.github.com/users/fubuloubu/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fubuloubu/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-09-27T20:08:43Z",
    "updated_at": "2018-09-27T20:08:43Z",
    "author_association": "MEMBER",
    "body": "For simplicity's sake, can the base standard have `sendByTranche` (singular send) as the required functionality for specifying a specific send pattern from one particular tranche, and have `sendByTranches` (multiple send) be optional syntax. Different implementations might have different assumptions on \"priority\" for sending by tranches, and the multiple send can be a wrapper around the singular sends, or implement alternative priority mechanisms as needed. This way, a user always has access to a simple function to move some amount of a particular tranche to a particular person without being locked in to how that contract leverages it's particular priority scheme.\r\n\r\nFor example, you might want to send amounts from tranches A, B, and C, but they have complicated inter-dependancies leading you to only send one at a time. The basic \"singular send\" would let you do that independantly if the multiple send was failing due to those dependencies. I believe strongly the basic sending mechanism be as atomic as possible without involving too much complexity in the priority scheme of handling multiple tranches.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/425226067/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/425776256",
    "html_url": "https://github.com/ethereum/EIPs/issues/1410#issuecomment-425776256",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1410",
    "id": 425776256,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQyNTc3NjI1Ng==",
    "user": {
      "login": "jllaw",
      "id": 5771238,
      "node_id": "MDQ6VXNlcjU3NzEyMzg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5771238?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jllaw",
      "html_url": "https://github.com/jllaw",
      "followers_url": "https://api.github.com/users/jllaw/followers",
      "following_url": "https://api.github.com/users/jllaw/following{/other_user}",
      "gists_url": "https://api.github.com/users/jllaw/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jllaw/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jllaw/subscriptions",
      "organizations_url": "https://api.github.com/users/jllaw/orgs",
      "repos_url": "https://api.github.com/users/jllaw/repos",
      "events_url": "https://api.github.com/users/jllaw/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jllaw/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-10-01T02:47:09Z",
    "updated_at": "2018-10-01T02:47:09Z",
    "author_association": "NONE",
    "body": "Interesting dialog.  I'm not technical, so I can't follow the technical discussion fully, but happy to contribute knowledge for my experience in finance and in law.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/425776256/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/425776596",
    "html_url": "https://github.com/ethereum/EIPs/issues/1410#issuecomment-425776596",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1410",
    "id": 425776596,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQyNTc3NjU5Ng==",
    "user": {
      "login": "jllaw",
      "id": 5771238,
      "node_id": "MDQ6VXNlcjU3NzEyMzg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5771238?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jllaw",
      "html_url": "https://github.com/jllaw",
      "followers_url": "https://api.github.com/users/jllaw/followers",
      "following_url": "https://api.github.com/users/jllaw/following{/other_user}",
      "gists_url": "https://api.github.com/users/jllaw/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jllaw/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jllaw/subscriptions",
      "organizations_url": "https://api.github.com/users/jllaw/orgs",
      "repos_url": "https://api.github.com/users/jllaw/repos",
      "events_url": "https://api.github.com/users/jllaw/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jllaw/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-10-01T02:50:24Z",
    "updated_at": "2018-10-01T02:50:24Z",
    "author_association": "NONE",
    "body": "@adamdossa Would #1410 be helpful for distinguishing between affiliate and non-affiliate tokens?  Also, are there mechanisms to expand or contract a tranche, or convert one tranche into another tranche?  Apologies, if this should be clear from the code; you know I'm not technically inclined.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/425776596/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/426257529",
    "html_url": "https://github.com/ethereum/EIPs/issues/1410#issuecomment-426257529",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1410",
    "id": 426257529,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQyNjI1NzUyOQ==",
    "user": {
      "login": "adamdossa",
      "id": 2633913,
      "node_id": "MDQ6VXNlcjI2MzM5MTM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2633913?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/adamdossa",
      "html_url": "https://github.com/adamdossa",
      "followers_url": "https://api.github.com/users/adamdossa/followers",
      "following_url": "https://api.github.com/users/adamdossa/following{/other_user}",
      "gists_url": "https://api.github.com/users/adamdossa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/adamdossa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/adamdossa/subscriptions",
      "organizations_url": "https://api.github.com/users/adamdossa/orgs",
      "repos_url": "https://api.github.com/users/adamdossa/repos",
      "events_url": "https://api.github.com/users/adamdossa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/adamdossa/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-10-02T12:38:14Z",
    "updated_at": "2018-10-02T12:38:14Z",
    "author_association": "NONE",
    "body": "@jllaw - Yep - you could distinguish between affiliate / non-affiliate tokens using tranches (i.e. having a tranche called `affiliate` and a tranche called `non-affiliate`, or by associating these tags with whatever tranche names you choose).\r\n\r\nIt is possible to move tokens between tranches (e.g. from non-affiliate to affiliate) and this logic can be determined on-chain (in the `sendByTranche` functions) or use off-chain data (`bytes _data`) to drive the change. If you wanted to move tokens between tranches for a single user (rather than as a result of transferring tokens between users) that user could just transfer tokens to themselves with the above logic.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/426257529/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/427845769",
    "html_url": "https://github.com/ethereum/EIPs/issues/1410#issuecomment-427845769",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1410",
    "id": 427845769,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQyNzg0NTc2OQ==",
    "user": {
      "login": "morpheus499",
      "id": 43952680,
      "node_id": "MDQ6VXNlcjQzOTUyNjgw",
      "avatar_url": "https://avatars.githubusercontent.com/u/43952680?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/morpheus499",
      "html_url": "https://github.com/morpheus499",
      "followers_url": "https://api.github.com/users/morpheus499/followers",
      "following_url": "https://api.github.com/users/morpheus499/following{/other_user}",
      "gists_url": "https://api.github.com/users/morpheus499/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/morpheus499/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/morpheus499/subscriptions",
      "organizations_url": "https://api.github.com/users/morpheus499/orgs",
      "repos_url": "https://api.github.com/users/morpheus499/repos",
      "events_url": "https://api.github.com/users/morpheus499/events{/privacy}",
      "received_events_url": "https://api.github.com/users/morpheus499/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-10-08T14:01:29Z",
    "updated_at": "2018-10-08T14:01:29Z",
    "author_association": "NONE",
    "body": "What’s the point of having the standards so specific they are practically designed to work for specific platforms? You might want to have a look at ERC-1462\r\n(https://github.com/AtlantPlatform/BaseSecurityToken/). It’s a really general standard for security tokens, unlike the proprietary methods 1400 and others trying to pump their own projects and hidden agendas. The new standard for security tokens should support as many use-cases as possible, so all teams can start embracing it such as ERC 20.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/427845769/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/427869049",
    "html_url": "https://github.com/ethereum/EIPs/issues/1410#issuecomment-427869049",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1410",
    "id": 427869049,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQyNzg2OTA0OQ==",
    "user": {
      "login": "fubuloubu",
      "id": 3859395,
      "node_id": "MDQ6VXNlcjM4NTkzOTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3859395?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fubuloubu",
      "html_url": "https://github.com/fubuloubu",
      "followers_url": "https://api.github.com/users/fubuloubu/followers",
      "following_url": "https://api.github.com/users/fubuloubu/following{/other_user}",
      "gists_url": "https://api.github.com/users/fubuloubu/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fubuloubu/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fubuloubu/subscriptions",
      "organizations_url": "https://api.github.com/users/fubuloubu/orgs",
      "repos_url": "https://api.github.com/users/fubuloubu/repos",
      "events_url": "https://api.github.com/users/fubuloubu/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fubuloubu/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-10-08T15:01:34Z",
    "updated_at": "2018-10-08T15:01:34Z",
    "author_association": "MEMBER",
    "body": "Well, I think that's unfair. This team has taken advice to segregate different parts of their proposal that had alternative use cases (like this PFT spec) with the goal of advancing other possible use cases.\r\n\r\nI know I have been interested in a partially fungible token spec exploring ideas I've had with reputation tokens, which may be held in different contexts.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/427869049/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/428131494",
    "html_url": "https://github.com/ethereum/EIPs/issues/1410#issuecomment-428131494",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1410",
    "id": 428131494,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQyODEzMTQ5NA==",
    "user": {
      "login": "adamdossa",
      "id": 2633913,
      "node_id": "MDQ6VXNlcjI2MzM5MTM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2633913?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/adamdossa",
      "html_url": "https://github.com/adamdossa",
      "followers_url": "https://api.github.com/users/adamdossa/followers",
      "following_url": "https://api.github.com/users/adamdossa/following{/other_user}",
      "gists_url": "https://api.github.com/users/adamdossa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/adamdossa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/adamdossa/subscriptions",
      "organizations_url": "https://api.github.com/users/adamdossa/orgs",
      "repos_url": "https://api.github.com/users/adamdossa/repos",
      "events_url": "https://api.github.com/users/adamdossa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/adamdossa/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-10-09T09:51:57Z",
    "updated_at": "2018-10-09T09:51:57Z",
    "author_association": "NONE",
    "body": "@morpheus499 we don't have a hidden agenda beyond trying to push forward the conversation on standards for security tokens (and other more sophisticated token types). I have looked at ERC 1462 and there is certainly an argument for a simpler standard which we've discussed openly on our open community calls.\r\n\r\nMy view is that it is better to try and design a future proofed standard that acknowledges that tokens can be more complex than what is easily represented with ERC20 - some of the potential use-cases for more sophisticated tokens (outside of security tokens) are in the article:  \r\nhttps://blog.polymath.network/what-do-in-game-credits-plasma-cash-and-security-tokens-have-in-common-1b490843ab85\r\n\r\nBeing able to check the validity of transactions before executing them (which is covered by #1462) is certainly one part of the puzzle, but IMO we also need the other parts (differentiated ownership, ability to inject off-chain data into transfer operations and so on).",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/428131494/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/428356469",
    "html_url": "https://github.com/ethereum/EIPs/issues/1410#issuecomment-428356469",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1410",
    "id": 428356469,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQyODM1NjQ2OQ==",
    "user": {
      "login": "macalinao",
      "id": 401263,
      "node_id": "MDQ6VXNlcjQwMTI2Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/401263?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/macalinao",
      "html_url": "https://github.com/macalinao",
      "followers_url": "https://api.github.com/users/macalinao/followers",
      "following_url": "https://api.github.com/users/macalinao/following{/other_user}",
      "gists_url": "https://api.github.com/users/macalinao/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/macalinao/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/macalinao/subscriptions",
      "organizations_url": "https://api.github.com/users/macalinao/orgs",
      "repos_url": "https://api.github.com/users/macalinao/repos",
      "events_url": "https://api.github.com/users/macalinao/events{/privacy}",
      "received_events_url": "https://api.github.com/users/macalinao/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-10-09T21:19:47Z",
    "updated_at": "2018-10-09T21:20:06Z",
    "author_association": "NONE",
    "body": "Hey all, I had a great chat with @thegostep today. I think ERC20 compatibility is really important for many reasons, so I have a proposal for an implementation that preserves this past the idea of “default tranches”. \r\n\r\n```solidity\r\n    contract ERC1410v2Tranche extends ERC20 {\r\n       function getTrancheId() public view returns (bytes32 trancheId);\r\n    }\r\n    \r\n    contract ERC1410v2 extends ERC1410 {\r\n       mapping (bytes32 => ERC1410v2Tranche) tranches;\r\n       \r\n       constructor() public {\r\n          tranches[keccak256(\"gold\")] = new ERC1410v2Tranche();\r\n          tranches[keccak256(\"silver\")] = new ERC1410v2Tranche();\r\n       }\r\n    \r\n        function balanceOfByTranche(bytes32 _tranche, address _tokenHolder) external view returns (uint256) {\r\n        require(tranches[_tranche] != address(0));\r\n        return tranches[_tranche].balanceOf(_tokenHolder);\r\n        }\r\n      // ...\r\n    }\r\n```\r\n\r\nDownsides:\r\n\r\n- higher deployment costs\r\n- larger code complexity (if someone is writing their own)\r\n  - mitigated by having good documentation and SDKs. This is not as complicated as, say, ERC 735.\r\n- infeasible with micro-tranches (e.g. if there are hundreds or thousands of tranches)\r\n\r\nUpsides:\r\n\r\n- backwards compatibility with ERC20\r\n  - what if someone wants to use a governance platform built on ERC20? (aragon?)\r\n  - what if someone wants to use a wallet built on ERC20? (metamask?)\r\n  - what if someone wants to see transaction history through an ERC20 browser? (etherscan?)\r\n  - There are lots of benefits to being backwards compatible.\r\n- Easier to reason about different transfer restrictions per tranche, e.g. affiliate vs non-affiliate tranches\r\n- Modularity is generally a good thing\r\n- Upgradeable tranches\r\n- Easier to add a new tranche with different logic\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/428356469/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/429566790",
    "html_url": "https://github.com/ethereum/EIPs/issues/1410#issuecomment-429566790",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1410",
    "id": 429566790,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQyOTU2Njc5MA==",
    "user": {
      "login": "adamdossa",
      "id": 2633913,
      "node_id": "MDQ6VXNlcjI2MzM5MTM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2633913?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/adamdossa",
      "html_url": "https://github.com/adamdossa",
      "followers_url": "https://api.github.com/users/adamdossa/followers",
      "following_url": "https://api.github.com/users/adamdossa/following{/other_user}",
      "gists_url": "https://api.github.com/users/adamdossa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/adamdossa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/adamdossa/subscriptions",
      "organizations_url": "https://api.github.com/users/adamdossa/orgs",
      "repos_url": "https://api.github.com/users/adamdossa/repos",
      "events_url": "https://api.github.com/users/adamdossa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/adamdossa/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-10-13T18:59:48Z",
    "updated_at": "2018-10-13T18:59:48Z",
    "author_association": "NONE",
    "body": "As part of the Ethereum Magicians hosted Council of Prague before DevCon some of us will be attending the Token Ring (Monday 29th October) to discuss ERC 1400 / security token standards.\r\n\r\nSome links to sign up for this and mark your attendance are:\r\nhttps://github.com/ethereum-magicians/scrolls/wiki/Council-of-Prague-Agenda\r\nhttps://www.picatic.com/ethmagicians-prague-2018\r\nhttps://hackmd.io/DaJhrasLQteUk3IwX5bQAg#7-Token-Ring",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/429566790/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/433366786",
    "html_url": "https://github.com/ethereum/EIPs/issues/1410#issuecomment-433366786",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1410",
    "id": 433366786,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzMzM2Njc4Ng==",
    "user": {
      "login": "satyamakgec",
      "id": 14581509,
      "node_id": "MDQ6VXNlcjE0NTgxNTA5",
      "avatar_url": "https://avatars.githubusercontent.com/u/14581509?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/satyamakgec",
      "html_url": "https://github.com/satyamakgec",
      "followers_url": "https://api.github.com/users/satyamakgec/followers",
      "following_url": "https://api.github.com/users/satyamakgec/following{/other_user}",
      "gists_url": "https://api.github.com/users/satyamakgec/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/satyamakgec/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/satyamakgec/subscriptions",
      "organizations_url": "https://api.github.com/users/satyamakgec/orgs",
      "repos_url": "https://api.github.com/users/satyamakgec/repos",
      "events_url": "https://api.github.com/users/satyamakgec/events{/privacy}",
      "received_events_url": "https://api.github.com/users/satyamakgec/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-10-26T10:41:06Z",
    "updated_at": "2018-10-26T10:41:06Z",
    "author_association": "NONE",
    "body": "I added a reference implementation for ERC 1410 - still some improvement to be done to factor out common base classes or make a robust implementation, but hopefully good reference for anyone looking at these standards.\r\nhttps://github.com/SecurityTokenStandard/EIP-Spec/blob/master/contracts/PartialFungibleToken.sol",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/433366786/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/444467827",
    "html_url": "https://github.com/ethereum/EIPs/issues/1410#issuecomment-444467827",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1410",
    "id": 444467827,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ0NDQ2NzgyNw==",
    "user": {
      "login": "caivs",
      "id": 32483798,
      "node_id": "MDQ6VXNlcjMyNDgzNzk4",
      "avatar_url": "https://avatars.githubusercontent.com/u/32483798?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/caivs",
      "html_url": "https://github.com/caivs",
      "followers_url": "https://api.github.com/users/caivs/followers",
      "following_url": "https://api.github.com/users/caivs/following{/other_user}",
      "gists_url": "https://api.github.com/users/caivs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/caivs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/caivs/subscriptions",
      "organizations_url": "https://api.github.com/users/caivs/orgs",
      "repos_url": "https://api.github.com/users/caivs/repos",
      "events_url": "https://api.github.com/users/caivs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/caivs/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-12-05T12:25:45Z",
    "updated_at": "2018-12-05T12:25:45Z",
    "author_association": "NONE",
    "body": "Any progress on this, or further thoughts?\r\n\r\nI am trying to see the utility of the proposed `tranche` idea but I must admit I'm not convinced yet. Mostly I am wondering why we wouldn't simply use multiple (security) tokens (i.e., one per tranche) -- why must they collectively be stored in one place?\r\n\r\nThe securities that I'm aware of using a tranche system (CDOs, corporate bonds) do so because each \"tranche\" has different properties; really, they are different securities and trade as such (i.e., there is a market for senior bonds and a separate market for junior bonds, etc).\r\n\r\nTherefore my gut instinct is that the most basic security token is actually a *single* tranche, which is probably closer to ERC1462 (#1462). \r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/444467827/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/444489050",
    "html_url": "https://github.com/ethereum/EIPs/issues/1410#issuecomment-444489050",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1410",
    "id": 444489050,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ0NDQ4OTA1MA==",
    "user": {
      "login": "fubuloubu",
      "id": 3859395,
      "node_id": "MDQ6VXNlcjM4NTkzOTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3859395?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fubuloubu",
      "html_url": "https://github.com/fubuloubu",
      "followers_url": "https://api.github.com/users/fubuloubu/followers",
      "following_url": "https://api.github.com/users/fubuloubu/following{/other_user}",
      "gists_url": "https://api.github.com/users/fubuloubu/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fubuloubu/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fubuloubu/subscriptions",
      "organizations_url": "https://api.github.com/users/fubuloubu/orgs",
      "repos_url": "https://api.github.com/users/fubuloubu/repos",
      "events_url": "https://api.github.com/users/fubuloubu/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fubuloubu/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-12-05T13:42:37Z",
    "updated_at": "2018-12-05T13:44:46Z",
    "author_association": "MEMBER",
    "body": "In a word, convertibility. With multiple tokens, you would have to design a complicated atomic swap, mint/burn or locking system to trade vesting to unlimited shares, and accurately represent the restrictions on tradability on multiple tokens that essentially represent the same thing. If they are all subcategories of the same token, that logic is much simpler to represent. I am not a \"security tokens\" guy, but that much makes sense to me.\r\n\r\nThis proposal also has wider utility. Allowing subcategories for a general token (in a non-security use case) would allow different ideas like locking voting tokens temporarily or making allocations to something like staking without delegating control to a smart contract you don't necessarily trust. That little bit of state helps have additional logic for transferability be much easier to implement.\r\n\r\nI do still wish `tranche` was called `category` or something to reflect these broader use cases.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/444489050/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/444492177",
    "html_url": "https://github.com/ethereum/EIPs/issues/1410#issuecomment-444492177",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1410",
    "id": 444492177,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ0NDQ5MjE3Nw==",
    "user": {
      "login": "zingleton",
      "id": 33845884,
      "node_id": "MDQ6VXNlcjMzODQ1ODg0",
      "avatar_url": "https://avatars.githubusercontent.com/u/33845884?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/zingleton",
      "html_url": "https://github.com/zingleton",
      "followers_url": "https://api.github.com/users/zingleton/followers",
      "following_url": "https://api.github.com/users/zingleton/following{/other_user}",
      "gists_url": "https://api.github.com/users/zingleton/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/zingleton/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/zingleton/subscriptions",
      "organizations_url": "https://api.github.com/users/zingleton/orgs",
      "repos_url": "https://api.github.com/users/zingleton/repos",
      "events_url": "https://api.github.com/users/zingleton/events{/privacy}",
      "received_events_url": "https://api.github.com/users/zingleton/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-12-05T13:52:52Z",
    "updated_at": "2018-12-05T13:52:52Z",
    "author_association": "NONE",
    "body": "That's not it at all. Tranche is probably a bad word, because it implies that the securities in the different tranches are different or have different rights -like the tranches of an MBS. However, that is NOT the purpose of this particular data structure. This data structure describes securities that are the SAME security, but issued on different days, or in different jurisdictions. The most important use case is to implement the rules of US Regulation D and Regulation S. For example, I can issue the SAME common stock in many different events. The stock that I sell to US investors has a one year lockup. So, stock issued  on each date can go into a separate tranche that tracks the origination date. There are many ways to implement lockup, so this tranche data structure is not required. However, it IS required for the stock that I sell to non-US investors under Reg S. This is covered by a rule that says the stock cannot be sold back to US investors until one year has passed. So, we have to track each share of stock that was issued on that date (using a tranche) to see if those shares have been outstanding for a year.  It also happens that securities jump from Reg D into Reg S, and the date of issue follows them, through purchase by a large fund that is exempt from Reg D under rule 144a. You might end up with 20 different issuance dates and jurisdictions. For most purposes, we don't care about the different tranches. We only care about the full set of outstanding securities for voting, and distribution, and trade volume restrictions. And, in most cases these tranches would collapse to the same security after a year or so. Keeping track of 20 different tokens in that case, and adding them up, and recombining them, would be silly.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/444492177/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/444493359",
    "html_url": "https://github.com/ethereum/EIPs/issues/1410#issuecomment-444493359",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1410",
    "id": 444493359,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ0NDQ5MzM1OQ==",
    "user": {
      "login": "zingleton",
      "id": 33845884,
      "node_id": "MDQ6VXNlcjMzODQ1ODg0",
      "avatar_url": "https://avatars.githubusercontent.com/u/33845884?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/zingleton",
      "html_url": "https://github.com/zingleton",
      "followers_url": "https://api.github.com/users/zingleton/followers",
      "following_url": "https://api.github.com/users/zingleton/following{/other_user}",
      "gists_url": "https://api.github.com/users/zingleton/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/zingleton/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/zingleton/subscriptions",
      "organizations_url": "https://api.github.com/users/zingleton/orgs",
      "repos_url": "https://api.github.com/users/zingleton/repos",
      "events_url": "https://api.github.com/users/zingleton/events{/privacy}",
      "received_events_url": "https://api.github.com/users/zingleton/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-12-05T13:56:31Z",
    "updated_at": "2018-12-05T13:56:31Z",
    "author_association": "NONE",
    "body": "This type of tranche would describe different issuances of the same security. As a corollary, if you have several securities from one issuer, but with different rights, I think you should make different tokens.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/444493359/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/444509046",
    "html_url": "https://github.com/ethereum/EIPs/issues/1410#issuecomment-444509046",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1410",
    "id": 444509046,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ0NDUwOTA0Ng==",
    "user": {
      "login": "caivs",
      "id": 32483798,
      "node_id": "MDQ6VXNlcjMyNDgzNzk4",
      "avatar_url": "https://avatars.githubusercontent.com/u/32483798?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/caivs",
      "html_url": "https://github.com/caivs",
      "followers_url": "https://api.github.com/users/caivs/followers",
      "following_url": "https://api.github.com/users/caivs/following{/other_user}",
      "gists_url": "https://api.github.com/users/caivs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/caivs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/caivs/subscriptions",
      "organizations_url": "https://api.github.com/users/caivs/orgs",
      "repos_url": "https://api.github.com/users/caivs/repos",
      "events_url": "https://api.github.com/users/caivs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/caivs/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-12-05T14:43:37Z",
    "updated_at": "2018-12-05T14:43:37Z",
    "author_association": "NONE",
    "body": "@fubuloubu @zingleton Thanks for the detailed responses. The examples given make a lot of sense - especially the point about lock-up times/issuance dates/recombining being a nightmare with separate tokens. I can definitely see advantages to this approach.\r\n\r\nSince it seems to be a potential source of confusion (at least in my case), perhaps the name *should* be changed from `tranche` to something that doesn't already have a well-understood meaning in the context of a security. The suggestion of `category` seems reasonable to me. `collection`, `issue` and I'm sure many others could also work. Obviously this standard isn't just about securities as has been pointed out, but it is likely a major application and it makes sense to reduce the potential for confusion where it is unnecessary, IMO.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/444509046/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/444509338",
    "html_url": "https://github.com/ethereum/EIPs/issues/1410#issuecomment-444509338",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1410",
    "id": 444509338,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ0NDUwOTMzOA==",
    "user": {
      "login": "caivs",
      "id": 32483798,
      "node_id": "MDQ6VXNlcjMyNDgzNzk4",
      "avatar_url": "https://avatars.githubusercontent.com/u/32483798?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/caivs",
      "html_url": "https://github.com/caivs",
      "followers_url": "https://api.github.com/users/caivs/followers",
      "following_url": "https://api.github.com/users/caivs/following{/other_user}",
      "gists_url": "https://api.github.com/users/caivs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/caivs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/caivs/subscriptions",
      "organizations_url": "https://api.github.com/users/caivs/orgs",
      "repos_url": "https://api.github.com/users/caivs/repos",
      "events_url": "https://api.github.com/users/caivs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/caivs/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-12-05T14:44:23Z",
    "updated_at": "2018-12-05T14:44:23Z",
    "author_association": "NONE",
    "body": "@adamdossa What do you think about changing `tranche` to something else that doesn't already have an established meaning in the context of securities?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/444509338/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/444517690",
    "html_url": "https://github.com/ethereum/EIPs/issues/1410#issuecomment-444517690",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1410",
    "id": 444517690,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ0NDUxNzY5MA==",
    "user": {
      "login": "fubuloubu",
      "id": 3859395,
      "node_id": "MDQ6VXNlcjM4NTkzOTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3859395?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fubuloubu",
      "html_url": "https://github.com/fubuloubu",
      "followers_url": "https://api.github.com/users/fubuloubu/followers",
      "following_url": "https://api.github.com/users/fubuloubu/following{/other_user}",
      "gists_url": "https://api.github.com/users/fubuloubu/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fubuloubu/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fubuloubu/subscriptions",
      "organizations_url": "https://api.github.com/users/fubuloubu/orgs",
      "repos_url": "https://api.github.com/users/fubuloubu/repos",
      "events_url": "https://api.github.com/users/fubuloubu/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fubuloubu/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-12-05T15:07:28Z",
    "updated_at": "2018-12-05T15:07:28Z",
    "author_association": "MEMBER",
    "body": "Also, one point. Again I am not an expert on securities at all, but focusing on US requirements is too narrowly focused to define a standard on. ERC standards are all about giving developers tools to build different use cases with, one of the main reasons I pushed back against the original monolithic proposal.\r\n\r\nAs noted, the fact is you really have multiple options for implementing a \"security token\" using this ERC, other ERCs (like using multiple ERC20s), or any combination of the above. It depends on what makes sense for how you're implementing it.\r\n\r\n---\r\n\r\nA lot of people think ERC proposals are somehow a \"stamp of legitimacy\", when in reality it's just an idea. Unlike core protocol EIPs, ERCs just serve as a rallying point for people to adopt them. By focusing on something more broadly useful, that means faster adoption of the ERC, which means it's \"legitimacy\" increases with each adoption.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/444517690/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/444520032",
    "html_url": "https://github.com/ethereum/EIPs/issues/1410#issuecomment-444520032",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1410",
    "id": 444520032,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ0NDUyMDAzMg==",
    "user": {
      "login": "thegostep",
      "id": 15959632,
      "node_id": "MDQ6VXNlcjE1OTU5NjMy",
      "avatar_url": "https://avatars.githubusercontent.com/u/15959632?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/thegostep",
      "html_url": "https://github.com/thegostep",
      "followers_url": "https://api.github.com/users/thegostep/followers",
      "following_url": "https://api.github.com/users/thegostep/following{/other_user}",
      "gists_url": "https://api.github.com/users/thegostep/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/thegostep/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/thegostep/subscriptions",
      "organizations_url": "https://api.github.com/users/thegostep/orgs",
      "repos_url": "https://api.github.com/users/thegostep/repos",
      "events_url": "https://api.github.com/users/thegostep/events{/privacy}",
      "received_events_url": "https://api.github.com/users/thegostep/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-12-05T15:13:49Z",
    "updated_at": "2018-12-05T15:13:49Z",
    "author_association": "NONE",
    "body": "@parkinsonj I want to point you to this WIP update to the 1400 proposals. It includes renaming 'tranches' to 'partitions' in order to remove the association with MBS and CDOs.\r\n\r\nhttps://github.com/SecurityTokenStandard/EIP-Spec/pull/6",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/444520032/reactions",
      "total_count": 2,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 2,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/444523900",
    "html_url": "https://github.com/ethereum/EIPs/issues/1410#issuecomment-444523900",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1410",
    "id": 444523900,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ0NDUyMzkwMA==",
    "user": {
      "login": "caivs",
      "id": 32483798,
      "node_id": "MDQ6VXNlcjMyNDgzNzk4",
      "avatar_url": "https://avatars.githubusercontent.com/u/32483798?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/caivs",
      "html_url": "https://github.com/caivs",
      "followers_url": "https://api.github.com/users/caivs/followers",
      "following_url": "https://api.github.com/users/caivs/following{/other_user}",
      "gists_url": "https://api.github.com/users/caivs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/caivs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/caivs/subscriptions",
      "organizations_url": "https://api.github.com/users/caivs/orgs",
      "repos_url": "https://api.github.com/users/caivs/repos",
      "events_url": "https://api.github.com/users/caivs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/caivs/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-12-05T15:24:23Z",
    "updated_at": "2018-12-05T15:24:23Z",
    "author_association": "NONE",
    "body": "@thegostep Thank you, I shall take a look at it. Sounds like a positive step!\r\n\r\n@fubuloubu I think that's a fair point, although as you've pointed out the partitioning is relevant to a berth of applications outside of US securities. \r\n\r\nRegarding \"legitimacy\", I'm not sure I agree in this particular context if only because a securities platform is not very useful if it only works with a small fraction of security tokens. It's utility that is driving the push for a standard - utility for platform builders, token designers and ultimately end users (who then won't need to use different tokens on different platforms, etc).",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/444523900/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/444531372",
    "html_url": "https://github.com/ethereum/EIPs/issues/1410#issuecomment-444531372",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1410",
    "id": 444531372,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ0NDUzMTM3Mg==",
    "user": {
      "login": "fubuloubu",
      "id": 3859395,
      "node_id": "MDQ6VXNlcjM4NTkzOTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3859395?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fubuloubu",
      "html_url": "https://github.com/fubuloubu",
      "followers_url": "https://api.github.com/users/fubuloubu/followers",
      "following_url": "https://api.github.com/users/fubuloubu/following{/other_user}",
      "gists_url": "https://api.github.com/users/fubuloubu/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fubuloubu/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fubuloubu/subscriptions",
      "organizations_url": "https://api.github.com/users/fubuloubu/orgs",
      "repos_url": "https://api.github.com/users/fubuloubu/repos",
      "events_url": "https://api.github.com/users/fubuloubu/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fubuloubu/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-12-05T15:43:35Z",
    "updated_at": "2018-12-05T15:43:35Z",
    "author_association": "MEMBER",
    "body": "Oh yeah, don't get me wrong, the securities use case is a really big driver of adoption, in the same way it has also driven the push for defining multiple, \"competing\" standards, basically all at the same time.\r\n\r\nI'm saying that non-security use cases can be a way to help engender adoption of a particular standard, as you have defined something more generally useful than if it were focused more towards one niche of the community.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/444531372/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/445898793",
    "html_url": "https://github.com/ethereum/EIPs/issues/1410#issuecomment-445898793",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1410",
    "id": 445898793,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ0NTg5ODc5Mw==",
    "user": {
      "login": "adamdossa",
      "id": 2633913,
      "node_id": "MDQ6VXNlcjI2MzM5MTM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2633913?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/adamdossa",
      "html_url": "https://github.com/adamdossa",
      "followers_url": "https://api.github.com/users/adamdossa/followers",
      "following_url": "https://api.github.com/users/adamdossa/following{/other_user}",
      "gists_url": "https://api.github.com/users/adamdossa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/adamdossa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/adamdossa/subscriptions",
      "organizations_url": "https://api.github.com/users/adamdossa/orgs",
      "repos_url": "https://api.github.com/users/adamdossa/repos",
      "events_url": "https://api.github.com/users/adamdossa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/adamdossa/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-12-10T17:23:50Z",
    "updated_at": "2018-12-10T17:23:50Z",
    "author_association": "NONE",
    "body": "Following feedback from the token ring, community calls, GitHub & the Telegram group, I have made the following changes:\r\n\r\nMotivation\r\n* Clarify use of tranches / partitions primarily as a mechanism to add transparency to the non-fungible subsets of a token holders balance.\r\n* Ease adoption by decomposing the security token standard into a library of related and interoperable standards.\r\n* Move to ERC-20 from ERC-777 as a base.\r\n* Provide a route to adoption / implementation which is more incremental.\r\n\r\nUpdates\r\n* Modify ERC-1410 to make it un-opinionated on ERC-20 vs. ERC-777 rather than a direct descendant of ERC-777.\r\n* Rename “tranches” to “partitions”\r\n* Create ERC-1594 which splits out the non-partition related core security token functionality.\r\n* Create ERC-1643 which splits out document management functionality.\r\n* Create ERC-1644 which splits out controller operation functionality.\r\n* Modify ERC-1594 be based on ERC-20 rather than ERC-777.\r\n* Modify ERC-1400 to be an umbrella of ERC-1410, ERC-1594, ERC-1643 and ERC-1644 with a few additional constraints to make these standards interoperate.\r\n\r\nThe changes in this update along with some related conversation are collected in a GitHub PR at:  \r\nhttps://github.com/SecurityTokenStandard/EIP-Spec/pull/6.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/445898793/reactions",
      "total_count": 1,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 1,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/454808151",
    "html_url": "https://github.com/ethereum/EIPs/issues/1410#issuecomment-454808151",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1410",
    "id": 454808151,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ1NDgwODE1MQ==",
    "user": {
      "login": "MichalZalecki",
      "id": 3136577,
      "node_id": "MDQ6VXNlcjMxMzY1Nzc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3136577?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MichalZalecki",
      "html_url": "https://github.com/MichalZalecki",
      "followers_url": "https://api.github.com/users/MichalZalecki/followers",
      "following_url": "https://api.github.com/users/MichalZalecki/following{/other_user}",
      "gists_url": "https://api.github.com/users/MichalZalecki/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MichalZalecki/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MichalZalecki/subscriptions",
      "organizations_url": "https://api.github.com/users/MichalZalecki/orgs",
      "repos_url": "https://api.github.com/users/MichalZalecki/repos",
      "events_url": "https://api.github.com/users/MichalZalecki/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MichalZalecki/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-01-16T14:55:55Z",
    "updated_at": "2019-01-16T15:27:43Z",
    "author_association": "NONE",
    "body": "@adamdossa Spec says `isOperatorFor` but interface is `isOperator`. I guess the `isOperator` is the right name as it follows the convention of not using `For` or `By` without `Partition` in the name, right?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/454808151/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/483891257",
    "html_url": "https://github.com/ethereum/EIPs/issues/1410#issuecomment-483891257",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1410",
    "id": 483891257,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ4Mzg5MTI1Nw==",
    "user": {
      "login": "devrajsinghrawat",
      "id": 44597990,
      "node_id": "MDQ6VXNlcjQ0NTk3OTkw",
      "avatar_url": "https://avatars.githubusercontent.com/u/44597990?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/devrajsinghrawat",
      "html_url": "https://github.com/devrajsinghrawat",
      "followers_url": "https://api.github.com/users/devrajsinghrawat/followers",
      "following_url": "https://api.github.com/users/devrajsinghrawat/following{/other_user}",
      "gists_url": "https://api.github.com/users/devrajsinghrawat/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/devrajsinghrawat/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/devrajsinghrawat/subscriptions",
      "organizations_url": "https://api.github.com/users/devrajsinghrawat/orgs",
      "repos_url": "https://api.github.com/users/devrajsinghrawat/repos",
      "events_url": "https://api.github.com/users/devrajsinghrawat/events{/privacy}",
      "received_events_url": "https://api.github.com/users/devrajsinghrawat/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-04-17T00:26:02Z",
    "updated_at": "2019-04-17T00:26:02Z",
    "author_association": "NONE",
    "body": "Hi @adamdossa, \r\n\r\nKindly help me on below points.\r\n\r\n1) According to transferByPartition\r\n\r\nThis function MUST throw if the transfer of tokens is not successful for any reason.\r\nWhen transferring tokens from a particular partition, it is useful to know on-chain (i.e. not just via an event being fired) the destination partition of those tokens. The destination partition will be determined by the implementation of this function and will vary depending on use-case.\r\n\r\n**The function MUST return the bytes32 _partition of the receiver.**\r\n\r\nDoes that mean, when we sends tokens from a perticular _partition to receiver, it generates a new _partition key? If thats true then what if the receiver partition is already holding the partition tokens (simliar attribute of tokens)\r\n\r\n2) How should we generated the _partition key? can we genearte it creating a hash by passing certain attributes?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/483891257/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
