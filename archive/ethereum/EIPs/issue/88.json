{
  "url": "https://api.github.com/repos/ethereum/EIPs/issues/88",
  "repository_url": "https://api.github.com/repos/ethereum/EIPs",
  "labels_url": "https://api.github.com/repos/ethereum/EIPs/issues/88/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/EIPs/issues/88/comments",
  "events_url": "https://api.github.com/repos/ethereum/EIPs/issues/88/events",
  "html_url": "https://github.com/ethereum/EIPs/issues/88",
  "id": 145485079,
  "node_id": "MDU6SXNzdWUxNDU0ODUwNzk=",
  "number": 88,
  "title": "Blockchain rent: user-side resurrectable edition",
  "user": {
    "login": "vbuterin",
    "id": 2230894,
    "node_id": "MDQ6VXNlcjIyMzA4OTQ=",
    "avatar_url": "https://avatars.githubusercontent.com/u/2230894?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/vbuterin",
    "html_url": "https://github.com/vbuterin",
    "followers_url": "https://api.github.com/users/vbuterin/followers",
    "following_url": "https://api.github.com/users/vbuterin/following{/other_user}",
    "gists_url": "https://api.github.com/users/vbuterin/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/vbuterin/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/vbuterin/subscriptions",
    "organizations_url": "https://api.github.com/users/vbuterin/orgs",
    "repos_url": "https://api.github.com/users/vbuterin/repos",
    "events_url": "https://api.github.com/users/vbuterin/events{/privacy}",
    "received_events_url": "https://api.github.com/users/vbuterin/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 2328627851,
      "node_id": "MDU6TGFiZWwyMzI4NjI3ODUx",
      "url": "https://api.github.com/repos/ethereum/EIPs/labels/stale",
      "name": "stale",
      "color": "000000",
      "default": false,
      "description": ""
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 13,
  "created_at": "2016-04-03T11:52:14Z",
  "updated_at": "2022-01-30T11:08:18Z",
  "closed_at": "2022-01-30T11:08:18Z",
  "author_association": "MEMBER",
  "active_lock_reason": null,
  "body": "A [previous EIP](https://github.com/ethereum/EIPs/issues/35) discussed the possibility of introducing a notion of \"blockchain rent\": paying not just a one-time fee for adding storage and getting a one-time refund for removing it, but actually paying per unit time. This was met with the primary criticism that users liked the aspect of Ethereum that contracts sit on the chain forever, and once a contract is placed there is no risk of the contract suddenly disappearing due to no longer being able to afford rent.\n\nThis EIP describes a mechanism by which contracts that \"go bankrupt\" and get deleted because they can no longer afford to pay rent can be removed from storage (via protocol-incentivized third-party cleanup actors that _could_ be miners but don't have to be so as to simplify the consensus code, as usual) but can be resurrected at a later time if need be.\n### Mechanism\n\nSuppose that we have a blockchain rent scheme, as in [EIP 103](https://github.com/ethereum/EIPs/issues/35), where contracts can get deleted. When this happens, the \"repo transaction\" generates a receipt in that block, specifying that the contract was removed, as well as its state root just before removal. Anyone can \"resurrect\" the contract at any time by providing a transaction containing the Merkle branch to the receipt of the repo transaction, plus the contract's entire state at that time. The protocol checks that the state root is equivalent to what was in the repo receipt, that the repo receipt is valid (this can be done through a scheme where the state of one block contains state roots of previous blocks, and the process of \"hopping\" back in time through these roots is reasonably efficient), and that an appropriate fee is paid (eg. one week's worth of rent is a possible minimum); if all checks pass, then it re-creates the contract at that address.\n\nA special case arises if a contract gets deleted, then resurrected, then deleted again; in this case, there are multiple repo transactions to choose from. To handle this case, a challenge-response protocol will need to be added, where the first resurrection transaction only creates a \"stub\" that can be challenged by a newer repo receipt within X blocks, and if the stub is unchallenged then it can be replaced with a live contract containing the actual storage.\n\nAnother special case is that of a contract being deleted, then _recreated_ with the same init code as previously, then resurrected (whether before or after a subsequent deletion). One way of dealing with this problem is to make contract creation challengeable in the same way as resurrection, though this introduces inefficiencies and inconveniences; another is to have contract addresses be based on a global nonce that changes every Y blocks (eg. two years) and require contracts to submit Y blocks worth of rent as a deposit before increasing their storage usage, so that they cannot get deleted before the global nonce changes. Note that this does mean that \"pay to not-yet-existent contract\" transactions will require the recipient to register their address within Y blocks, although if desired we can add a mechanism by which a user can send initialize a contract with a previous global nonce, and only in that case requiring a challenge time to make sure that there are no repo receipts for the address.\n### Developer Best Practices\n\nContract developers will have to make do with the possibility that a contract they have some relationship to gets deleted; hence, if this scheme is implemented, we encourage developers to check that the contracts they are talking to exist, and if the contract does not exist throw an exception, so that the sender can themselves resurrect and resend the original transaction if they so choose.\n",
  "closed_by": {
    "login": "github-actions[bot]",
    "id": 41898282,
    "node_id": "MDM6Qm90NDE4OTgyODI=",
    "avatar_url": "https://avatars.githubusercontent.com/in/15368?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/github-actions%5Bbot%5D",
    "html_url": "https://github.com/apps/github-actions",
    "followers_url": "https://api.github.com/users/github-actions%5Bbot%5D/followers",
    "following_url": "https://api.github.com/users/github-actions%5Bbot%5D/following{/other_user}",
    "gists_url": "https://api.github.com/users/github-actions%5Bbot%5D/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/github-actions%5Bbot%5D/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/github-actions%5Bbot%5D/subscriptions",
    "organizations_url": "https://api.github.com/users/github-actions%5Bbot%5D/orgs",
    "repos_url": "https://api.github.com/users/github-actions%5Bbot%5D/repos",
    "events_url": "https://api.github.com/users/github-actions%5Bbot%5D/events{/privacy}",
    "received_events_url": "https://api.github.com/users/github-actions%5Bbot%5D/received_events",
    "type": "Bot",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/88/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/EIPs/issues/88/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/205126158",
    "html_url": "https://github.com/ethereum/EIPs/issues/88#issuecomment-205126158",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/88",
    "id": 205126158,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIwNTEyNjE1OA==",
    "user": {
      "login": "Souptacular",
      "id": 3460120,
      "node_id": "MDQ6VXNlcjM0NjAxMjA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3460120?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Souptacular",
      "html_url": "https://github.com/Souptacular",
      "followers_url": "https://api.github.com/users/Souptacular/followers",
      "following_url": "https://api.github.com/users/Souptacular/following{/other_user}",
      "gists_url": "https://api.github.com/users/Souptacular/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Souptacular/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Souptacular/subscriptions",
      "organizations_url": "https://api.github.com/users/Souptacular/orgs",
      "repos_url": "https://api.github.com/users/Souptacular/repos",
      "events_url": "https://api.github.com/users/Souptacular/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Souptacular/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-04-04T04:02:49Z",
    "updated_at": "2016-04-04T04:02:49Z",
    "author_association": "MEMBER",
    "body": "A concern I have about this scheme is how much time it would take to ressurect a contract. Contracts are becoming more complicated and reference multiple contracts at times. Systems will need to have built in mechanisms to make external, off-chain calls to get the data to ressurect contracts and by the time this occurs the initial call that would try to use the contract would time out or provide a long delay for users. To negate a delay for users, SC devs will need to create ways to query the external contracts often to make sure their services will still work.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/205126158/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/205156146",
    "html_url": "https://github.com/ethereum/EIPs/issues/88#issuecomment-205156146",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/88",
    "id": 205156146,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIwNTE1NjE0Ng==",
    "user": {
      "login": "vbuterin",
      "id": 2230894,
      "node_id": "MDQ6VXNlcjIyMzA4OTQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2230894?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vbuterin",
      "html_url": "https://github.com/vbuterin",
      "followers_url": "https://api.github.com/users/vbuterin/followers",
      "following_url": "https://api.github.com/users/vbuterin/following{/other_user}",
      "gists_url": "https://api.github.com/users/vbuterin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vbuterin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vbuterin/subscriptions",
      "organizations_url": "https://api.github.com/users/vbuterin/orgs",
      "repos_url": "https://api.github.com/users/vbuterin/repos",
      "events_url": "https://api.github.com/users/vbuterin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vbuterin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-04-04T06:31:55Z",
    "updated_at": "2016-04-04T06:31:55Z",
    "author_association": "MEMBER",
    "body": "Well, unforeseen contract deletion is only something that should happen in fairly exceptional cases involving developer negligence, so I don't see too much of a problem with requiring a 3 hour waiting period on it. I would say contract resurrection can be implemented as a library if need be: if a contract or EOA calls another contract and fails because the child is empty, then check to see if the child existed previously (this can be done via a specialized kind of archive node), and if it did then grab the merkle branch to bring it back.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/205156146/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/205321560",
    "html_url": "https://github.com/ethereum/EIPs/issues/88#issuecomment-205321560",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/88",
    "id": 205321560,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIwNTMyMTU2MA==",
    "user": {
      "login": "Smithgift",
      "id": 10504499,
      "node_id": "MDQ6VXNlcjEwNTA0NDk5",
      "avatar_url": "https://avatars.githubusercontent.com/u/10504499?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Smithgift",
      "html_url": "https://github.com/Smithgift",
      "followers_url": "https://api.github.com/users/Smithgift/followers",
      "following_url": "https://api.github.com/users/Smithgift/following{/other_user}",
      "gists_url": "https://api.github.com/users/Smithgift/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Smithgift/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Smithgift/subscriptions",
      "organizations_url": "https://api.github.com/users/Smithgift/orgs",
      "repos_url": "https://api.github.com/users/Smithgift/repos",
      "events_url": "https://api.github.com/users/Smithgift/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Smithgift/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-04-04T14:28:23Z",
    "updated_at": "2016-04-04T14:28:23Z",
    "author_association": "NONE",
    "body": "The advantage of this proposal is that it will clean up the blockchain of old, unused contracts, as well as spam contracts. The disadvantage is the various inelegant requirements. For example, we will have to have a new kind of transaction with the right to repo contracts, or create \"kernalspace\" contracts that can repo others. The side effects of the challenge-response system also feel significant. Global nonce with past receipt seems the least disruptive.\n\nThe big question: Is blockchain rent to mitigate the increase the size of global state, or to actually decrease the size of the global state?\n\nIt's still possible for data to be permanently deleted in this model. Consider the following (somewhat unlikely) chain of events.\n1. Contract A is created.\n2. Contract A is deleted.\n3. The original creator of Contract A recreates it at the same address, creating A'. \n4. Due to unspecified shenanigans (spam attack, collusion, attack on archive node), A' is never challenged successfully.\n5. A' is deleted.\n\nWe now have two receipts for the address of A, and the original A's receipt can always be challenged by the A`. I doubt this will ever be an issue, and a simple technique would be to create important contracts from addresses which are promptly disposed of. (But if the contract is important, it's unlikely to get archived in the first place, let alone not be challenged when recreated.)\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/205321560/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/205366280",
    "html_url": "https://github.com/ethereum/EIPs/issues/88#issuecomment-205366280",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/88",
    "id": 205366280,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIwNTM2NjI4MA==",
    "user": {
      "login": "chriseth",
      "id": 9073706,
      "node_id": "MDQ6VXNlcjkwNzM3MDY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/9073706?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/chriseth",
      "html_url": "https://github.com/chriseth",
      "followers_url": "https://api.github.com/users/chriseth/followers",
      "following_url": "https://api.github.com/users/chriseth/following{/other_user}",
      "gists_url": "https://api.github.com/users/chriseth/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/chriseth/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/chriseth/subscriptions",
      "organizations_url": "https://api.github.com/users/chriseth/orgs",
      "repos_url": "https://api.github.com/users/chriseth/repos",
      "events_url": "https://api.github.com/users/chriseth/events{/privacy}",
      "received_events_url": "https://api.github.com/users/chriseth/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-04-04T15:58:02Z",
    "updated_at": "2016-04-04T15:58:02Z",
    "author_association": "MEMBER",
    "body": "With regards to the \"developer best practice\": What about raising an OOG for empty destination code by default (at least if value is zero)? I can imagine that checking CODESIZE in an inner loop is quite expensive (for example it will turn into an external function call in the JIT) and it cannot be optimized away, because the library can allways selfdestruct.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/205366280/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/206126961",
    "html_url": "https://github.com/ethereum/EIPs/issues/88#issuecomment-206126961",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/88",
    "id": 206126961,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIwNjEyNjk2MQ==",
    "user": {
      "login": "vbuterin",
      "id": 2230894,
      "node_id": "MDQ6VXNlcjIyMzA4OTQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2230894?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vbuterin",
      "html_url": "https://github.com/vbuterin",
      "followers_url": "https://api.github.com/users/vbuterin/followers",
      "following_url": "https://api.github.com/users/vbuterin/following{/other_user}",
      "gists_url": "https://api.github.com/users/vbuterin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vbuterin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vbuterin/subscriptions",
      "organizations_url": "https://api.github.com/users/vbuterin/orgs",
      "repos_url": "https://api.github.com/users/vbuterin/repos",
      "events_url": "https://api.github.com/users/vbuterin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vbuterin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-04-06T05:35:54Z",
    "updated_at": "2016-04-06T05:35:54Z",
    "author_association": "MEMBER",
    "body": "Agree that cleanup of unused code is the pro, and inelegance is the primary con.\n\n> With regards to the \"developer best practice\": What about raising an OOG for empty destination code by default (at least if value is zero)?\n\nI would be fine with this.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/206126961/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/207448660",
    "html_url": "https://github.com/ethereum/EIPs/issues/88#issuecomment-207448660",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/88",
    "id": 207448660,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIwNzQ0ODY2MA==",
    "user": {
      "login": "Smithgift",
      "id": 10504499,
      "node_id": "MDQ6VXNlcjEwNTA0NDk5",
      "avatar_url": "https://avatars.githubusercontent.com/u/10504499?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Smithgift",
      "html_url": "https://github.com/Smithgift",
      "followers_url": "https://api.github.com/users/Smithgift/followers",
      "following_url": "https://api.github.com/users/Smithgift/following{/other_user}",
      "gists_url": "https://api.github.com/users/Smithgift/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Smithgift/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Smithgift/subscriptions",
      "organizations_url": "https://api.github.com/users/Smithgift/orgs",
      "repos_url": "https://api.github.com/users/Smithgift/repos",
      "events_url": "https://api.github.com/users/Smithgift/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Smithgift/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-04-08T14:17:56Z",
    "updated_at": "2016-04-08T14:17:56Z",
    "author_association": "NONE",
    "body": "If we decide to rip off the lid of the Pandora's Box of making \"kernalspace\" contracts, I think we can find an elegant version of this underneath.\n\nSuppose there are some opcodes that only contracts at certain addresses can use. I think all that would be necessary in this instance is the ability to create and delete contracts at arbitrary addresses and set arbitrary state. (I guess that actually suffices for most kernalspace uses?)\n\nA precompiled kernalspace rent contract stores the deposit of various contracts. When rent is not paid, a normal transaction to the rent contract uses a delete opcode to delete the deadbeat contract. Another normal transaction sets the resurrection process in motion. If there's no challenge, it uses a create opcode to recreate the code and then some sort of state-setting opcode to recreate the local state.\n\nAnother advantage is simply having the rent contract store nonces of archives and getting rid of the challenge-response protocol entirely. I'm not sure how best to deal with manual recreation. A violent method is for the rent contract to keep track of whether contracts should currently be dead or not, and kill them if they ought to be. Wallets would have to have some sense to check the rent contract before interacting with contracts under some circumstances.\n\nOf course, the Pandora's Box of kernalspace contracts is potentially a very large one, and that's a discussion of its own. But if we still decide to have kernalspace contracts for some other reason, this is a lot more possible.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/207448660/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/286415661",
    "html_url": "https://github.com/ethereum/EIPs/issues/88#issuecomment-286415661",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/88",
    "id": 286415661,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI4NjQxNTY2MQ==",
    "user": {
      "login": "willnwhite",
      "id": 8081877,
      "node_id": "MDQ6VXNlcjgwODE4Nzc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/8081877?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/willnwhite",
      "html_url": "https://github.com/willnwhite",
      "followers_url": "https://api.github.com/users/willnwhite/followers",
      "following_url": "https://api.github.com/users/willnwhite/following{/other_user}",
      "gists_url": "https://api.github.com/users/willnwhite/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/willnwhite/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/willnwhite/subscriptions",
      "organizations_url": "https://api.github.com/users/willnwhite/orgs",
      "repos_url": "https://api.github.com/users/willnwhite/repos",
      "events_url": "https://api.github.com/users/willnwhite/events{/privacy}",
      "received_events_url": "https://api.github.com/users/willnwhite/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-03-14T13:09:34Z",
    "updated_at": "2017-03-16T08:20:08Z",
    "author_association": "NONE",
    "body": "Before any rent, I think it should be easier to _voluntarily_ save space on the blockchain by deleting contracts you've deployed. Currently that kind of code has to be written into the contract before it's deployed. I think every contract should come with a standard \"delete\" functionality (that only its deployer can use). Contract deployers would be incentivised to close their unused contracts so their other contracts will have more space.\r\n\r\nAs well as saving space, a built-in delete could help with the other things this code is currently manually written into a contract for, like stopping use of a deprecated contract. I had started thinking about making an EIP for this reason previously.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/286415661/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/300558454",
    "html_url": "https://github.com/ethereum/EIPs/issues/88#issuecomment-300558454",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/88",
    "id": 300558454,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwMDU1ODQ1NA==",
    "user": {
      "login": "willnwhite",
      "id": 8081877,
      "node_id": "MDQ6VXNlcjgwODE4Nzc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/8081877?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/willnwhite",
      "html_url": "https://github.com/willnwhite",
      "followers_url": "https://api.github.com/users/willnwhite/followers",
      "following_url": "https://api.github.com/users/willnwhite/following{/other_user}",
      "gists_url": "https://api.github.com/users/willnwhite/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/willnwhite/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/willnwhite/subscriptions",
      "organizations_url": "https://api.github.com/users/willnwhite/orgs",
      "repos_url": "https://api.github.com/users/willnwhite/repos",
      "events_url": "https://api.github.com/users/willnwhite/events{/privacy}",
      "received_events_url": "https://api.github.com/users/willnwhite/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-05-10T17:39:06Z",
    "updated_at": "2017-05-10T17:39:06Z",
    "author_association": "NONE",
    "body": "I now have contracts deployed that I'd be happy to destroy, but I'm unable to because I didn't write the appropriate function into them. Also, it'd be great if it didn't cost gas to destroy contracts.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/300558454/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/300765823",
    "html_url": "https://github.com/ethereum/EIPs/issues/88#issuecomment-300765823",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/88",
    "id": 300765823,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwMDc2NTgyMw==",
    "user": {
      "login": "Arachnid",
      "id": 17865,
      "node_id": "MDQ6VXNlcjE3ODY1",
      "avatar_url": "https://avatars.githubusercontent.com/u/17865?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Arachnid",
      "html_url": "https://github.com/Arachnid",
      "followers_url": "https://api.github.com/users/Arachnid/followers",
      "following_url": "https://api.github.com/users/Arachnid/following{/other_user}",
      "gists_url": "https://api.github.com/users/Arachnid/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Arachnid/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Arachnid/subscriptions",
      "organizations_url": "https://api.github.com/users/Arachnid/orgs",
      "repos_url": "https://api.github.com/users/Arachnid/repos",
      "events_url": "https://api.github.com/users/Arachnid/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Arachnid/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-05-11T11:48:29Z",
    "updated_at": "2017-05-11T11:48:29Z",
    "author_association": "MEMBER",
    "body": "There's no blockchain-level concept of a contract \"owner\", and that's how\nit should be. If the person to deploy a contract had a built in escape\nclause of deleting the contract, that would weaken or destroy a lot of\nguarantees that can be offered by contracts.\n\nOn Wed, May 10, 2017 at 6:39 PM Will White <notifications@github.com> wrote:\n\n> I now have contracts deployed that I'd be happy to destroy, but I'm unable\n> to because I didn't write the appropriate function into them. Also, it'd be\n> great if it didn't cost gas to destroy contracts.\n>\n> â€”\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/ethereum/EIPs/issues/88#issuecomment-300558454>, or mute\n> the thread\n> <https://github.com/notifications/unsubscribe-auth/AABFydDv_Muhdlvhk4QAxcTq5JLYnzDjks5r4fY6gaJpZM4H-iHr>\n> .\n>\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/300765823/reactions",
      "total_count": 3,
      "+1": 3,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/343363142",
    "html_url": "https://github.com/ethereum/EIPs/issues/88#issuecomment-343363142",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/88",
    "id": 343363142,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0MzM2MzE0Mg==",
    "user": {
      "login": "jamesray1",
      "id": 16969914,
      "node_id": "MDQ6VXNlcjE2OTY5OTE0",
      "avatar_url": "https://avatars.githubusercontent.com/u/16969914?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jamesray1",
      "html_url": "https://github.com/jamesray1",
      "followers_url": "https://api.github.com/users/jamesray1/followers",
      "following_url": "https://api.github.com/users/jamesray1/following{/other_user}",
      "gists_url": "https://api.github.com/users/jamesray1/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jamesray1/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jamesray1/subscriptions",
      "organizations_url": "https://api.github.com/users/jamesray1/orgs",
      "repos_url": "https://api.github.com/users/jamesray1/repos",
      "events_url": "https://api.github.com/users/jamesray1/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jamesray1/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-11-10T03:14:40Z",
    "updated_at": "2017-11-10T03:17:32Z",
    "author_association": "CONTRIBUTOR",
    "body": "Referenced here: https://ethresear.ch/t/the-stateless-client-concept/172.\r\n\r\nWith a stateless client concept an advantage is: \"All of the thorny questions about state storage economics that lead to the need for designs like rent (eg. https://github.com/ethereum/EIPs/issues/35 http://github.com/ethereum/EIPs/issues/872 http://github.com/ethereum/EIPs/issues/882) and even the current complex SSTORE cost/refund scheme disappear, and blockchain economics can focus purely on pricing bandwidth and computation, a much simpler problem)\".",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/343363142/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/377593831",
    "html_url": "https://github.com/ethereum/EIPs/issues/88#issuecomment-377593831",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/88",
    "id": 377593831,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM3NzU5MzgzMQ==",
    "user": {
      "login": "rkagerer",
      "id": 7076780,
      "node_id": "MDQ6VXNlcjcwNzY3ODA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7076780?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/rkagerer",
      "html_url": "https://github.com/rkagerer",
      "followers_url": "https://api.github.com/users/rkagerer/followers",
      "following_url": "https://api.github.com/users/rkagerer/following{/other_user}",
      "gists_url": "https://api.github.com/users/rkagerer/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/rkagerer/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/rkagerer/subscriptions",
      "organizations_url": "https://api.github.com/users/rkagerer/orgs",
      "repos_url": "https://api.github.com/users/rkagerer/repos",
      "events_url": "https://api.github.com/users/rkagerer/events{/privacy}",
      "received_events_url": "https://api.github.com/users/rkagerer/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-03-30T18:43:55Z",
    "updated_at": "2018-03-30T18:43:55Z",
    "author_association": "NONE",
    "body": "Say you have a dormant contract, maybe something lots of users transacted with years ago (e.g. deposit) and now suddenly there's a burning reason to transact again (e.g. withdraw).  I can just see a situation where everyone's waiting for some other poor sucker to pull the trigger first.  Is it fair that one person pays the whole revival fee, then everyone else can immediately transact for \"free\"?\r\n\r\nMight be prudent to have a mechanism whereby the person who swallowed the fee recovers some of it from subsequent contract invocations for a period of time (scaling off), to discourage \"attrition abuse\".",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/377593831/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/1013846942",
    "html_url": "https://github.com/ethereum/EIPs/issues/88#issuecomment-1013846942",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/88",
    "id": 1013846942,
    "node_id": "IC_kwDOAq426M48bhOe",
    "user": {
      "login": "github-actions[bot]",
      "id": 41898282,
      "node_id": "MDM6Qm90NDE4OTgyODI=",
      "avatar_url": "https://avatars.githubusercontent.com/in/15368?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/github-actions%5Bbot%5D",
      "html_url": "https://github.com/apps/github-actions",
      "followers_url": "https://api.github.com/users/github-actions%5Bbot%5D/followers",
      "following_url": "https://api.github.com/users/github-actions%5Bbot%5D/following{/other_user}",
      "gists_url": "https://api.github.com/users/github-actions%5Bbot%5D/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/github-actions%5Bbot%5D/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/github-actions%5Bbot%5D/subscriptions",
      "organizations_url": "https://api.github.com/users/github-actions%5Bbot%5D/orgs",
      "repos_url": "https://api.github.com/users/github-actions%5Bbot%5D/repos",
      "events_url": "https://api.github.com/users/github-actions%5Bbot%5D/events{/privacy}",
      "received_events_url": "https://api.github.com/users/github-actions%5Bbot%5D/received_events",
      "type": "Bot",
      "site_admin": false
    },
    "created_at": "2022-01-16T10:12:36Z",
    "updated_at": "2022-01-16T10:12:36Z",
    "author_association": "NONE",
    "body": "There has been no activity on this issue for two months. It will be closed in a week if no further activity occurs. If you would like to move this EIP forward, please respond to any outstanding feedback or add a comment indicating that you have addressed all required feedback and are ready for a review.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/1013846942/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/1025119695",
    "html_url": "https://github.com/ethereum/EIPs/issues/88#issuecomment-1025119695",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/88",
    "id": 1025119695,
    "node_id": "IC_kwDOAq426M49GhXP",
    "user": {
      "login": "github-actions[bot]",
      "id": 41898282,
      "node_id": "MDM6Qm90NDE4OTgyODI=",
      "avatar_url": "https://avatars.githubusercontent.com/in/15368?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/github-actions%5Bbot%5D",
      "html_url": "https://github.com/apps/github-actions",
      "followers_url": "https://api.github.com/users/github-actions%5Bbot%5D/followers",
      "following_url": "https://api.github.com/users/github-actions%5Bbot%5D/following{/other_user}",
      "gists_url": "https://api.github.com/users/github-actions%5Bbot%5D/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/github-actions%5Bbot%5D/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/github-actions%5Bbot%5D/subscriptions",
      "organizations_url": "https://api.github.com/users/github-actions%5Bbot%5D/orgs",
      "repos_url": "https://api.github.com/users/github-actions%5Bbot%5D/repos",
      "events_url": "https://api.github.com/users/github-actions%5Bbot%5D/events{/privacy}",
      "received_events_url": "https://api.github.com/users/github-actions%5Bbot%5D/received_events",
      "type": "Bot",
      "site_admin": false
    },
    "created_at": "2022-01-30T11:08:17Z",
    "updated_at": "2022-01-30T11:08:17Z",
    "author_association": "NONE",
    "body": "This issue was closed due to inactivity. If you are still pursuing it, feel free to reopen it and respond to any feedback or request a review in a comment.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/1025119695/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
