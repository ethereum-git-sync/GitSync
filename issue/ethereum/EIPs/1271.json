{
  "url": "https://api.github.com/repos/ethereum/EIPs/issues/1271",
  "repository_url": "https://api.github.com/repos/ethereum/EIPs",
  "labels_url": "https://api.github.com/repos/ethereum/EIPs/issues/1271/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/EIPs/issues/1271/comments",
  "events_url": "https://api.github.com/repos/ethereum/EIPs/issues/1271/events",
  "html_url": "https://github.com/ethereum/EIPs/issues/1271",
  "id": 345405726,
  "node_id": "MDU6SXNzdWUzNDU0MDU3MjY=",
  "number": 1271,
  "title": "ERC-1271 : Standard Signature Validation Method for Contracts ",
  "user": {
    "login": "PhABC",
    "id": 9306422,
    "node_id": "MDQ6VXNlcjkzMDY0MjI=",
    "avatar_url": "https://avatars.githubusercontent.com/u/9306422?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/PhABC",
    "html_url": "https://github.com/PhABC",
    "followers_url": "https://api.github.com/users/PhABC/followers",
    "following_url": "https://api.github.com/users/PhABC/following{/other_user}",
    "gists_url": "https://api.github.com/users/PhABC/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/PhABC/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/PhABC/subscriptions",
    "organizations_url": "https://api.github.com/users/PhABC/orgs",
    "repos_url": "https://api.github.com/users/PhABC/repos",
    "events_url": "https://api.github.com/users/PhABC/events{/privacy}",
    "received_events_url": "https://api.github.com/users/PhABC/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [

  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 149,
  "created_at": "2018-07-28T01:25:00Z",
  "updated_at": "2022-05-28T05:10:56Z",
  "closed_at": "2022-05-28T05:10:56Z",
  "author_association": "CONTRIBUTOR",
  "active_lock_reason": null,
  "body": "**Simple Description**\r\n\r\nMany blockchain based applications allow users to sign off-chain messages instead of directly requesting users to do an on-chain transaction. This is the case for decentralized exchanges with off-chain orderbooks like [0x](https://0xproject.com/) and [etherdelta](https://etherdelta.com/). These applications usually assume that the message will be signed by the same address that owns the assets. However, one can hold assets directly in their regular account (controlled by a private key) or in a smart contract that acts as a wallet (e.g. a multisig contract). The current design of many smart contracts prevent contract based accounts from interacting with them, since contracts do not possess private keys and therefore can not directly sign messages. The proposal here outlines a standard way for contracts to verify if a provided signature is valid when the account is a contract.\r\n\r\nSee [EIP draft](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1271.md).",
  "closed_by": {
    "login": "MicahZoltu",
    "id": 886059,
    "node_id": "MDQ6VXNlcjg4NjA1OQ==",
    "avatar_url": "https://avatars.githubusercontent.com/u/886059?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/MicahZoltu",
    "html_url": "https://github.com/MicahZoltu",
    "followers_url": "https://api.github.com/users/MicahZoltu/followers",
    "following_url": "https://api.github.com/users/MicahZoltu/following{/other_user}",
    "gists_url": "https://api.github.com/users/MicahZoltu/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/MicahZoltu/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/MicahZoltu/subscriptions",
    "organizations_url": "https://api.github.com/users/MicahZoltu/orgs",
    "repos_url": "https://api.github.com/users/MicahZoltu/repos",
    "events_url": "https://api.github.com/users/MicahZoltu/events{/privacy}",
    "received_events_url": "https://api.github.com/users/MicahZoltu/received_events",
    "type": "User",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/1271/reactions",
    "total_count": 33,
    "+1": 30,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 3,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/EIPs/issues/1271/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/408602473",
    "html_url": "https://github.com/ethereum/EIPs/issues/1271#issuecomment-408602473",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1271",
    "id": 408602473,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwODYwMjQ3Mw==",
    "user": {
      "login": "shrugs",
      "id": 1535001,
      "node_id": "MDQ6VXNlcjE1MzUwMDE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1535001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/shrugs",
      "html_url": "https://github.com/shrugs",
      "followers_url": "https://api.github.com/users/shrugs/followers",
      "following_url": "https://api.github.com/users/shrugs/following{/other_user}",
      "gists_url": "https://api.github.com/users/shrugs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/shrugs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/shrugs/subscriptions",
      "organizations_url": "https://api.github.com/users/shrugs/orgs",
      "repos_url": "https://api.github.com/users/shrugs/repos",
      "events_url": "https://api.github.com/users/shrugs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/shrugs/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-07-28T12:01:24Z",
    "updated_at": "2018-07-28T12:01:24Z",
    "author_association": "NONE",
    "body": "Realizing that this is more than just validating signatures; we're actually asking the question \"given this action, does the caller have the ability to it, given this proof\"?\r\n\r\nso perhaps the better metaphor is \r\n\r\n```\r\nisValidAction(bytes _action, bytes _proof) {}\r\n```\r\n\r\nwhere the default behavior might be to treat `_action` as a Bouncer data hash and `_proof` as a signature. But like we noticed before, they could be anything.\r\n\r\nAlthough this implies that the proof handling and the access control are part of the same function/contract where they could potentially be different, although I'm not sure how that separation would generalize at all (i.e. in the case of ECDSA signatures, the validity is just the recovery, which produces an `address` and the access control is a \"does this address have this permission\" check against the `_action` data).\r\n\r\nThoughts, @PhABC?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/408602473/reactions",
      "total_count": 3,
      "+1": 3,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/408627361",
    "html_url": "https://github.com/ethereum/EIPs/issues/1271#issuecomment-408627361",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1271",
    "id": 408627361,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwODYyNzM2MQ==",
    "user": {
      "login": "PhABC",
      "id": 9306422,
      "node_id": "MDQ6VXNlcjkzMDY0MjI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/9306422?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/PhABC",
      "html_url": "https://github.com/PhABC",
      "followers_url": "https://api.github.com/users/PhABC/followers",
      "following_url": "https://api.github.com/users/PhABC/following{/other_user}",
      "gists_url": "https://api.github.com/users/PhABC/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/PhABC/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/PhABC/subscriptions",
      "organizations_url": "https://api.github.com/users/PhABC/orgs",
      "repos_url": "https://api.github.com/users/PhABC/repos",
      "events_url": "https://api.github.com/users/PhABC/events{/privacy}",
      "received_events_url": "https://api.github.com/users/PhABC/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-07-28T18:42:42Z",
    "updated_at": "2018-07-28T18:42:42Z",
    "author_association": "CONTRIBUTOR",
    "body": "That's a good point! A signature is usually used to guarantee that a given address allows something, but other schemes not relying on signature methods could also achieve the same goal.  \r\n\r\nPinging @alexvandesande & @abandeali1 for comments. ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/408627361/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/409807238",
    "html_url": "https://github.com/ethereum/EIPs/issues/1271#issuecomment-409807238",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1271",
    "id": 409807238,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwOTgwNzIzOA==",
    "user": {
      "login": "abandeali1",
      "id": 18060168,
      "node_id": "MDQ6VXNlcjE4MDYwMTY4",
      "avatar_url": "https://avatars.githubusercontent.com/u/18060168?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/abandeali1",
      "html_url": "https://github.com/abandeali1",
      "followers_url": "https://api.github.com/users/abandeali1/followers",
      "following_url": "https://api.github.com/users/abandeali1/following{/other_user}",
      "gists_url": "https://api.github.com/users/abandeali1/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/abandeali1/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/abandeali1/subscriptions",
      "organizations_url": "https://api.github.com/users/abandeali1/orgs",
      "repos_url": "https://api.github.com/users/abandeali1/repos",
      "events_url": "https://api.github.com/users/abandeali1/events{/privacy}",
      "received_events_url": "https://api.github.com/users/abandeali1/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-08-02T05:08:10Z",
    "updated_at": "2018-08-02T05:08:10Z",
    "author_association": "NONE",
    "body": "I personally prefer using a 32 byte hash over an `_action` byte array. Any action should be able to be represented as a hash, and this really simplifies the implementation details. You're probably going to end up hashing `_action` and verifying a signature at some point anyways. Any extra logic could live in the caller contract.\r\n\r\nI could see it making sense to use the word `proof` instead of `signature`, though.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/409807238/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/409812605",
    "html_url": "https://github.com/ethereum/EIPs/issues/1271#issuecomment-409812605",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1271",
    "id": 409812605,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwOTgxMjYwNQ==",
    "user": {
      "login": "PhABC",
      "id": 9306422,
      "node_id": "MDQ6VXNlcjkzMDY0MjI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/9306422?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/PhABC",
      "html_url": "https://github.com/PhABC",
      "followers_url": "https://api.github.com/users/PhABC/followers",
      "following_url": "https://api.github.com/users/PhABC/following{/other_user}",
      "gists_url": "https://api.github.com/users/PhABC/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/PhABC/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/PhABC/subscriptions",
      "organizations_url": "https://api.github.com/users/PhABC/orgs",
      "repos_url": "https://api.github.com/users/PhABC/repos",
      "events_url": "https://api.github.com/users/PhABC/events{/privacy}",
      "received_events_url": "https://api.github.com/users/PhABC/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-08-02T05:44:26Z",
    "updated_at": "2018-08-02T05:44:26Z",
    "author_association": "CONTRIBUTOR",
    "body": "@abandeali1 \r\n\r\nThe reason why we opted for a dynamic byte array is because the `called` contract might request specific data that the `caller` contract is not aware of. \r\n\r\nFor instance, imagine you use a smart account that has some key management properties, where different keys have different roles ([RBAC](https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/access/rbac/RBAC.sol) style). Now imagine that the private key on your phone can sell some game assets, but can't any other types of tokens. Your ledger private key can sell any type of asset. If the caller contract (e.g. 0x contract) only passes the hash of the message, the smart account has no way of knowing what the asset being traded is. The smart account would see two hashes that were indeed signed by two private key you own, but it would have no way of verifying if the action signed is valid based on it's own internal conditions. In this case, your smart account would either need to allow all your private keys to exchange assets via 0x (let them sign hashes) or prevent them all. \r\n\r\nIn general, what i'm trying to say is that I think there could always be additional rules not encompassed by the caller contract that the called contract requires. ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/409812605/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/409819932",
    "html_url": "https://github.com/ethereum/EIPs/issues/1271#issuecomment-409819932",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1271",
    "id": 409819932,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwOTgxOTkzMg==",
    "user": {
      "login": "shrugs",
      "id": 1535001,
      "node_id": "MDQ6VXNlcjE1MzUwMDE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1535001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/shrugs",
      "html_url": "https://github.com/shrugs",
      "followers_url": "https://api.github.com/users/shrugs/followers",
      "following_url": "https://api.github.com/users/shrugs/following{/other_user}",
      "gists_url": "https://api.github.com/users/shrugs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/shrugs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/shrugs/subscriptions",
      "organizations_url": "https://api.github.com/users/shrugs/orgs",
      "repos_url": "https://api.github.com/users/shrugs/repos",
      "events_url": "https://api.github.com/users/shrugs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/shrugs/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-08-02T06:25:37Z",
    "updated_at": "2018-08-02T06:25:37Z",
    "author_association": "NONE",
    "body": "Likewise, my worry is that a hash loses information that may be necessary for validation.\r\n\r\nThat said, I'm also worried about the complexity of passing arbitrary data via a bytes call; we've just accidentally re-created the need for abi encoding/decoding and whoops, we should probably just use solidity for that, so now we're back where we started, creating context-specific methods.\r\nIt may make more sense to simply restrict this to hash + proof validation, and nothing more? that covers bouncer and identity contracts, the two main cases I'd like to use this technique for.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/409819932/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/409825205",
    "html_url": "https://github.com/ethereum/EIPs/issues/1271#issuecomment-409825205",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1271",
    "id": 409825205,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwOTgyNTIwNQ==",
    "user": {
      "login": "abandeali1",
      "id": 18060168,
      "node_id": "MDQ6VXNlcjE4MDYwMTY4",
      "avatar_url": "https://avatars.githubusercontent.com/u/18060168?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/abandeali1",
      "html_url": "https://github.com/abandeali1",
      "followers_url": "https://api.github.com/users/abandeali1/followers",
      "following_url": "https://api.github.com/users/abandeali1/following{/other_user}",
      "gists_url": "https://api.github.com/users/abandeali1/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/abandeali1/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/abandeali1/subscriptions",
      "organizations_url": "https://api.github.com/users/abandeali1/orgs",
      "repos_url": "https://api.github.com/users/abandeali1/repos",
      "events_url": "https://api.github.com/users/abandeali1/events{/privacy}",
      "received_events_url": "https://api.github.com/users/abandeali1/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-08-02T06:52:26Z",
    "updated_at": "2018-08-02T06:52:26Z",
    "author_association": "NONE",
    "body": "You can always encode any extra data about the `hash` in the `signature` field. For example:\r\n\r\n```\r\nfunction isValidSignature(bytes32 hash, bytes signature) external {\r\n    uint8 signatureType = uint8(signature[0]);\r\n    bytes32 msgHash = keccak256(hash, signatureType);\r\n    if (signatureType == 0) {\r\n        // Do something specific to signatureType\r\n        return _isValidSignature(msgHash, signature);\r\n    } else if ...\r\n}\r\n```\r\n\r\nYou can imagine adding any amount of extra data to `signature` in a similar way. This keeps the simplest implementation simple, but it's still pretty flexible if necessary.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/409825205/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/409832349",
    "html_url": "https://github.com/ethereum/EIPs/issues/1271#issuecomment-409832349",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1271",
    "id": 409832349,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwOTgzMjM0OQ==",
    "user": {
      "login": "shrugs",
      "id": 1535001,
      "node_id": "MDQ6VXNlcjE1MzUwMDE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1535001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/shrugs",
      "html_url": "https://github.com/shrugs",
      "followers_url": "https://api.github.com/users/shrugs/followers",
      "following_url": "https://api.github.com/users/shrugs/following{/other_user}",
      "gists_url": "https://api.github.com/users/shrugs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/shrugs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/shrugs/subscriptions",
      "organizations_url": "https://api.github.com/users/shrugs/orgs",
      "repos_url": "https://api.github.com/users/shrugs/repos",
      "events_url": "https://api.github.com/users/shrugs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/shrugs/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-08-02T07:25:01Z",
    "updated_at": "2018-08-02T07:25:01Z",
    "author_association": "NONE",
    "body": "@abandeali1 I'm not convinced that overloading the signature (\"proof\") argument is a ton better than `bytes action, bytes proof`. ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/409832349/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/410408587",
    "html_url": "https://github.com/ethereum/EIPs/issues/1271#issuecomment-410408587",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1271",
    "id": 410408587,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQxMDQwODU4Nw==",
    "user": {
      "login": "shrugs",
      "id": 1535001,
      "node_id": "MDQ6VXNlcjE1MzUwMDE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1535001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/shrugs",
      "html_url": "https://github.com/shrugs",
      "followers_url": "https://api.github.com/users/shrugs/followers",
      "following_url": "https://api.github.com/users/shrugs/following{/other_user}",
      "gists_url": "https://api.github.com/users/shrugs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/shrugs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/shrugs/subscriptions",
      "organizations_url": "https://api.github.com/users/shrugs/orgs",
      "repos_url": "https://api.github.com/users/shrugs/repos",
      "events_url": "https://api.github.com/users/shrugs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/shrugs/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-08-04T00:39:43Z",
    "updated_at": "2018-08-04T00:39:43Z",
    "author_association": "NONE",
    "body": "@PhABC any feedback on restricting this to hash+signature based validation?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/410408587/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/410475220",
    "html_url": "https://github.com/ethereum/EIPs/issues/1271#issuecomment-410475220",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1271",
    "id": 410475220,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQxMDQ3NTIyMA==",
    "user": {
      "login": "abandeali1",
      "id": 18060168,
      "node_id": "MDQ6VXNlcjE4MDYwMTY4",
      "avatar_url": "https://avatars.githubusercontent.com/u/18060168?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/abandeali1",
      "html_url": "https://github.com/abandeali1",
      "followers_url": "https://api.github.com/users/abandeali1/followers",
      "following_url": "https://api.github.com/users/abandeali1/following{/other_user}",
      "gists_url": "https://api.github.com/users/abandeali1/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/abandeali1/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/abandeali1/subscriptions",
      "organizations_url": "https://api.github.com/users/abandeali1/orgs",
      "repos_url": "https://api.github.com/users/abandeali1/repos",
      "events_url": "https://api.github.com/users/abandeali1/events{/privacy}",
      "received_events_url": "https://api.github.com/users/abandeali1/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-08-04T20:21:29Z",
    "updated_at": "2018-08-04T20:21:29Z",
    "author_association": "NONE",
    "body": "@shrugs my point is that it can be done with just a hash+signature, but I wouldn't expect that to be frequently used.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/410475220/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/410493254",
    "html_url": "https://github.com/ethereum/EIPs/issues/1271#issuecomment-410493254",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1271",
    "id": 410493254,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQxMDQ5MzI1NA==",
    "user": {
      "login": "frangio",
      "id": 481465,
      "node_id": "MDQ6VXNlcjQ4MTQ2NQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/481465?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/frangio",
      "html_url": "https://github.com/frangio",
      "followers_url": "https://api.github.com/users/frangio/followers",
      "following_url": "https://api.github.com/users/frangio/following{/other_user}",
      "gists_url": "https://api.github.com/users/frangio/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/frangio/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/frangio/subscriptions",
      "organizations_url": "https://api.github.com/users/frangio/orgs",
      "repos_url": "https://api.github.com/users/frangio/repos",
      "events_url": "https://api.github.com/users/frangio/events{/privacy}",
      "received_events_url": "https://api.github.com/users/frangio/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-08-05T03:37:17Z",
    "updated_at": "2018-08-05T03:37:17Z",
    "author_association": "CONTRIBUTOR",
    "body": "Thanks for writing this up @PhABC, it's quite good.\r\n\r\nThe discussion around @abandeali1's suggestion is very interesting, but we need to show some examples of usage in order to best decide on fixed or arbitrary size `_data` (i.e. the message that is signed).\r\n\r\nI think a good example to analyze is that of an _m_-of-_n_ multisig smart account. A valid signature for this account could be the concatenation of _m_ _(signature, signer)_ pairs, where the _m_ signers are in the set of _n_ signers, and each signature is valid for the message and respective signer. I think this is enough motivation for the signature to be of arbitrary size.\r\n\r\nNow suppose that a family of messages can only be considered signed when the full set of _n_ signers approve. It's common to increase the required number of signatures for large value transfers, so I think it would make sense for the signature scheme to have something analogous to that. The validity of the signature then depends on some parameter in the message being signed. Per @abandeali1's suggestion, the parameter should be included as part of the signature, but then the contract would have to additionally verify that the parameter in the signature is indeed the one contained in the message. If the message is hashed, then the entire message has to also be included in the signature in order to verify the hash. That would be a lot of redundant bytes being passed around. IMO this justifies having the message be of arbitrary size, and not necessarily a hash.\r\n\r\nDo you all agree the scenario described makes sense?\r\n\r\n***\r\n\r\nA mostly unrelated question about the EIP. Would it be valid for an implementation of `isValidSignature` to change its behavior depending on the caller? I have the feeling that this should be forbidden by the spec (\"MUST NOT\"), but unfortunately I don't think there's a way to enforce it in the API.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/410493254/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/410493680",
    "html_url": "https://github.com/ethereum/EIPs/issues/1271#issuecomment-410493680",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1271",
    "id": 410493680,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQxMDQ5MzY4MA==",
    "user": {
      "login": "frangio",
      "id": 481465,
      "node_id": "MDQ6VXNlcjQ4MTQ2NQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/481465?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/frangio",
      "html_url": "https://github.com/frangio",
      "followers_url": "https://api.github.com/users/frangio/followers",
      "following_url": "https://api.github.com/users/frangio/following{/other_user}",
      "gists_url": "https://api.github.com/users/frangio/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/frangio/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/frangio/subscriptions",
      "organizations_url": "https://api.github.com/users/frangio/orgs",
      "repos_url": "https://api.github.com/users/frangio/repos",
      "events_url": "https://api.github.com/users/frangio/events{/privacy}",
      "received_events_url": "https://api.github.com/users/frangio/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-08-05T03:50:47Z",
    "updated_at": "2018-08-05T03:50:47Z",
    "author_association": "CONTRIBUTOR",
    "body": "I forgot to comment on the suggestion to use the names \"action\" and \"proof\". Although I kind of like \"proof\", I would prefer to keep the current names as they're consistent with those of cryptographic signing, and agnostic to any particular use case.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/410493680/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/410494699",
    "html_url": "https://github.com/ethereum/EIPs/issues/1271#issuecomment-410494699",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1271",
    "id": 410494699,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQxMDQ5NDY5OQ==",
    "user": {
      "login": "abandeali1",
      "id": 18060168,
      "node_id": "MDQ6VXNlcjE4MDYwMTY4",
      "avatar_url": "https://avatars.githubusercontent.com/u/18060168?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/abandeali1",
      "html_url": "https://github.com/abandeali1",
      "followers_url": "https://api.github.com/users/abandeali1/followers",
      "following_url": "https://api.github.com/users/abandeali1/following{/other_user}",
      "gists_url": "https://api.github.com/users/abandeali1/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/abandeali1/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/abandeali1/subscriptions",
      "organizations_url": "https://api.github.com/users/abandeali1/orgs",
      "repos_url": "https://api.github.com/users/abandeali1/repos",
      "events_url": "https://api.github.com/users/abandeali1/events{/privacy}",
      "received_events_url": "https://api.github.com/users/abandeali1/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-08-05T04:20:07Z",
    "updated_at": "2018-08-05T04:20:07Z",
    "author_association": "NONE",
    "body": "@frangio overloading the `signature` field should actually result in fewer bytes being passed around and should be cheaper, assuming that `isValidSignature` is being called by another contract (i.e the data is being copied to memory and is not included in the transaction calldata).\r\n\r\nWith `bytes data, bytes signature`, the ABI encoded bytes will look like: [dataOffset][signatureOffset][dataLength][data][signatureLength][signature], where everything is 32 bytes except for `data` and `signature`. This gives us a total of 128 + data.length + signature.length bytes.\r\n\r\nWith `bytes32 hash, bytes signature`, the ABI encoded bytes will look like: [hash][signatureOffset][signatureLength][signature]. This gives us a total of 96 + data.length + signature.length bytes (assuming that the `signature` field includes everything that would otherwise be in the `data` field).\r\n\r\nSo in the worst case scenario of using `bytes32 hash, bytes signature`, we save 32 bytes but add some extra hashing and complexity. \r\n\r\nNow let's look that the case where we we use `bytes data, bytes signature` but `data` only contains a 32 bytes hash. The ABI encoded bytes are [dataOffset][signatureOffset][dataLength][hash][signatureLength][signature]. This means we add 64 bytes vs using `bytes32 hash, bytes signature`. There's an extra hidden cost here though - if calling `isValidSignature` from another contract, we now have to convert our 32 byte hash into a byte array before the call and then parse the hash out of byte array after the call. This isn't particularly easy without using some inline assembly (currently), and I'm guessing that the function will be used this way the majority of the time.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/410494699/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/410494918",
    "html_url": "https://github.com/ethereum/EIPs/issues/1271#issuecomment-410494918",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1271",
    "id": 410494918,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQxMDQ5NDkxOA==",
    "user": {
      "login": "abandeali1",
      "id": 18060168,
      "node_id": "MDQ6VXNlcjE4MDYwMTY4",
      "avatar_url": "https://avatars.githubusercontent.com/u/18060168?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/abandeali1",
      "html_url": "https://github.com/abandeali1",
      "followers_url": "https://api.github.com/users/abandeali1/followers",
      "following_url": "https://api.github.com/users/abandeali1/following{/other_user}",
      "gists_url": "https://api.github.com/users/abandeali1/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/abandeali1/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/abandeali1/subscriptions",
      "organizations_url": "https://api.github.com/users/abandeali1/orgs",
      "repos_url": "https://api.github.com/users/abandeali1/repos",
      "events_url": "https://api.github.com/users/abandeali1/events{/privacy}",
      "received_events_url": "https://api.github.com/users/abandeali1/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-08-05T04:26:52Z",
    "updated_at": "2018-08-05T04:26:52Z",
    "author_association": "NONE",
    "body": "To be honest, the cost differences here are probably minimal. I think the main downside for the `bytes data, bytes signature` approach is converting a bytes32 to and from a byte array. With the `bytes32 hash, bytes signature` approach, the downside is confusion over potentially overloading `signature`. Which is better likely comes down to how often we think each case is likely to be used.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/410494918/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/410545411",
    "html_url": "https://github.com/ethereum/EIPs/issues/1271#issuecomment-410545411",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1271",
    "id": 410545411,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQxMDU0NTQxMQ==",
    "user": {
      "login": "shrugs",
      "id": 1535001,
      "node_id": "MDQ6VXNlcjE1MzUwMDE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1535001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/shrugs",
      "html_url": "https://github.com/shrugs",
      "followers_url": "https://api.github.com/users/shrugs/followers",
      "following_url": "https://api.github.com/users/shrugs/following{/other_user}",
      "gists_url": "https://api.github.com/users/shrugs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/shrugs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/shrugs/subscriptions",
      "organizations_url": "https://api.github.com/users/shrugs/orgs",
      "repos_url": "https://api.github.com/users/shrugs/repos",
      "events_url": "https://api.github.com/users/shrugs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/shrugs/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-08-05T20:23:41Z",
    "updated_at": "2018-08-05T20:23:41Z",
    "author_association": "NONE",
    "body": "The complexity of converting a `bytes32` to `bytes` is _not_ something I'd like people to have to deal with, great point, @abandeali1. And indeed, verifying the signature of a hash seems to be the primary use-case, @frangio.\r\n\r\nI'm happy with, in order of preference:\r\n1) scoping this issue to just be hash + signature validation and encouraging people to overload signature for extra data\r\n2) scoping this issue to just be hash  + signature validation and _not_ encouraging people to overload signature, and instead encouraging a different signature (ideally without overloading the function name) for application-specific action validation\r\n3) using `bytes, bytes` as the arguments and providing a minimal assembly bytes32->bytes conversion library within OpenZeppelin to make it as easy as possible.\r\n\r\nFor naming, I'd prefer `isValidAction`, but am definitely fine with `isValidSignature`.\r\n\r\nhow about some fun voting, multiple choice ok:\r\n- ðŸ˜€for 1\r\n- ðŸŽ‰ for 2\r\n- â¤ï¸ for 3\r\n- ðŸ‘ for `isValidSignature`\r\n- ðŸ‘Ž for `isValidAction`\r\n\r\n(hmm, github should have twitter-style polls that only followers of an issue at time-of-poll can vote on)",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/410545411/reactions",
      "total_count": 25,
      "+1": 11,
      "-1": 0,
      "laugh": 5,
      "hooray": 2,
      "confused": 0,
      "heart": 7,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/410622783",
    "html_url": "https://github.com/ethereum/EIPs/issues/1271#issuecomment-410622783",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1271",
    "id": 410622783,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQxMDYyMjc4Mw==",
    "user": {
      "login": "shrugs",
      "id": 1535001,
      "node_id": "MDQ6VXNlcjE1MzUwMDE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1535001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/shrugs",
      "html_url": "https://github.com/shrugs",
      "followers_url": "https://api.github.com/users/shrugs/followers",
      "following_url": "https://api.github.com/users/shrugs/following{/other_user}",
      "gists_url": "https://api.github.com/users/shrugs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/shrugs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/shrugs/subscriptions",
      "organizations_url": "https://api.github.com/users/shrugs/orgs",
      "repos_url": "https://api.github.com/users/shrugs/repos",
      "events_url": "https://api.github.com/users/shrugs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/shrugs/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-08-06T08:03:31Z",
    "updated_at": "2018-08-06T08:04:16Z",
    "author_association": "NONE",
    "body": "It seems like we'll need to include more information than just action/signature. I'm having trouble visualizing how to abstract signature validation like this so that contracts can recursively \"sign\". I think we need to add the \"delegate\" concept here so we can do \"recursive\" validity. i.e. I'm trying to sign something with my contract, but I want to proxy that validity to _another_ contract.\r\n\r\nI ended up writing something like this; does it make sense?\r\n\r\n```solidity\r\n  // added this function to ECRecovery, so it's used as _hash.isSignedBy(signer, sig)\r\n  function isSignedBy(bytes32 _hash, address _signer, bytes _sig)\r\n    internal\r\n    view\r\n    returns (bool)\r\n  {\r\n    // if the signer address supports SignatureDelegation, delegate to it\r\n    if (_signer.supportsInterface(InterfaceId_SignatureDelegate)) {\r\n      return ISignatureDelegate(_signer).isValidAction(_signer, _hash, _sig);\r\n    }\r\n\r\n    // otherwise make sure the hash was personally signed by the EOA account\r\n    return _signer == recover(toEthSignedMessageHash(_hash), _sig);\r\n  }\r\n\r\n  /**\r\n   * @dev An action is valid iff the _sig of the _action is from an key with the ACTION role\r\n   */\r\n  function isValidAction(address _signer, bytes32 _action, bytes _sig)\r\n    view\r\n    public\r\n    returns (bool)\r\n  {\r\n    // permission\r\n    bool hasPermission = _signer == address(this) || hasRole(_signer, ROLE_ACTION);\r\n\r\n    // validity\r\n    bool isValid = _action.isSignedBy(_signer, _sig);\r\n\r\n    return hasPermission && isValid;\r\n  }\r\n```\r\n\r\nI haven't written any tests for this, but this allows, for example, a multisig to own an identity that owns another identity that can sign 0x orders and operate with off-chain tooling that expects signatures.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/410622783/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/410722532",
    "html_url": "https://github.com/ethereum/EIPs/issues/1271#issuecomment-410722532",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1271",
    "id": 410722532,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQxMDcyMjUzMg==",
    "user": {
      "login": "frangio",
      "id": 481465,
      "node_id": "MDQ6VXNlcjQ4MTQ2NQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/481465?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/frangio",
      "html_url": "https://github.com/frangio",
      "followers_url": "https://api.github.com/users/frangio/followers",
      "following_url": "https://api.github.com/users/frangio/following{/other_user}",
      "gists_url": "https://api.github.com/users/frangio/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/frangio/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/frangio/subscriptions",
      "organizations_url": "https://api.github.com/users/frangio/orgs",
      "repos_url": "https://api.github.com/users/frangio/repos",
      "events_url": "https://api.github.com/users/frangio/events{/privacy}",
      "received_events_url": "https://api.github.com/users/frangio/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-08-06T14:14:29Z",
    "updated_at": "2018-08-06T14:14:29Z",
    "author_association": "CONTRIBUTOR",
    "body": "> we'll need to include more information\r\n\r\nSo, the information that you added was the account for which you need to verify validity, right?\r\n\r\nThat's an interesting thing to point out. With `ecrecover`  the signature and the signed message get you back the account. But there's no way to do that when the signer is a contract, so you need to know what account you will validate the signature against. IMO this doesn't affect this EIP at all, but it would be valuable to add a note about it in the document, because it will affect the design of APIs which do signature validation.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/410722532/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/410757949",
    "html_url": "https://github.com/ethereum/EIPs/issues/1271#issuecomment-410757949",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1271",
    "id": 410757949,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQxMDc1Nzk0OQ==",
    "user": {
      "login": "PhABC",
      "id": 9306422,
      "node_id": "MDQ6VXNlcjkzMDY0MjI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/9306422?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/PhABC",
      "html_url": "https://github.com/PhABC",
      "followers_url": "https://api.github.com/users/PhABC/followers",
      "following_url": "https://api.github.com/users/PhABC/following{/other_user}",
      "gists_url": "https://api.github.com/users/PhABC/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/PhABC/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/PhABC/subscriptions",
      "organizations_url": "https://api.github.com/users/PhABC/orgs",
      "repos_url": "https://api.github.com/users/PhABC/repos",
      "events_url": "https://api.github.com/users/PhABC/events{/privacy}",
      "received_events_url": "https://api.github.com/users/PhABC/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-08-06T15:57:47Z",
    "updated_at": "2018-08-07T00:13:09Z",
    "author_association": "CONTRIBUTOR",
    "body": "**Regarding `(action, proof)` vs `(data, signature)`**\r\n\r\n@shrugs I do like both term pairs ; \"proof\" is probably more future proof, while \"signature\" will be more easily understood for a while given the current practices in the space. Action might not be general enough however, where it's not clear how the term \"action\" fits with the hash of an 0x order for example. Regardless, we can always change the terms in the future since argument naming changes should be backward compatible.  \r\n\r\n-----------------------------\r\n\r\n**Regarding `bytes` vs `bytes32`**\r\n\r\nBoth allow for passing extra data to the receiving contract, so it's really a question of efficiency. It does seem like both have tradeoffs ; `bytes32` will be cheaper when people sign hashes, while `bytes` will be cheaper when receiver contracts need additional data. I am fairly convinced that in the next few years identity contracts will allow for fine grain action based permissions for different private keys (e.g. address `A` can sell any assets, while address `B` can only sell cryptokitties). However, identity contracts are still quite primitive and I agree that most data being signed will be hashes for a while. \r\n\r\nIn terms of converting `bytes32` to `bytes`, you can use `abi.encodePacked()`, such as ; \r\n\r\n```solidity\r\ncontract C { \r\n  function toBytes() public pure returns (bytes) {\r\n    bytes32 a;\r\n    return abi.encodePacked(a);\r\n  }\r\n}\r\n```\r\nwhich costs about 210 gas. Not sure about `bytes => bytes32` however. \r\n\r\n**Edit :** Christian from the Solidity team told me the `abi.decode()` will be able to do `bytes => bytes32` if the `bytes` array is only composed of a `bytes32`, which is true in the case of passing a hash. Hence, it seems to me like we should assume converting `bytes <=> bytes32` should be relatively straightforward in the near future.  \r\n\r\n-----------------------------\r\n\r\n**Regarding passing signer as argument**\r\n\r\nThat's a good point @shrugs. As a side note, I think `ISignatureDelegate(_signer).isValidAction(_signer, _hash, _sig);` will not allow an EOA account to have use a signature validator contract, since `_signer.supportsInterface(InterfaceId_SignatureDelegate)` would always return false when signer is an EOA. Imo, if your EOA holds your fund and you want to use a specific signature scheme, something like what 0x v2 is doing might be more appropriate ; \r\n\r\n```solidity\r\nisValid = IValidator(validatorAddress).isValidSignature(\r\n                hash,\r\n                signerAddress,\r\n                signature\r\n);\r\n```\r\nCode from [here](https://github.com/0xProject/0x-monorepo/blob/47fef1f8ff583879fa83a7a44086b14f69c09e21/packages/contracts/src/2.0.0/protocol/Exchange/MixinSignatureValidator.sol#L198).\r\n\r\nThe above also works for contracts being signers. Also, why couldn't `signer` be also part of the `signature()` argument instead of an additional argument? @abandeali1 you guys probably thought about having `signerAddress` as part of `signature` vs as a separate argument. \r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/410757949/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/410785121",
    "html_url": "https://github.com/ethereum/EIPs/issues/1271#issuecomment-410785121",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1271",
    "id": 410785121,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQxMDc4NTEyMQ==",
    "user": {
      "login": "shrugs",
      "id": 1535001,
      "node_id": "MDQ6VXNlcjE1MzUwMDE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1535001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/shrugs",
      "html_url": "https://github.com/shrugs",
      "followers_url": "https://api.github.com/users/shrugs/followers",
      "following_url": "https://api.github.com/users/shrugs/following{/other_user}",
      "gists_url": "https://api.github.com/users/shrugs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/shrugs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/shrugs/subscriptions",
      "organizations_url": "https://api.github.com/users/shrugs/orgs",
      "repos_url": "https://api.github.com/users/shrugs/repos",
      "events_url": "https://api.github.com/users/shrugs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/shrugs/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-08-06T17:24:22Z",
    "updated_at": "2018-08-06T17:24:22Z",
    "author_association": "NONE",
    "body": "Although I'm realizing there still needs to be a way to recover the contract signer for a signature. Maybe it could be the highly compacted chain of contract addresses like `[address] [address] [v] [r] [s]`? Then you can remove the prefix and send it along to the next one while checking permissions.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/410785121/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/410785986",
    "html_url": "https://github.com/ethereum/EIPs/issues/1271#issuecomment-410785986",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1271",
    "id": 410785986,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQxMDc4NTk4Ng==",
    "user": {
      "login": "shrugs",
      "id": 1535001,
      "node_id": "MDQ6VXNlcjE1MzUwMDE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1535001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/shrugs",
      "html_url": "https://github.com/shrugs",
      "followers_url": "https://api.github.com/users/shrugs/followers",
      "following_url": "https://api.github.com/users/shrugs/following{/other_user}",
      "gists_url": "https://api.github.com/users/shrugs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/shrugs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/shrugs/subscriptions",
      "organizations_url": "https://api.github.com/users/shrugs/orgs",
      "repos_url": "https://api.github.com/users/shrugs/repos",
      "events_url": "https://api.github.com/users/shrugs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/shrugs/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-08-06T17:27:02Z",
    "updated_at": "2018-08-07T04:18:33Z",
    "author_association": "NONE",
    "body": "@phabcd if the account ~different~ doesn't support the interface, it's expected to be an EOA account that signed on behalf of itself so imo that still makes sense. Is that right, you think?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/410785986/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/410829446",
    "html_url": "https://github.com/ethereum/EIPs/issues/1271#issuecomment-410829446",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1271",
    "id": 410829446,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQxMDgyOTQ0Ng==",
    "user": {
      "login": "PhABC",
      "id": 9306422,
      "node_id": "MDQ6VXNlcjkzMDY0MjI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/9306422?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/PhABC",
      "html_url": "https://github.com/PhABC",
      "followers_url": "https://api.github.com/users/PhABC/followers",
      "following_url": "https://api.github.com/users/PhABC/following{/other_user}",
      "gists_url": "https://api.github.com/users/PhABC/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/PhABC/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/PhABC/subscriptions",
      "organizations_url": "https://api.github.com/users/PhABC/orgs",
      "repos_url": "https://api.github.com/users/PhABC/repos",
      "events_url": "https://api.github.com/users/PhABC/events{/privacy}",
      "received_events_url": "https://api.github.com/users/PhABC/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-08-06T19:42:33Z",
    "updated_at": "2018-08-06T19:42:33Z",
    "author_association": "CONTRIBUTOR",
    "body": "> @phabcd if the account different support the interface, it's expected to be an EOA account that signed on behalf of itself so imo that still makes sense. Is that right, you think?\r\n\r\nWith respect to what? I'm not sure I get what this is specifically referring to.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/410829446/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/410928543",
    "html_url": "https://github.com/ethereum/EIPs/issues/1271#issuecomment-410928543",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1271",
    "id": 410928543,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQxMDkyODU0Mw==",
    "user": {
      "login": "shrugs",
      "id": 1535001,
      "node_id": "MDQ6VXNlcjE1MzUwMDE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1535001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/shrugs",
      "html_url": "https://github.com/shrugs",
      "followers_url": "https://api.github.com/users/shrugs/followers",
      "following_url": "https://api.github.com/users/shrugs/following{/other_user}",
      "gists_url": "https://api.github.com/users/shrugs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/shrugs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/shrugs/subscriptions",
      "organizations_url": "https://api.github.com/users/shrugs/orgs",
      "repos_url": "https://api.github.com/users/shrugs/repos",
      "events_url": "https://api.github.com/users/shrugs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/shrugs/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-08-07T04:20:28Z",
    "updated_at": "2018-08-07T04:20:28Z",
    "author_association": "NONE",
    "body": "sorry, was on mobile;\r\n\r\nbasically, the logic to evaluate `isValidSignature` is \r\n1) does the _signerAddress have the permission in my security model?\r\n2) is that signature valid? in which case we either\r\n    1) if supports interface, delegate to the `_signerAddress.isValidSignature(hash, signature)`\r\n    2) otherwise, expect that this is an EOA account so check that `_signerAddress = hash.toEthSignedMessage.recover(signature)`",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/410928543/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/411050541",
    "html_url": "https://github.com/ethereum/EIPs/issues/1271#issuecomment-411050541",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1271",
    "id": 411050541,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQxMTA1MDU0MQ==",
    "user": {
      "login": "PhABC",
      "id": 9306422,
      "node_id": "MDQ6VXNlcjkzMDY0MjI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/9306422?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/PhABC",
      "html_url": "https://github.com/PhABC",
      "followers_url": "https://api.github.com/users/PhABC/followers",
      "following_url": "https://api.github.com/users/PhABC/following{/other_user}",
      "gists_url": "https://api.github.com/users/PhABC/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/PhABC/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/PhABC/subscriptions",
      "organizations_url": "https://api.github.com/users/PhABC/orgs",
      "repos_url": "https://api.github.com/users/PhABC/repos",
      "events_url": "https://api.github.com/users/PhABC/events{/privacy}",
      "received_events_url": "https://api.github.com/users/PhABC/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-08-07T13:11:32Z",
    "updated_at": "2018-08-07T13:11:54Z",
    "author_association": "CONTRIBUTOR",
    "body": "Ah, I understand. So the idea behind having an EOA account using a signature validator contract is for the scenario where the user wants to hold its funds in EOA but does not want to use ECDSA signature scheme, hence need to use a validator contract. It's a pretty niche case, but you could imagine things like BLS signatures or other aggregation signature methods to more efficiently verify many signatures in batch or even quantum secure signature schemes. ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/411050541/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/411152768",
    "html_url": "https://github.com/ethereum/EIPs/issues/1271#issuecomment-411152768",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1271",
    "id": 411152768,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQxMTE1Mjc2OA==",
    "user": {
      "login": "shrugs",
      "id": 1535001,
      "node_id": "MDQ6VXNlcjE1MzUwMDE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1535001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/shrugs",
      "html_url": "https://github.com/shrugs",
      "followers_url": "https://api.github.com/users/shrugs/followers",
      "following_url": "https://api.github.com/users/shrugs/following{/other_user}",
      "gists_url": "https://api.github.com/users/shrugs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/shrugs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/shrugs/subscriptions",
      "organizations_url": "https://api.github.com/users/shrugs/orgs",
      "repos_url": "https://api.github.com/users/shrugs/repos",
      "events_url": "https://api.github.com/users/shrugs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/shrugs/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-08-07T18:18:46Z",
    "updated_at": "2018-08-07T18:18:46Z",
    "author_association": "NONE",
    "body": "I think we're misunderstood, again; I hadn't considered that case, actually.\r\n\r\nRemoving any preconditions, here is some proposed code.\r\n\r\n```solidity\r\n// interface\r\nfunction isValidSignature(bytes _action, bytes _sig)\r\n```\r\n\r\n```solidity\r\n  function isSignedBy(bytes _action, address _signer, bytes _sig)\r\n    internal\r\n    view\r\n    returns (bool)\r\n  {\r\n\r\n    // if the signer address supports signature validation, ask for its permissions/validity\r\n    // which means _sig can be anything\r\n    if (_signer.supportsInterface(InterfaceId_SignatureDelegate)) {\r\n      return ISignatureValidator(_signer).isValidSignature(_action, _sig);\r\n    }\r\n\r\n    // otherwise make sure the hash was personally signed by the EOA account\r\n    // which means _sig should be highly compacted vrs\r\n    bytes32 signedHash = toEthSignedMessageHash(BytesConverter.toBytes32(_action));\r\n    return _signer == recover(signedHash, _sig);\r\n  }\r\n```\r\n\r\n```solidity\r\n// \"isValidSignature\" implementation for identity contracts\r\n\r\n  /**\r\n   * @dev An action is valid iff the _sig of the _action is from an key with the ACTION purpose\r\n   * @param _action\r\n   * @param _sig [[address] [address] [...]] <address> <v> <r> <s>\r\n   */\r\n  function isValidSignature(bytes _action, bytes _sig)\r\n    view\r\n    public\r\n    returns (bool)\r\n  {\r\n    // the fact that this method has been called means the caller knows/expects that\r\n    //   this contract has permission to do a thing.\r\n\r\n    (nextSigner, sig) = splitNextSignerAndSig(_sig);\r\n    // permission\r\n    bytes32 keyId = KeyUtils.idForAddress(nextSigner);\r\n    bool hasPermission = keyHasPurpose(keyId, PURPOSE_ACTION);\r\n\r\n    // validity\r\n    bool isValid = _action.isSignedBy(nextSigner, _sig);\r\n\r\n    return hasPermission && isValid;\r\n  }\r\n```\r\n\r\n```solidity\r\n// now the 0x contracts can do something like\r\n\r\n// https://github.com/0xProject/0x-monorepo/blob/development/packages/contracts/src/2.0.0/protocol/Exchange/MixinSignatureValidator.sol#L188\r\n\r\nBytesConverter.toBytes(hash).isSignedBy(signerAddress, signature);\r\n\r\n// ...\r\n```\r\n\r\nand everything should cascade downwards.\r\n\r\nSo identity contracts can own identity contracts (i.e., multisigs can own multisigs) and we can encoded arbitrary validation logic as well (your identity contract would support BLS verification).\r\n\r\nThe recursive nature of validation is what I think we were missing. without it, we can only do single-level signature validation.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/411152768/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/413308913",
    "html_url": "https://github.com/ethereum/EIPs/issues/1271#issuecomment-413308913",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1271",
    "id": 413308913,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQxMzMwODkxMw==",
    "user": {
      "login": "frangio",
      "id": 481465,
      "node_id": "MDQ6VXNlcjQ4MTQ2NQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/481465?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/frangio",
      "html_url": "https://github.com/frangio",
      "followers_url": "https://api.github.com/users/frangio/followers",
      "following_url": "https://api.github.com/users/frangio/following{/other_user}",
      "gists_url": "https://api.github.com/users/frangio/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/frangio/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/frangio/subscriptions",
      "organizations_url": "https://api.github.com/users/frangio/orgs",
      "repos_url": "https://api.github.com/users/frangio/repos",
      "events_url": "https://api.github.com/users/frangio/events{/privacy}",
      "received_events_url": "https://api.github.com/users/frangio/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-08-15T19:30:00Z",
    "updated_at": "2018-08-15T19:31:06Z",
    "author_association": "CONTRIBUTOR",
    "body": "> So identity contracts can own identity contracts (i.e., multisigs can own multisigs) and we can encoded arbitrary validation logic as well (your identity contract would support BLS verification).\r\n\r\nIs there anything in the current EIP text that you think doesn't enable this?\r\n\r\n***\r\n\r\nI was going to suggest that `isSignedBy` should simply check if the signer is a contract, and not necessarily use `supportsInterface`, but I suppose this is a problem because of selector collisions, right? I mean, that a contract may reply to `isValidSignature` even if it doesn't really implement this method. This could be a real problem.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/413308913/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/413340830",
    "html_url": "https://github.com/ethereum/EIPs/issues/1271#issuecomment-413340830",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1271",
    "id": 413340830,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQxMzM0MDgzMA==",
    "user": {
      "login": "shrugs",
      "id": 1535001,
      "node_id": "MDQ6VXNlcjE1MzUwMDE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1535001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/shrugs",
      "html_url": "https://github.com/shrugs",
      "followers_url": "https://api.github.com/users/shrugs/followers",
      "following_url": "https://api.github.com/users/shrugs/following{/other_user}",
      "gists_url": "https://api.github.com/users/shrugs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/shrugs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/shrugs/subscriptions",
      "organizations_url": "https://api.github.com/users/shrugs/orgs",
      "repos_url": "https://api.github.com/users/shrugs/repos",
      "events_url": "https://api.github.com/users/shrugs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/shrugs/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-08-15T21:19:42Z",
    "updated_at": "2018-08-15T21:19:42Z",
    "author_association": "NONE",
    "body": "presumably we're acting on the contract's behalf, so if it lied and said something was authorized when it wasn't, that'd be its own issue... but I'd have to take some time to think of attack scenarios.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/413340830/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/413363841",
    "html_url": "https://github.com/ethereum/EIPs/issues/1271#issuecomment-413363841",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1271",
    "id": 413363841,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQxMzM2Mzg0MQ==",
    "user": {
      "login": "shrugs",
      "id": 1535001,
      "node_id": "MDQ6VXNlcjE1MzUwMDE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1535001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/shrugs",
      "html_url": "https://github.com/shrugs",
      "followers_url": "https://api.github.com/users/shrugs/followers",
      "following_url": "https://api.github.com/users/shrugs/following{/other_user}",
      "gists_url": "https://api.github.com/users/shrugs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/shrugs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/shrugs/subscriptions",
      "organizations_url": "https://api.github.com/users/shrugs/orgs",
      "repos_url": "https://api.github.com/users/shrugs/repos",
      "events_url": "https://api.github.com/users/shrugs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/shrugs/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-08-15T22:50:47Z",
    "updated_at": "2018-08-15T22:52:38Z",
    "author_association": "NONE",
    "body": "@frangio if a contract doesn't support a method, it might just return garbage data; that's why 165 does  two calls to make doubly sure that it actually supports the `supportInterface(bytes4)` interface.\r\n\r\nBut the current interface definition in the spec is fine, since it claims `bytes` on both arguments, yeah. Once we get `abi.decode`, though, we'll be able to do this parsing of the array much easier. It was just merged in solidity's repo, but idk if it's worth waiting for it to land in order to change this spec to use it?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/413363841/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/439904554",
    "html_url": "https://github.com/ethereum/EIPs/issues/1271#issuecomment-439904554",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1271",
    "id": 439904554,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzOTkwNDU1NA==",
    "user": {
      "login": "izqui",
      "id": 447328,
      "node_id": "MDQ6VXNlcjQ0NzMyOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/447328?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/izqui",
      "html_url": "https://github.com/izqui",
      "followers_url": "https://api.github.com/users/izqui/followers",
      "following_url": "https://api.github.com/users/izqui/following{/other_user}",
      "gists_url": "https://api.github.com/users/izqui/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/izqui/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/izqui/subscriptions",
      "organizations_url": "https://api.github.com/users/izqui/orgs",
      "repos_url": "https://api.github.com/users/izqui/repos",
      "events_url": "https://api.github.com/users/izqui/events{/privacy}",
      "received_events_url": "https://api.github.com/users/izqui/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-11-19T14:09:05Z",
    "updated_at": "2018-11-19T14:09:24Z",
    "author_association": "CONTRIBUTOR",
    "body": "Great conversation! Aragon is currently implementing an Actor app ([WIP implementation](https://github.com/aragon/aragon-apps/blob/actor-app/future-apps/actor/contracts/Actor.sol#L108), [spec and discussion](https://forum.aragon.org/t/actor-app-arbitrary-actions-from-daos)) that allows DAOs to interact with other protocols, and implements signature validation as well.\r\n\r\nAfter reading the discussion, for signature validation we have opted for implementing both `isValidSignature(bytes32 hash, bytes sig)` and `isValidSignature(bytes data, bytes sig)` (just performs `isValidSignature(keccak256(data), sig)`), but when the Actor app has a designated signer that is also a contract, it uses the `isValidSignature(bytes32 hash, bytes sig)`.\r\n\r\nEven though `isValidSignature(bytes data, bytes sig)` seems more flexible, given that there are so many ways that protocols can decide how to hash the data that will be signed (i.e. [ERC712](https://eips.ethereum.org/EIPS/eip-712) requires [multiple hashes](https://github.com/ethereum/EIPs/blob/master/assets/eip-712/Example.sol#L74-L82) and it is not as easy as `hash = keccak256(data)`), it seems more complicated to rely on Identity contracts to implement every possible transformation from data to the hash. Also given that `msg.sender` cannot be relied on for hashing the data in some way or another (as `isValidSignature` may have been forwarded by another contract).\r\n\r\nAs proposed by @abandeali1, in case an implementation of `isValidSignature` needs to behave differently depending on what data is being signed, a proof of what type of data (or a proof to a particular value within the hash) is being signed can be provided, appended to the signature bytes array.\r\n\r\nThat being said, I think getting this initial ERC draft finalized soon is really important, to avoid more protocols and contracts being deployed that either only use ECDSA signatures or a one-off `isValidSignature` type check isn't standard. A standard for having contracts 'sign data' is already really useful and it will be very beneficial for the ecosystem now. Another standard for how to differentiate the data being signed and be able to have more granular rules can be worked on later, and being able to pass arbitrary data in the signature field is future-proof enough IMO.\r\n\r\nPS: I really like the idea of using `proof` instead of `signature`, specially considering any data different from a signature can be passed.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/439904554/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/440671610",
    "html_url": "https://github.com/ethereum/EIPs/issues/1271#issuecomment-440671610",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1271",
    "id": 440671610,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ0MDY3MTYxMA==",
    "user": {
      "login": "wighawag",
      "id": 790580,
      "node_id": "MDQ6VXNlcjc5MDU4MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/790580?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/wighawag",
      "html_url": "https://github.com/wighawag",
      "followers_url": "https://api.github.com/users/wighawag/followers",
      "following_url": "https://api.github.com/users/wighawag/following{/other_user}",
      "gists_url": "https://api.github.com/users/wighawag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/wighawag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/wighawag/subscriptions",
      "organizations_url": "https://api.github.com/users/wighawag/orgs",
      "repos_url": "https://api.github.com/users/wighawag/repos",
      "events_url": "https://api.github.com/users/wighawag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/wighawag/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-11-21T14:01:08Z",
    "updated_at": "2018-11-21T14:01:08Z",
    "author_association": "CONTRIBUTOR",
    "body": "This is definitely something we will need for smart contract based accounts.\r\n\r\nIf I understood correctly though, such function is intended to be implemented by an identity contract and as such any application relying on it to validate signed messages becomes vulnerable to such contract revoking signatures at will.\r\n\r\nImagine a application's smart contract who accept signed messages from anyone and the users rely on these signature being valid for the duration of the process. Let say a user could get punished (withdraw from a deposit) from the content of the signed message. It could be some sort of state channel mechanism for example.\r\n\r\nNow when it is time for a user to publish the signed message, if the smart contract ask the identity smart contract for the validity of these messages through the function mentioned in this proposal, the malicious user could decide to revoke its signature through its identity contract and avoid to be punished. As such application smart contracts would need to trust these identity smart contract in order to provide a fair process. Unless we come up with only one (or a limited set) of these identity contract and everybody use it (unlikely), this is not an option.\r\n\r\nI was imagining another possibility for validating messages. We could have a signer registry who allow any addresses (including identity smart contract) to declare the signers allowed to sign on behalf of them. Only one of such registry would be need to be trusted and only one would need to exist (think like #820)\r\n\r\nWhile the identity contracts should be still able to revoke approved signers using such registry, they should not be able to do instantly since it could break the trust of time based processes. \r\n\r\nThe idea would be that when an address ask the registry to revoke one of its signer, the registry timestamp the request so other smart contract can continue to apply time based logic on the signature and refuse to accept old enough signature but still accept recently revoked one.\r\n\r\n```function approve(address signer)```\r\n```function revoke(address signer)```\r\n```function hasBeenApproved(address signer) returns (boolean)```\r\n```function revokeTimestamp(address signer) returns (uint256 timestamp) // 0 mean it has not been revoked```\r\n\r\nto check signer validity you need to first call ```hasBeenApproved``` which will always return true once a signer has been approved once. Hence you also need to check when was it revoked if ever by calling ```revokeTimestamp``` it it returns 0 you are good to go, if it return a specific timestamp it will depend on your application logic.\r\n\r\nNote by the way that the registry solution as presented would only allow EOA signers but there might be way  for the identity smart contract to register a validator smart contract (that could use the function ```isValidSignature(bytes32 hash, bytes sig)``` mentioned here) as one acting on its behalf. Though it will face the same problem as stated above : such smart contract could revoke access at will, depending of its code. \r\nTo solve this issue, we could propose an approved set of validator smart contract whose role is clearly defined (supporting specific signature protocols) and does nothing else than approving signatures. As new standard comes into being we could update the set.\r\n\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/440671610/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/441311890",
    "html_url": "https://github.com/ethereum/EIPs/issues/1271#issuecomment-441311890",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1271",
    "id": 441311890,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ0MTMxMTg5MA==",
    "user": {
      "login": "frangio",
      "id": 481465,
      "node_id": "MDQ6VXNlcjQ4MTQ2NQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/481465?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/frangio",
      "html_url": "https://github.com/frangio",
      "followers_url": "https://api.github.com/users/frangio/followers",
      "following_url": "https://api.github.com/users/frangio/following{/other_user}",
      "gists_url": "https://api.github.com/users/frangio/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/frangio/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/frangio/subscriptions",
      "organizations_url": "https://api.github.com/users/frangio/orgs",
      "repos_url": "https://api.github.com/users/frangio/repos",
      "events_url": "https://api.github.com/users/frangio/events{/privacy}",
      "received_events_url": "https://api.github.com/users/frangio/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-11-23T20:08:44Z",
    "updated_at": "2018-11-23T20:08:44Z",
    "author_association": "CONTRIBUTOR",
    "body": "@wighawag brings up a super interesting point. The semantics of cryptographic signatures cannot be replicated in identity contracts as generally as we attempted in this ERC. Having a central registry would solve a part of the problem, in that a signature can be guaranteed to remain valid once it's been observed valid on-chain. However, a cryptographic signature observed valid off-chain will also be valid on-chain, which isn't necessarily true for identity contracts. This could be problematic for some protocols.\r\n\r\nI think the ERC is useful, but these subtleties will be confusing to users and render it tricky to use correctly. What does everyone else think?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/441311890/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/441330089",
    "html_url": "https://github.com/ethereum/EIPs/issues/1271#issuecomment-441330089",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1271",
    "id": 441330089,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ0MTMzMDA4OQ==",
    "user": {
      "login": "PhABC",
      "id": 9306422,
      "node_id": "MDQ6VXNlcjkzMDY0MjI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/9306422?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/PhABC",
      "html_url": "https://github.com/PhABC",
      "followers_url": "https://api.github.com/users/PhABC/followers",
      "following_url": "https://api.github.com/users/PhABC/following{/other_user}",
      "gists_url": "https://api.github.com/users/PhABC/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/PhABC/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/PhABC/subscriptions",
      "organizations_url": "https://api.github.com/users/PhABC/orgs",
      "repos_url": "https://api.github.com/users/PhABC/repos",
      "events_url": "https://api.github.com/users/PhABC/events{/privacy}",
      "received_events_url": "https://api.github.com/users/PhABC/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-11-23T23:39:50Z",
    "updated_at": "2018-11-23T23:41:38Z",
    "author_association": "CONTRIBUTOR",
    "body": "@izqui \r\n\r\n> As proposed by @abandeali1, in case an implementation of isValidSignature needs to behave differently depending on what data is being signed, a proof of what type of data (or a proof to a particular value within the hash) is being signed can be provided, appended to the signature bytes array.\r\n\r\nI think this is probably the easiest solution in order to have one function only instead of two. `isValidSignature(hash, proof)` where `proof` seem to encompass both the signature and additional information that would be required for the function to return true. Implementing both could help gathering data however on which method is the most appropriate.\r\n\r\nPerhaps we could say `isValidSignature(bytes32,bytes)` is mandatory and `isValidSignature(bytes,bytes)` is optional?\r\n\r\n@wighawag \r\n> Let say a user could get punished (withdraw from a deposit) from the content of the signed message. It could be some sort of state channel mechanism for example.\r\n\r\nYes, that is a risk indeed, where now the users need to make sure that the signature scheme of the party they are interacting with is sound, which is not trivial. Using a common registry with curated signature functions would be one way, but it might be hard/complicated to satisfy all possible \"proof\" requirements that projects might have.\r\n\r\nI would argue that perhaps state-channels and applications where signatures are use for accountability (slashing, fault attrition, etc.) should force their users to agree on a given signature scheme when not using EOA accounts. Pointing to a signature library could be one of the parameter of the state-channel. \r\n\r\nNevertheless, it seems clear that having `wallet.isValidSignature()` on the contract is not sufficient and that we also need something like `validatorContract.isValidSignature()`. This is something that 0x also supports. \r\n\r\nAny insights @abandeali1 ?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/441330089/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
