{
  "url": "https://api.github.com/repos/ethereum/EIPs/issues/1497",
  "repository_url": "https://api.github.com/repos/ethereum/EIPs",
  "labels_url": "https://api.github.com/repos/ethereum/EIPs/issues/1497/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/EIPs/issues/1497/comments",
  "events_url": "https://api.github.com/repos/ethereum/EIPs/issues/1497/events",
  "html_url": "https://github.com/ethereum/EIPs/issues/1497",
  "id": 370730062,
  "node_id": "MDU6SXNzdWUzNzA3MzAwNjI=",
  "number": 1497,
  "title": "ERC 1497: Evidence Standard",
  "user": {
    "login": "satello",
    "id": 6563204,
    "node_id": "MDQ6VXNlcjY1NjMyMDQ=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6563204?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/satello",
    "html_url": "https://github.com/satello",
    "followers_url": "https://api.github.com/users/satello/followers",
    "following_url": "https://api.github.com/users/satello/following{/other_user}",
    "gists_url": "https://api.github.com/users/satello/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/satello/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/satello/subscriptions",
    "organizations_url": "https://api.github.com/users/satello/orgs",
    "repos_url": "https://api.github.com/users/satello/repos",
    "events_url": "https://api.github.com/users/satello/events{/privacy}",
    "received_events_url": "https://api.github.com/users/satello/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 2328627851,
      "node_id": "MDU6TGFiZWwyMzI4NjI3ODUx",
      "url": "https://api.github.com/repos/ethereum/EIPs/labels/stale",
      "name": "stale",
      "color": "000000",
      "default": false,
      "description": ""
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 19,
  "created_at": "2018-10-16T17:57:33Z",
  "updated_at": "2022-08-10T14:49:32Z",
  "closed_at": "2022-04-16T13:07:15Z",
  "author_association": "NONE",
  "active_lock_reason": null,
  "body": "```\r\nEIP 1497\r\nTitle: Evidence Standard\r\nStatus: Draft\r\nType: Informational\r\nCategory: ERC\r\nAuthors: Sam Vitello <sam@kleros.io>, Cl√©ment Lesaege <clement@kleros.io>, Enrique Piqueras <enrique@kleros.io>\r\nCreated: 2018-10-16\r\n```\r\n\r\n# Abstract\r\n\r\nThe following describes the standards for `MetaEvidence` and `Evidence` for dispute resolution. `Evidence` is provided by a participant in a dispute in order to support their assertion. `MetaEvidence` gives context to the dispute so that arbitrators are able to accurately and fairly evaluate it. This standard follows [ERC 792](https://github.com/ethereum/EIPs/issues/792) and references `Arbitrator` and `Arbitrable` contracts.\r\n\r\n# Motivation\r\n\r\nStandardizing `MetaEvidence` and `Evidence` allows interoperability between `Arbitrable` DApps (DApps where disputes can arise) and `Arbitrator` DApps (DApps which can be used to resolve disputes). It allows these applications to easily switch from one arbitration service to another, or to let their users decide which arbitration service to use without having to spend time to integrate with all of them. `MetaEvidence` is required to provide the context of the dispute. `Evidence` allows for dispute participants to submit extra information for the arbitrators.\r\n\r\nThe ERC792 standardizes the way the smart contracts interact with each other while this standard is made to standardize the way the interfaces interact in the context of disputes.\r\n\r\n# Specification\r\n\r\n## MetaEvidence\r\n\r\n`MetaEvidence` provides the context of the dispute, the question the arbitrators have to answer, the human readable meanings of rulings and specific modes of display for evidence.\r\n\r\n**NOTE:** Each dispute includes only one piece of `MetaEvidence`, however, the same `MetaEvidence` can be used for multiple disputes.\r\n**NOTE:** It is up to the `Arbitrable` contract to determine how `MetaEvidence` is submitted and assigned to a dispute.\r\n**NOTE:** In some use cases, `MetaEvidence` is all that the `Arbitrator` will need in order to make a ruling.\r\n**NOTE:** All `MetaEvidence` fields are optional. An `Arbitrator` interface should have defaults for every field. However, not supplying contextual fields may affect the arbitrator‚Äôs ability to make an accurate ruling. Not supplying hash fields meant to secure the integrity of the data may result in arbitrators being warned that the data could have been altered.\r\n\r\n### Events\r\n\r\n**MetaEvidence**\r\n`MetaEvidence` has to be created before a dispute can arise. The `MetaEvidence` event includes an identifier used to link the `MetaEvidence` to a dispute and the `_evidence` reference is a URI to a JSON file, specified below, whose name is the multihash hash of the file with no file type extension. The JSON file should have all insignificant whitespace removed before hashing.\r\n\r\nTo be emitted when `MetaEvidence` is submitted:\r\n\r\n```javascript\r\nevent MetaEvidence(uint indexed _metaEvidenceID, string _evidence);\r\n```\r\n\r\n### JSON\r\n\r\nThe `MetaEvidence` JSON file includes the following properties:\r\n\r\n```\r\n{\r\n  \"fileURI\": string,\r\n  \"fileHash\": string,\r\n  ‚ÄúfileTypeExtension\": string,\r\n  \"category\": string,\r\n  \"title\": string,\r\n  \"description\": string,\r\n  \"aliases\": {\r\n    [string]: string\r\n  },\r\n  \"question\": string,\r\n  \"rulingOptions\": {\r\n    \"type\": string,\r\n    \"precision\": number,\r\n    \"titles\": [],\r\n    \"descriptions\": []\r\n  },\r\n  \"evidenceDisplayInterfaceURI\": string,\r\n  \"evidenceDisplayInterfaceHash\": string,\r\n  \"dynamicScriptURI\": string,\r\n  \"dynamicScriptHash: string\r\n}\r\n```\r\n\r\n#### fileURI\r\n\r\nThe URI that leads to a natural language contract, agreement, or primary document that is the basis of the dispute. The file name should be the multihash hash of the resulting file. If this is not possible use `fileHash`.\r\n\r\n_Example: \"/ipfs/QmUQMJbfiQYX7k6SWt8xMpR7g4vwtAYY1BTeJ8UY8JWRs9‚Äù_\r\n\r\n#### fileHash\r\n\r\nThe multihash hash of the primary document file. This may not be included for dynamic or mutable evidence. Not including the hash, either as the file name or in this property, may result in arbitrators being made aware that the evidence could have been altered.\r\n\r\n_Example: ‚ÄúQmUQMJbfiQYX7k6SWt8xMpR7g4vwtAYY1BTeJ8UY8JWRs9‚Äù_\r\n\r\n#### fileTypeExtension\r\n\r\nThe file type extension of the resulting file. This can be used by an `Arbitrator` interface to display the file.\r\n\r\n_Example: ‚Äúpdf‚Äù_\r\n\r\n#### category\r\n\r\nA short (one word or phrase) high level identifier for the type of dispute. E.g. ‚ÄúCurated List‚Äù, ‚ÄúOracle‚Äù or ‚ÄúEscrow‚Äù.\r\n\r\n_Example: \"Escrow\"_\r\n\r\n#### title\r\n\r\nTitle that summarizes the relationship between the participants.\r\n\r\n_Example: \"Alice Builds a Webpage for Bob\"_\r\n\r\n#### description\r\n\r\nDescription of the relationship between the participants. Here is where more detail can be provided so that arbitrators can fully understand the context in which the dispute arose. It can be a summary of the terms of the primary document file, and/or include other contextual information.\r\n\r\n_Example: \"Alice is hired by Bob as a contractor to create a website for his company. When completed, the site will be hosted at https://my-site.com.\"_\r\n\r\n#### aliases\r\n\r\nA mapping that can be used by the `Arbitrator` interface to translate each given key to the supplied value. For example, ETH addresses can be mapped to human readable terms to make the dispute easier to understand.\r\n\r\n_Example:_ \r\n```json\r\n{\r\n    \"0x56b2b5C88C9AC1D0E5785ED1A7c7B28173F5eE1b\": \"Alice\",\r\n    \"0x8961286757C764a4a6Be9689649BA9E08DBaca4a\": \"Bob\"\r\n}\r\n```\r\n\r\n#### question\r\n\r\nThe question that arbitrators have to answer.\r\n\r\n_Example: \"Is the website compliant with the terms of the contract?\"_\r\n\r\n#### rulingOptions\r\n\r\nInformation about the ruling options to provide clarity on the available rulings to arbitrators. \r\n\r\nIndexes of `titles` and `descriptions` map to the ruling options of the `Arbitrable` contract. Ruling indexing starts at ruling option 1 (rulingOptions.titles[0] corresponds to ruling option 1 in the `Arbitrable` contract). The ruling option 0 is always reserved for ‚ÄúRefuse to Arbitrate‚Äù and should not be included in the array. The `Arbitrator` interface can specify the specific title and description used for the ‚ÄúRefuse to Arbitrate‚Äù ruling.\r\n\r\n`type` is used to indicate to the arbitrator interface how a ruling should be made. There are 5 basic types that an arbitrator interface are expected to support. If a `type` is not specified, the arbitrator interface should default to type `single-select`. Arbitrator interfaces can choose to support other custom types.\r\n\r\n- `single-select`: arbitrators select one answer among the provided options.\r\n- `multiple-select`: arbitrators can select any number of the provided options.\r\n- `uint`: arbitrators input an unsigned integer.\r\n- `int`: arbitrators input a signed integer.\r\n- `string`: arbitrators enter a string. String must fit into `bytes32`.\r\n\r\n`precision` is used for ruling types `int` and `uint` to indicate the number of decimal places a ruling contains.\r\n\r\n_Example:_\r\n```\r\n{\r\n    \"type\": \"single-select\",\r\n    ‚Äútitles‚Äù: [‚ÄúYes‚Äù, ‚ÄúNo‚Äù],\r\n    ‚Äúdescriptions‚Äù: [\r\n         \"The website is compliant. This will release the funds to Alice.\",\r\n         \"The website is not compliant. This will refund Bob.\"\r\n    ]\r\n}\r\n```\r\n\r\n#### evidenceDisplayInterfaceURI\r\n\r\nThe URI to a display interface that should be used to render the evidence for arbitrators. The `Arbitrator` interface should use an iframe to render the display interface. Data can be passed to the custom display interface with query parameters or with browser based approaches such as `window.postMessage`.\r\n\r\n**NOTE:** `Arbitrator` interfaces should still have a default way to display evidence, as not all evidence will use a custom evidence display interface.\r\n**NOTE:** `Arbitrator` interfaces should take security precautions when injecting the evidence display interface code into their page. The iframe used to render the external interface should be secured properly with a sandbox or other means of disabling functionality that could pose a security risk to the interface or users. For example, an interface should disallow the injected `web3` object from MetaMask or a different browser wallet from requesting signatures from the user. This can be accomplished by using a sandbox to disallow the external interface from retaining its origin (and therefore using the browser‚Äôs built in security features to block API requests), or by removing methods such as `sign` and `personalSign` from the injected `web3` object.\r\n\r\n_Example: \"https://my-site.com/evidence-display/escrow\"_\r\n\r\n#### evidenceDisplayInterfaceHash\r\n\r\nLike `fileHash` for `fileURI`.\r\n\r\n_Example: ‚ÄúQmUQMJbfiQYX7k6SWt8xMpR7g4vwtAYY1BTeJ8UY8JWRs9‚Äù_\r\n\r\n\r\n#### dynamicScriptURI\r\n\r\nThe URI of a script that can be run when the `MetaEvidence` is fetched by an arbitrator interface in order to make dynamic updates. The script should expose a function `getMetaEvidence` that returns JSON, which should be merged with the original `MetaEvidence` JSON.\r\n\r\n**NOTE:** `Arbitrator` interfaces should take security precautions when running an external script. A script should never be run directly inline as this would give the script full access to the DOM and make calls on behalf of the arbitrator. Instead the script should be run in a sandbox such as an iframe so that the scope is limited.\r\n\r\nExample: \"/ipfs/QmUQMJbfiQYX7k6SWt8xMpR7g4vwtAYY1BTeJ8UY8JWRs9‚Äù\r\n\r\n\r\n#### dynamicScriptHash\r\n\r\nLike `fileHash` for `fileURI`.\r\n\r\n## Evidence\r\n\r\n`Arbitrable` contracts emit an event that contains a reference to an evidence JSON file when new evidence is submitted.\r\n\r\n### Events\r\n\r\n**Evidence**\r\n\r\nThe event log should include the `Arbitrator` contract, an identifier for the `EvidenceGroup` it belongs to, the address of the submitting party, and reference to the evidence itself. The evidence reference is a URI to a JSON file, specified below, whose name is the multihash hash of the file with no file type extension. The JSON file should have all insignificant whitespace removed before hashing.\r\n\r\n**NOTE:** An `EvidenceGroup` is used to link individual pieces of evidence and eventually to link the entire grouping of evidence to a dispute. An Evidence Group must have it's own unique identifier so that Evidence can be submitted before a dispute has been raised.\r\n\r\nTo be triggered when evidence is submitted:\r\n```javascript\r\nevent Evidence(Arbitrator indexed _arbitrator, uint indexed _evidenceGroupID, address indexed _party, string _evidence)\r\n```\r\n\r\n### JSON\r\n\r\nThe `Evidence` JSON file includes the following properties:\r\n\r\n```\r\n{\r\n  \"fileURI\": string,\r\n  \"fileHash\": string,\r\n  \"fileTypeExtension\": string,\r\n  \"name\": string,\r\n  \"description\": string\r\n}\r\n```\r\n\r\n#### fileURI\r\n\r\nLike the `fileURI` for `MetaEvidence`.\r\n\r\n_Example: ‚Äú/ipfs/QmWQV5ZFFhEJiW8Lm7ay2zLxC2XS4wx1b2W7FfdrLMyQQc‚Äù._\r\n\r\n#### fileHash\r\n\r\nLike the `fileHash` for `MetaEvidence`.\r\n\r\n_Example: ‚ÄúQmWQV5ZFFhEJiW8Lm7ay2zLxC2XS4wx1b2W7FfdrLMyQQc‚Äù._\r\n\r\n#### fileTypeExtension\r\n\r\nLike the `fileTypeExtension` for `MetaEvidence`.\r\n\r\n_Example: ‚Äúpdf‚Äù._\r\n\r\n#### name\r\n\r\nWhat the piece of evidence should be called.\r\n\r\n_Example: ‚ÄúEmail clarifying the terms of the contract.‚Äù_\r\n\r\n#### description\r\n\r\nA brief description of what the evidence contains. Can also include any necessary context to understand the evidence.\r\n\r\n_Example: ‚ÄúThis is an email sent to Alice from Bob that clarifies that the checkout screen can be integrated with the catalog page.‚Äù_\r\n\r\n## Dispute\r\n\r\nA dispute must include a `MetaEvidence` and an `EvidenceGroup`. A dispute can have one `MetaEvidence` and many pieces of `Evidence` that are linked together by an `EvidenceGroup`.\r\n\r\n### Events\r\n\r\n**Dispute**\r\nThe `Dispute` event is raised when a dispute is created to link the proper `MetaEvidence` and `EvidenceGroup` to the dispute. The event includes a reference to the `Arbitrator`, a unique identifier for the dispute itself, the identifier used to look up the `MetaEvidence` event log and the identifier of the `EvidenceGroup` that can be used to look up all evidence submitted in the grouping.\r\n\r\nTo be emitted when a dispute is created.\r\n\r\n```javascript\r\nevent Dispute(Arbitrator indexed _arbitrator, uint indexed _disputeID, uint _metaEvidenceID, uint _evidenceGroupID);\r\n```\r\n\r\n## Rationale\r\n\r\n- A series of hashes are used to verify that evidence has not been tampered with. The blockchain events can maintain integrity of the address of the submitter, the date of submission, and the hash of the `MetaEvidence` or `Evidence` file. Hashes included in the JSON file of the `MetaEvidence` or `Evidence` can then be used to verify that the evidence has not changed since submission.\r\n- JSON objects are a standard way to structure and share data on the web. They provide structural flexibility to represent any type of data, can maintain integrity through use of hashing, and are easily interpreted.\r\n- It is not practical to store all type of evidence on the blockchain, so links to off-chain evidence are broadcasted instead. URIs are compatible with classical web URLs as well as decentralized web storage such as IPFS and SWARM. Both partially and fully decentralized dapps can be supported with URIs.\r\n- The fileURI and fileHash are two separate variables in the `MetaEvidence` and `Evidence` JSON to maximize flexibility on the types of links that can be used (as opposed to only supporting the hash as the file name). For example, if the evidence is a news article or some other public resource, the hash needs to be included separately.\r\n- `dynamicScriptURI` was chosen instead of a callback because it gives Arbitrable parties the ability to provide audibility. The script can be publicly posted with the included hash so that arbitrators can verify that the same edits are being made for everyone who runs the script. It is harder to prove this on a privately hosted callback.\r\n\r\n## Implementations\r\n\r\n### Smart Contract Examples\r\n\r\n- Single Dispute `Arbitrable` Contract:\r\nhttps://github.com/kleros/kleros-interaction/blob/master/contracts/standard/arbitration/ArbitrableTransaction.sol\r\n      \r\n- Multi-Dispute `Arbitrable` Contract:\r\nhttps://github.com/kleros/kleros-interaction/blob/master/contracts/standard/arbitration/MultipleArbitrableTransaction.sol\r\n\r\n### JSON File Examples\r\n\r\n- MetaEvidence:\r\nhttps://s3.us-east-2.amazonaws.com/kleros-examples/9fgZ2uU5hUtmhNZX4h64LSAAGP5VBCsVeLVSCyyESxN9121wuRs9vaV1Y3Pn9P1XKoX5unszjc16bz6WCMoFdKP1ow\r\n\r\n### Evidence Display Interface Examples\r\n\r\n- URI: https://juror.kleros.io/evidence-display/doges-on-trial\r\n- Code: https://github.com/kleros/kleros-juror-front/blob/cca73c85c8532115d64c8a2cbb2844f1ce4edcc1/src/components/iframes/doges-on-trial-evidence/index.js\r\n- `Arbitrator` Interface Code:\r\nhttps://github.com/kleros/kleros-juror-front/blob/3ecafbbddd036779993c2bca2ace40882ebe164a/src/containers/dispute/components/details/index.js\r\n\r\n### Dynamic Script Examples\r\n\r\n- DynamicScript: https://github.com/kleros/realitio-script/blob/master/src/index.js\r\n",
  "closed_by": {
    "login": "github-actions[bot]",
    "id": 41898282,
    "node_id": "MDM6Qm90NDE4OTgyODI=",
    "avatar_url": "https://avatars.githubusercontent.com/in/15368?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/github-actions%5Bbot%5D",
    "html_url": "https://github.com/apps/github-actions",
    "followers_url": "https://api.github.com/users/github-actions%5Bbot%5D/followers",
    "following_url": "https://api.github.com/users/github-actions%5Bbot%5D/following{/other_user}",
    "gists_url": "https://api.github.com/users/github-actions%5Bbot%5D/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/github-actions%5Bbot%5D/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/github-actions%5Bbot%5D/subscriptions",
    "organizations_url": "https://api.github.com/users/github-actions%5Bbot%5D/orgs",
    "repos_url": "https://api.github.com/users/github-actions%5Bbot%5D/repos",
    "events_url": "https://api.github.com/users/github-actions%5Bbot%5D/events{/privacy}",
    "received_events_url": "https://api.github.com/users/github-actions%5Bbot%5D/received_events",
    "type": "Bot",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/1497/reactions",
    "total_count": 10,
    "+1": 6,
    "-1": 0,
    "laugh": 0,
    "hooray": 4,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/EIPs/issues/1497/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/464844323",
    "html_url": "https://github.com/ethereum/EIPs/issues/1497#issuecomment-464844323",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1497",
    "id": 464844323,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2NDg0NDMyMw==",
    "user": {
      "login": "satello",
      "id": 6563204,
      "node_id": "MDQ6VXNlcjY1NjMyMDQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6563204?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/satello",
      "html_url": "https://github.com/satello",
      "followers_url": "https://api.github.com/users/satello/followers",
      "following_url": "https://api.github.com/users/satello/following{/other_user}",
      "gists_url": "https://api.github.com/users/satello/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/satello/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/satello/subscriptions",
      "organizations_url": "https://api.github.com/users/satello/orgs",
      "repos_url": "https://api.github.com/users/satello/repos",
      "events_url": "https://api.github.com/users/satello/events{/privacy}",
      "received_events_url": "https://api.github.com/users/satello/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-02-18T19:00:53Z",
    "updated_at": "2019-02-18T19:00:53Z",
    "author_association": "NONE",
    "body": "I have updated the standard by adding Evidence Groupings to the Evidence submission and Dispute creation events. Previously, Evidence was linked directly to a `disputeID`. This restricted Evidence from being submitted before a dispute had been raised and the `disputeID` created. Now Evidence can be submitted at any time, and will be linked to a dispute by the `Dispute` event (raised when a dispute is created) via a `evidenceGroupID`.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/464844323/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/487121885",
    "html_url": "https://github.com/ethereum/EIPs/issues/1497#issuecomment-487121885",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1497",
    "id": 487121885,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ4NzEyMTg4NQ==",
    "user": {
      "login": "marsrobertson",
      "id": 44369284,
      "node_id": "MDQ6VXNlcjQ0MzY5Mjg0",
      "avatar_url": "https://avatars.githubusercontent.com/u/44369284?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/marsrobertson",
      "html_url": "https://github.com/marsrobertson",
      "followers_url": "https://api.github.com/users/marsrobertson/followers",
      "following_url": "https://api.github.com/users/marsrobertson/following{/other_user}",
      "gists_url": "https://api.github.com/users/marsrobertson/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/marsrobertson/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/marsrobertson/subscriptions",
      "organizations_url": "https://api.github.com/users/marsrobertson/orgs",
      "repos_url": "https://api.github.com/users/marsrobertson/repos",
      "events_url": "https://api.github.com/users/marsrobertson/events{/privacy}",
      "received_events_url": "https://api.github.com/users/marsrobertson/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-04-26T16:39:20Z",
    "updated_at": "2019-04-28T11:13:59Z",
    "author_association": "NONE",
    "body": "### Evidence:\r\n\r\nIs `fileTypeExtension` required? Maybe it can be derived from: https://en.wikipedia.org/wiki/MIME_type\r\n\r\n_(as a security practice, do not rely on user-provided input, is it ZIP or PDF or HTML [Poc||GTFO](https://www.alchemistowl.org/pocorgtfo/pocorgtfo18.pdf))_\r\n\r\n\r\n### MetaEvidence:\r\n\r\n`title`, `question`, `category`, `description` - too many fields, repetetive.\r\n\r\n`rulingOptions`, `type`, `single`, `multiple` - I'd like to add `number`, `value`, `range`, `ratio` or `proportion`... Worried it is getting out of hand, if in doubt simplify.\r\n\r\n`aliases` - not necessary, can live without it. ENS will provide names.\r\n\r\n`evidenceDisplayInterfaceURI` - all evidence is hosted on IPFS or centralized servers, just open in a browser, do I need this info?\r\n\r\n`dynamicScriptURI` - too complicated. Just submit new `MetaEvidence`\r\n\r\n`selfHash` - someone who modifies evidence can modify `selfHash` as well, I don't understand what is the point\r\n\r\n### Meta MetaEvidence\r\n\r\nhttps://github.com/ethereum/EIPs/issues/792 is using human-readable names such as **Dispute**, **Decision**, **Appeal**, **Ruling**\r\n\r\nMy suggestion would be to replace geeky sounding **MetaEvidence** with **DisputeInfo** or **ArbitrationInfo** or simply **Dispute** or **Arbitration** or **Case** or **Matter** _(legal language)_\r\n\r\n-----\r\n\r\n**EDIT:** Noticed **Dispute** already exists. **MetaEvidence** is nothing else than **DisputeInfo** - definitely merge into one, simplify.\r\n\r\n**EDIT:**\r\n\r\n>  If it is not possible to use multihash for the name of the file, use the selfHash field described below.\r\n\r\nIf it is not possible to use multihash for the name of the file:\r\n1. use the selfHash for the name of the file?\r\n2. store multiHash as selfHash?\r\n\r\n_(previous comment about someone replacing content and validating hashes remain valid)_\r\n\r\n**EDIT:** `MetaEvidence`all fields optional, `Evidence` all fields optional too?\r\n\r\n**EDIT:** No extension:\r\n> The evidence reference is a URI to a JSON file, specified below, whose name is the multihash hash of the file with no file type extension. \r\n\r\nOr extension: https://github.com/kleros/kleros-interaction/blob/96b34176090e3a17d5208f3093ec15a4482d7c43/contracts/standard/arbitration/IArbitrable.sol#L38\r\n\r\n\r\n-----\r\n\r\nI'm literally working on the hackathon project https://github.com/kleros/hackathon/issues/1 and I'm likely to have more thoughts after completion. ~Will update this post or~ **submit a new comment**.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/487121885/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/487187703",
    "html_url": "https://github.com/ethereum/EIPs/issues/1497#issuecomment-487187703",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1497",
    "id": 487187703,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ4NzE4NzcwMw==",
    "user": {
      "login": "satello",
      "id": 6563204,
      "node_id": "MDQ6VXNlcjY1NjMyMDQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6563204?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/satello",
      "html_url": "https://github.com/satello",
      "followers_url": "https://api.github.com/users/satello/followers",
      "following_url": "https://api.github.com/users/satello/following{/other_user}",
      "gists_url": "https://api.github.com/users/satello/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/satello/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/satello/subscriptions",
      "organizations_url": "https://api.github.com/users/satello/orgs",
      "repos_url": "https://api.github.com/users/satello/repos",
      "events_url": "https://api.github.com/users/satello/events{/privacy}",
      "received_events_url": "https://api.github.com/users/satello/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-04-26T20:16:37Z",
    "updated_at": "2019-04-26T20:16:37Z",
    "author_association": "NONE",
    "body": "- `fileTypeExtension` is not required. If the file includes the MIME type it can be derived by the arbitrator interface that way. None of the fields are required. However, not including some fields may cause an Arbitrator interface to be unable to display a dispute.\r\n\r\n- `title`, `question`, `category`, `description` all have different purposes so they are not redundant. It is not required that you use them all if they are not relevant to the dispute.\r\n\r\n- `rulingsOptions.type` has been updated to have a basic set of types `['single-select', 'multiple-select', 'uint', 'int', 'string']`. It is not meant to be an exhaustive list of types, just a basic set that all Arbitrator interfaces can be expected to support.\r\n\r\n- `aliases`: If you derive names another way you do not need to use it.\r\n\r\n- `evidenceDisplayInterfaceURI`: Evidence can be hosted on a centralized or decentralized platform.\r\n\r\n- `dynamicScriptURI`: For disputes that will have dynamic content it adds bloat and extra gas to have to continually emit new MetaEvidence. Also for some use cases the data might be too dynamic to continually update it on chain. It is much simpler, less expensive and more flexible to handle it off chain.\r\n\r\n- `selfHash`: Yes you are right, this will not work. I have changed it so that hashes must be in the file name.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/487187703/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/487369753",
    "html_url": "https://github.com/ethereum/EIPs/issues/1497#issuecomment-487369753",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1497",
    "id": 487369753,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ4NzM2OTc1Mw==",
    "user": {
      "login": "marsrobertson",
      "id": 44369284,
      "node_id": "MDQ6VXNlcjQ0MzY5Mjg0",
      "avatar_url": "https://avatars.githubusercontent.com/u/44369284?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/marsrobertson",
      "html_url": "https://github.com/marsrobertson",
      "followers_url": "https://api.github.com/users/marsrobertson/followers",
      "following_url": "https://api.github.com/users/marsrobertson/following{/other_user}",
      "gists_url": "https://api.github.com/users/marsrobertson/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/marsrobertson/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/marsrobertson/subscriptions",
      "organizations_url": "https://api.github.com/users/marsrobertson/orgs",
      "repos_url": "https://api.github.com/users/marsrobertson/repos",
      "events_url": "https://api.github.com/users/marsrobertson/events{/privacy}",
      "received_events_url": "https://api.github.com/users/marsrobertson/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-04-28T11:17:49Z",
    "updated_at": "2019-04-28T15:48:37Z",
    "author_association": "NONE",
    "body": "> the identifier of the `MetaEvidence` event that will provide the URI to the `MetaEvidence`\r\n\r\n`event Dispute(Arbitrator indexed _arbitrator, uint indexed _disputeID, uint _metaEvidenceID, uint _evidenceGroupID);`\r\n\r\n### Suggestion (assuming we were using IPFS)\r\n\r\n`string _metaEvidenceHash`\r\n\r\nIf we were using IFPS, we could simply use the hash, instead of the event id... I'm not that good with Ethereum events and accessing their IDs, I thought I'll mention that.\r\n\r\nReal-world usage: https://github.com/kleros/kleros-interaction/blob/1ada4bf9d2cc024c162257def03763ad6111c0ff/contracts/standard/arbitration/MultipleArbitrableTokenTransaction.sol#L283\r\n\r\n`emit Dispute(arbitrator, transaction.disputeId, _transactionID, _transactionID);`\r\n\r\nUsing `_transactionID` for both `_metaEvidenceID` and `_evidenceGroupID` üßê Maybe `_evidenceGroupID` should be `0`, appeal becomes `1`, appeal appeal becomes `2`...\r\n\r\n-----\r\n\r\n**EDIT:**\r\n\r\nFrom my previous comment\r\n\r\n> https://github.com/ethereum/EIPs/issues/792 is using human-readable names such as **Dispute**, **Decision**, **Appeal**, **Ruling**\r\n\r\n> My suggestion would be to replace geeky sounding **MetaEvidence** with **DisputeInfo** or **ArbitrationInfo** or simply **Dispute** or **Arbitration** or **Case** or **Matter** _(legal language)_\r\n\r\n> Noticed **Dispute** already exists. **MetaEvidence** is nothing else than **DisputeInfo** - definitely merge into one, simplify.\r\n\r\nhttps://github.com/kleros/kleros-interaction/blob/1ada4bf9d2cc024c162257def03763ad6111c0ff/contracts/standard/arbitration/MultipleArbitrableTokenTransaction.sol#L127\r\n\r\n`Link to the meta-evidence.`\r\n\r\nI think we need to simplify and agree:\r\n\r\n* Link (URI) to MetaEvidence\r\n* IPFS hash of MetaEvidence\r\n* ID of MetaEvidence\r\n\r\nOtherwise, it is not obvious, not clear, error-prone.\r\n\r\n----\r\n\r\n**EDIT:**\r\n\r\n> The MetaEvidence event includes an identifier used to link the MetaEvidence to a dispute and the _evidence reference is a URI to a JSON file, specified below, whose name is the multihash hash of the file with no file type extension.\r\n\r\nI would like to submit that JSON to IPFS. \r\n\r\nI know that library written by @satello -  https://archon.readthedocs.io/en/latest/ipfs.html - is accepting the following URI schemes:\r\n```\r\n/ipfs/Qm...../foo/bar\r\nipfs:/ipfs/Qm...../foo/bar\r\nfs:/ipfs/Qm...../foo/bar\r\n```\r\nhttps://github.com/ipfs/ipfs\r\n> browsers or extensions can learn to use the `ipfs://` URL or `dweb:/ipfs/` URI schemes directly\r\n\r\n*(I will probably use ipfs:// with double slash, just like `https://`, `https://` and `ftp://`)*\r\n\r\nAt this stage I'm unsure if `multihash hash` is compatible with IPFS naming. Maybe. Could be. Unsure. I've spent already **WAY TOO MUCH** time trying to decypher what really is required and what is the minimal viable use case. This can *(and should)* be simplified and wider user adoption is desired.\r\n\r\n----\r\n\r\nCC @clesaege for visibility.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/487369753/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/487592713",
    "html_url": "https://github.com/ethereum/EIPs/issues/1497#issuecomment-487592713",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1497",
    "id": 487592713,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ4NzU5MjcxMw==",
    "user": {
      "login": "satello",
      "id": 6563204,
      "node_id": "MDQ6VXNlcjY1NjMyMDQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6563204?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/satello",
      "html_url": "https://github.com/satello",
      "followers_url": "https://api.github.com/users/satello/followers",
      "following_url": "https://api.github.com/users/satello/following{/other_user}",
      "gists_url": "https://api.github.com/users/satello/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/satello/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/satello/subscriptions",
      "organizations_url": "https://api.github.com/users/satello/orgs",
      "repos_url": "https://api.github.com/users/satello/repos",
      "events_url": "https://api.github.com/users/satello/events{/privacy}",
      "received_events_url": "https://api.github.com/users/satello/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-04-29T14:04:19Z",
    "updated_at": "2019-04-29T14:04:19Z",
    "author_association": "NONE",
    "body": ">Suggestion (assuming we were using IPFS)\r\n>string _metaEvidenceHash\r\n>\r\n>If we were using IFPS, we could simply use the hash, instead of the event id... I'm not that good with Ethereum events and accessing their IDs, I thought I'll mention that.\r\n\r\nWe cannot assume that Evidence will be hosted using IPFS or another storage that produces/verifies data integrity via hashes. The standard needs to encapsulate all use cases.\r\n\r\n>Using _transactionID for both _metaEvidenceID and _evidenceGroupID üßê Maybe _evidenceGroupID should be 0, appeal becomes 1, appeal appeal becomes 2...\r\n\r\n`evidenceGroupID` is used to link pieces of evidence together, and then to link all of the evidence to a dispute. You would still want evidence from previous appeals to be linked to the same dispute.\r\n\r\n> Noticed Dispute already exists. MetaEvidence is nothing else than DisputeInfo - definitely merge into one, simplify.\r\n\r\nWe cannot merge `MetaEvidence` into `Dispute`. `MetaEvidence` is separate and can be (should be in most cases) submitted before a dispute has been raised.\r\n\r\n> browsers or extensions can learn to use the ipfs:// URL or dweb:/ipfs/ URI schemes directly\r\n\r\nThis is for browsers. I chose these formats from here: https://github.com/ipfs/go-ipfs/issues/1678#issuecomment-157478515.\r\n\r\nThis seemed to be the most convincing \"standard\" for IPFS URIs. Note that the issue is still open so this is subject to change. If you want to continue discussing this we can over at https://github.com/kleros/archon/issues",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/487592713/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/487859594",
    "html_url": "https://github.com/ethereum/EIPs/issues/1497#issuecomment-487859594",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1497",
    "id": 487859594,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ4Nzg1OTU5NA==",
    "user": {
      "login": "marsrobertson",
      "id": 44369284,
      "node_id": "MDQ6VXNlcjQ0MzY5Mjg0",
      "avatar_url": "https://avatars.githubusercontent.com/u/44369284?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/marsrobertson",
      "html_url": "https://github.com/marsrobertson",
      "followers_url": "https://api.github.com/users/marsrobertson/followers",
      "following_url": "https://api.github.com/users/marsrobertson/following{/other_user}",
      "gists_url": "https://api.github.com/users/marsrobertson/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/marsrobertson/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/marsrobertson/subscriptions",
      "organizations_url": "https://api.github.com/users/marsrobertson/orgs",
      "repos_url": "https://api.github.com/users/marsrobertson/repos",
      "events_url": "https://api.github.com/users/marsrobertson/events{/privacy}",
      "received_events_url": "https://api.github.com/users/marsrobertson/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-04-30T08:22:12Z",
    "updated_at": "2019-04-30T08:27:19Z",
    "author_association": "NONE",
    "body": "* You created the standard\r\n* You wrote a utility library\r\n* You linked to the existing code samples\r\n\r\nThe library and the code become de facto a reference implementation.\r\n\r\n----------\r\n\r\nIn IPFS filename is the hash\r\n\r\nHere you suggest using multihash.\r\n\r\nPrior to reading, I have never heard of multihash.\r\n\r\nKeccak3 is de facto a hashing standard on Ethereum, whoever is to use the standard, is likely to have `web3` and `Keccak3` already in place: https://ethereum.stackexchange.com/questions/550/which-cryptographic-hash-function-does-ethereum-use\r\n\r\nDo you want the standard to become bigger than just Ethereum or just futureproofing?\r\n\r\nMy main principle remains the same:\r\n\r\n### Simplicity = wider adoption. \r\n\r\nLet's see what other developers working on implementing the standard will tell, what is their feedback.\r\n\r\nFor the time being, I will focus on finishing the hackathon project. \r\n\r\n*(money well spent, incentivizing people to look at the standard)*\r\n\r\n**FYI:** While working on the hackathon and evaluating the standard I‚Äôve created something simple: https://genesis.re/kleros-metaevidence-metahash/ _‚ÄúMaking uploading to IPFS easier since 2019‚Äù_\r\n\r\n\r\n----\r\n\r\n**EDIT:**\r\n\r\nhttp://jonathanpatrick.me/blog/ethereum-compressed-text\r\n\r\n> Log storage is the ideal place to store text in the Ethereum blockchain. Contract state could be used, but it is more expensive and doesn't really offer any advantages. There is no reason why contract logic would need to access a blob of text. Data stored in the log can only be accessed externally, but that is fine for this use-case.\r\n\r\nDo you think it will be possible to have completely on-chain arbitrator? On-chain cannot read `emit Event`. Maybe explain the rationale behind emitting Events, maybe explain the rationale behind the various points of the design.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/487859594/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/487973295",
    "html_url": "https://github.com/ethereum/EIPs/issues/1497#issuecomment-487973295",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1497",
    "id": 487973295,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ4Nzk3MzI5NQ==",
    "user": {
      "login": "satello",
      "id": 6563204,
      "node_id": "MDQ6VXNlcjY1NjMyMDQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6563204?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/satello",
      "html_url": "https://github.com/satello",
      "followers_url": "https://api.github.com/users/satello/followers",
      "following_url": "https://api.github.com/users/satello/following{/other_user}",
      "gists_url": "https://api.github.com/users/satello/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/satello/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/satello/subscriptions",
      "organizations_url": "https://api.github.com/users/satello/orgs",
      "repos_url": "https://api.github.com/users/satello/repos",
      "events_url": "https://api.github.com/users/satello/events{/privacy}",
      "received_events_url": "https://api.github.com/users/satello/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-04-30T14:25:56Z",
    "updated_at": "2019-04-30T14:25:56Z",
    "author_association": "NONE",
    "body": ">Simplicity = wider adoption.\r\n\r\nI understand what you are saying, but for a standard it is more important that it is future proof than being simple/easy to adopt. That being said if there are ways to simplify the standard without compromising functionality than I am all for it. Adoption is important, but it is more important that the standard can work for as many use cases as possible or else it will quickly reach it's limits and won't be a useful standard. You can always use a simplified version of the standard JSON if you do not need all of the different fields.\r\n\r\n>In IPFS filename is the hash\r\n>Here you suggest using multihash.\r\n>Prior to reading, I have never heard of multihash.\r\n>Keccak3 is de facto a hashing standard on Ethereum.\r\n\r\nIPFS uses multihash. Multihash is used because it allows different hash functions to co-exist. Actually Ethereum hashing standards are confusing already. Solidity uses a non-standard implementation of `keccak256` which is not compatible with your out of the box `sha3` (`solidity.keccak256 != web3.keccak256`). Multihash can encompass most of the different hashing functions people may want to use. If you use IPFS you don't need to worry about doing any hashing yourself.\r\n\r\n> Do you think it will be possible to have completely on-chain arbitrator? On-chain cannot read emit Event. Maybe explain the rationale behind emitting Events, maybe explain the rationale behind the various points of the design.\r\n\r\nWhat would be the purpose of an on-chain arbitrator? You always need some end user to give the ruling, regardless of whether they are reading the dispute information from the contract state or the event logs. All of the advantages that are in the passage you quoted are true here and I don't see any advantages to using storage in this use case. The contract itself cannot make a ruling so it has no need to access the Evidence or MetaEvidence.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/487973295/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/488121150",
    "html_url": "https://github.com/ethereum/EIPs/issues/1497#issuecomment-488121150",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1497",
    "id": 488121150,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ4ODEyMTE1MA==",
    "user": {
      "login": "marsrobertson",
      "id": 44369284,
      "node_id": "MDQ6VXNlcjQ0MzY5Mjg0",
      "avatar_url": "https://avatars.githubusercontent.com/u/44369284?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/marsrobertson",
      "html_url": "https://github.com/marsrobertson",
      "followers_url": "https://api.github.com/users/marsrobertson/followers",
      "following_url": "https://api.github.com/users/marsrobertson/following{/other_user}",
      "gists_url": "https://api.github.com/users/marsrobertson/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/marsrobertson/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/marsrobertson/subscriptions",
      "organizations_url": "https://api.github.com/users/marsrobertson/orgs",
      "repos_url": "https://api.github.com/users/marsrobertson/repos",
      "events_url": "https://api.github.com/users/marsrobertson/events{/privacy}",
      "received_events_url": "https://api.github.com/users/marsrobertson/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-04-30T21:25:18Z",
    "updated_at": "2019-04-30T22:31:09Z",
    "author_association": "NONE",
    "body": "About IPFS and multihash: https://github.com/ipfs/specs/tree/master/architecture#21-multihash-and-upgradeable-hashing\r\n\r\n*(didn't know about it)*\r\n\r\nMetaEvidence, MetaHash, it all sounds so meta.\r\n\r\n-----\r\n\r\nI agree that most likely there is no need for on-chain arbitrator. If AI gets sophisticated enough, I'll build their own toolchain to read Events or use the [Archon library](https://archon.readthedocs.io/en/latest/evidence.html#fetch-metaevidence-for-dispute).\r\n\r\n-----\r\n\r\n**EDIT:** Still confused.\r\n\r\n![image](https://user-images.githubusercontent.com/44369284/56997347-66ca0b00-6b9f-11e9-8181-06d48796e6dd.png)\r\n\r\nWe managed to agree that events are accessed off-chain. How on-chain code can know the identifier of the event?\r\n\r\n------\r\n\r\nCopy paste from the previous comments:\r\n\r\n> Hackathon money well spent, incentivizing people to look at the standard.\r\n\r\n> Let's see what other developers working on implementing the standard will tell, what is their feedback.\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/488121150/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/488173506",
    "html_url": "https://github.com/ethereum/EIPs/issues/1497#issuecomment-488173506",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1497",
    "id": 488173506,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ4ODE3MzUwNg==",
    "user": {
      "login": "satello",
      "id": 6563204,
      "node_id": "MDQ6VXNlcjY1NjMyMDQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6563204?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/satello",
      "html_url": "https://github.com/satello",
      "followers_url": "https://api.github.com/users/satello/followers",
      "following_url": "https://api.github.com/users/satello/following{/other_user}",
      "gists_url": "https://api.github.com/users/satello/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/satello/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/satello/subscriptions",
      "organizations_url": "https://api.github.com/users/satello/orgs",
      "repos_url": "https://api.github.com/users/satello/repos",
      "events_url": "https://api.github.com/users/satello/events{/privacy}",
      "received_events_url": "https://api.github.com/users/satello/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-05-01T01:55:09Z",
    "updated_at": "2019-05-01T01:55:09Z",
    "author_association": "NONE",
    "body": "It is referring to `_metaEvidenceID`. You use `_metaEvidenceID` to look up the `MetaEvidence` event log. The contract itself doesn't need to know the `_metaEvidenceID`. I will clear up the wording there.\r\n\r\nAnd yes the more eyes we get on this the better!",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/488173506/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/489397070",
    "html_url": "https://github.com/ethereum/EIPs/issues/1497#issuecomment-489397070",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1497",
    "id": 489397070,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ4OTM5NzA3MA==",
    "user": {
      "login": "marsrobertson",
      "id": 44369284,
      "node_id": "MDQ6VXNlcjQ0MzY5Mjg0",
      "avatar_url": "https://avatars.githubusercontent.com/u/44369284?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/marsrobertson",
      "html_url": "https://github.com/marsrobertson",
      "followers_url": "https://api.github.com/users/marsrobertson/followers",
      "following_url": "https://api.github.com/users/marsrobertson/following{/other_user}",
      "gists_url": "https://api.github.com/users/marsrobertson/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/marsrobertson/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/marsrobertson/subscriptions",
      "organizations_url": "https://api.github.com/users/marsrobertson/orgs",
      "repos_url": "https://api.github.com/users/marsrobertson/repos",
      "events_url": "https://api.github.com/users/marsrobertson/events{/privacy}",
      "received_events_url": "https://api.github.com/users/marsrobertson/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-05-05T06:57:45Z",
    "updated_at": "2019-05-05T06:57:45Z",
    "author_association": "NONE",
    "body": "**RELATED:** Have you heard of https://opentimestamps.org/ https://en.wikipedia.org/wiki/OpenTimestamps ?\r\n\r\nCommitting to a value, ensuring that piece of evidence existing before a certain time.\r\n\r\n---\r\n\r\n**What are your thoughts about going IPFS only?**\r\n\r\nThis ERC1497 is specific to Ethereum (emitting events for example) and I'm leaning towards establishing IPFS as standard.\r\n\r\n_(dropping support for traditional servers)_\r\n\r\nRationale: no need to store hash, as the filename is the hash. Audience technical enough to handle the standard will be able to handle IPFS with breeze.\r\n\r\nShameless plug - https://genesis.re/kleros-metaevidence-metahash/ - making it easier üòá",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/489397070/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/492997771",
    "html_url": "https://github.com/ethereum/EIPs/issues/1497#issuecomment-492997771",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1497",
    "id": 492997771,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ5Mjk5Nzc3MQ==",
    "user": {
      "login": "lidel",
      "id": 157609,
      "node_id": "MDQ6VXNlcjE1NzYwOQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/157609?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/lidel",
      "html_url": "https://github.com/lidel",
      "followers_url": "https://api.github.com/users/lidel/followers",
      "following_url": "https://api.github.com/users/lidel/following{/other_user}",
      "gists_url": "https://api.github.com/users/lidel/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/lidel/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/lidel/subscriptions",
      "organizations_url": "https://api.github.com/users/lidel/orgs",
      "repos_url": "https://api.github.com/users/lidel/repos",
      "events_url": "https://api.github.com/users/lidel/events{/privacy}",
      "received_events_url": "https://api.github.com/users/lidel/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-05-16T09:43:58Z",
    "updated_at": "2019-05-16T09:43:58Z",
    "author_association": "NONE",
    "body": ":car: :dash: _some drive-by comments from IPFS_ :)\r\n\r\n#### On IPFS Addressing\r\n\r\n> This is for browsers. I chose these formats from here: `ipfs/go-ipfs#1678`.\r\n>\r\n> This seemed to be the most convincing \"standard\" for IPFS URIs. Note that the issue is still open so this is subject to change.\r\n\r\nLinked issue is super old (2015), we will close it to decrease noise (sorry!).\r\nSince then, we switched to `ipfs://`, `ipns://` and `dweb:/` to improve URL/URI interop, ease adoption and unblock browser integration. Latest IPFS addressing standards for web browsers can be found at [ipfs/in-web-browsers/ADDRESSING.md](https://github.com/ipfs/in-web-browsers/blob/master/ADDRESSING.md).\r\n\r\nThat being said, in contexts that do not require strict URI/URL interop, things can be simplified:\r\n\r\n- If you want to only support immutable IPFS,  raw `{cid}` should suffice\r\n- If you want to support mutable pointers at some point, then `/ipfs/{cid}` is a better idea, as you can add support for `/ipns/{keyid}` in the future\r\n- If you want to be able to support not only IPFS, but also other namespaces, `dweb:/ipfs/{cid}` URI may be the most future-proof way (`dweb:/somethingelse/{hash}`) \r\n\r\n\r\n#### On CIDs and Multihashes\r\n\r\n> At this stage I'm unsure if `multihash hash` is compatible with IPFS naming. \r\n> About IPFS and multihash [..]\r\n\r\nfyi IPFS wraps raw Multihash in Content IDentifier (CID) these days:\r\nhttps://github.com/multiformats/cid#versions:\r\n```\r\ncidv0 ::= <multihash-content-address>\r\ncidv1 ::= <multibase-prefix><cid-version><multicodec-content-type><multihash-content-address>\r\n```\r\n**tl;dr:**\r\nCIDv0 is implicitly versioned, equal to raw Multihash (in text form always encoded in Base58btc).\r\nCIDv1 is explicitly versioned, text form can be encoded with arbitrary base (multibase prefix is dropped in binary form), and includes multicodec to indicate the type of content refered by multihash.\r\n\r\nIf you want your spec to be better aligned with IPFS concepts, it should be worded around CIDs, not raw Multihashes. Referring to content via raw multihash is fine and will still work, but you may consider some benefits of custom base and knowing content type before it is fetched. \r\n\r\nExample: CIDv1 encoded in Base32  can be used in authority part of URLs:\r\nhttps://bafybeiemxf5abjwjbikoz4mc3a3dla6ual3jsgpdr4cjr3oz3evfyavhwq.ipfs.dweb.link/wiki/\r\n\r\nRefs.\r\n\r\n- Migration to CIDv1 (default base32) https://github.com/ipfs/ipfs/issues/337\r\n  - Converting CIDv0 to CIDv1 https://github.com/ipfs/ipfs/issues/337#issuecomment-435356238\r\n  - Switching CIDv1 to Base32 https://github.com/ipfs/ipfs/issues/337#issuecomment-491254639",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/492997771/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/493597273",
    "html_url": "https://github.com/ethereum/EIPs/issues/1497#issuecomment-493597273",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1497",
    "id": 493597273,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ5MzU5NzI3Mw==",
    "user": {
      "login": "satello",
      "id": 6563204,
      "node_id": "MDQ6VXNlcjY1NjMyMDQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6563204?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/satello",
      "html_url": "https://github.com/satello",
      "followers_url": "https://api.github.com/users/satello/followers",
      "following_url": "https://api.github.com/users/satello/following{/other_user}",
      "gists_url": "https://api.github.com/users/satello/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/satello/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/satello/subscriptions",
      "organizations_url": "https://api.github.com/users/satello/orgs",
      "repos_url": "https://api.github.com/users/satello/repos",
      "events_url": "https://api.github.com/users/satello/events{/privacy}",
      "received_events_url": "https://api.github.com/users/satello/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-05-17T20:57:41Z",
    "updated_at": "2019-05-17T20:57:41Z",
    "author_association": "NONE",
    "body": "Hi @lidel. Thanks for the clarifications and suggestions. For the purposes of this standard it is not necessary to spell out the accepted `URI` formats in the standard itself, as these may change over time and different interfaces will have different requirements, but this is great discussion for people trying to implement an interface that will support `IPFS`.\r\n\r\nCIDs are an interesting idea. We could then remove `fileTypeExtension` from the respective JSON schemas and not have to worry about missing `content-types`. My biggest concern is that it creates a much higher threshold for implementation. As @marsrobertson pointed out in earlier comments, just doing a standalone `multihash` was a little bit burdensome. Requiring all hashes to be wrapped in a `CID` adds another level of complexity. ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/493597273/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/493801119",
    "html_url": "https://github.com/ethereum/EIPs/issues/1497#issuecomment-493801119",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1497",
    "id": 493801119,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ5MzgwMTExOQ==",
    "user": {
      "login": "lidel",
      "id": 157609,
      "node_id": "MDQ6VXNlcjE1NzYwOQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/157609?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/lidel",
      "html_url": "https://github.com/lidel",
      "followers_url": "https://api.github.com/users/lidel/followers",
      "following_url": "https://api.github.com/users/lidel/following{/other_user}",
      "gists_url": "https://api.github.com/users/lidel/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/lidel/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/lidel/subscriptions",
      "organizations_url": "https://api.github.com/users/lidel/orgs",
      "repos_url": "https://api.github.com/users/lidel/repos",
      "events_url": "https://api.github.com/users/lidel/events{/privacy}",
      "received_events_url": "https://api.github.com/users/lidel/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-05-19T23:26:26Z",
    "updated_at": "2019-05-19T23:29:42Z",
    "author_association": "NONE",
    "body": "Cool, just wanted to put the concept of a CID on the radar in case its useful for this or future standards.\r\n\r\nGoing with raw multihash should be fine if you don't care about CID, or as long you also store DAG type or all data is in the same DAG format. For example, CIDv1 of IPFS files can be derived  from multihash alone, if needed.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/493801119/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/769305451",
    "html_url": "https://github.com/ethereum/EIPs/issues/1497#issuecomment-769305451",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1497",
    "id": 769305451,
    "node_id": "MDEyOklzc3VlQ29tbWVudDc2OTMwNTQ1MQ==",
    "user": {
      "login": "n1c01a5",
      "id": 1773356,
      "node_id": "MDQ6VXNlcjE3NzMzNTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1773356?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/n1c01a5",
      "html_url": "https://github.com/n1c01a5",
      "followers_url": "https://api.github.com/users/n1c01a5/followers",
      "following_url": "https://api.github.com/users/n1c01a5/following{/other_user}",
      "gists_url": "https://api.github.com/users/n1c01a5/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/n1c01a5/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/n1c01a5/subscriptions",
      "organizations_url": "https://api.github.com/users/n1c01a5/orgs",
      "repos_url": "https://api.github.com/users/n1c01a5/repos",
      "events_url": "https://api.github.com/users/n1c01a5/events{/privacy}",
      "received_events_url": "https://api.github.com/users/n1c01a5/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-01-28T19:03:58Z",
    "updated_at": "2021-01-28T19:03:58Z",
    "author_association": "NONE",
    "body": "There are 2 typos in the metaEvidence json:\r\n1. L4 `‚ÄúfileTypeExtension\": string,` => `\"fileTypeExtension\": string,`\r\n2. L21 `\"dynamicScriptHash: string` => `\"dynamicScriptHash\": string`",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/769305451/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/924384244",
    "html_url": "https://github.com/ethereum/EIPs/issues/1497#issuecomment-924384244",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1497",
    "id": 924384244,
    "node_id": "IC_kwDOAq426M43GPv0",
    "user": {
      "login": "hbarcelos",
      "id": 16565602,
      "node_id": "MDQ6VXNlcjE2NTY1NjAy",
      "avatar_url": "https://avatars.githubusercontent.com/u/16565602?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/hbarcelos",
      "html_url": "https://github.com/hbarcelos",
      "followers_url": "https://api.github.com/users/hbarcelos/followers",
      "following_url": "https://api.github.com/users/hbarcelos/following{/other_user}",
      "gists_url": "https://api.github.com/users/hbarcelos/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/hbarcelos/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/hbarcelos/subscriptions",
      "organizations_url": "https://api.github.com/users/hbarcelos/orgs",
      "repos_url": "https://api.github.com/users/hbarcelos/repos",
      "events_url": "https://api.github.com/users/hbarcelos/events{/privacy}",
      "received_events_url": "https://api.github.com/users/hbarcelos/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-09-21T21:07:10Z",
    "updated_at": "2021-10-04T12:07:36Z",
    "author_association": "NONE",
    "body": "# Follow-on Proposal\r\n\r\nWe are making some additions to this proposal in a backwards-compatible fashion.\r\n\r\n# Motivation\r\n\r\nAlmost 3 years have passed since this proposal was created and we learned a lot about what it takes to build applications on both the Arbitrator and the Arbitrable side. As it currently is, the standard leaves a lot of unanswered questions that could lead to issues down the road.\r\n\r\nTo alleviate this problem, we are adding some fields and recommended ways of solving common problems when building arbitrable and arbitrator applications.\r\n\r\n# Specification\r\n\r\n## MetaEvidence\r\n\r\nExample:\r\n\r\n```json\r\n{\r\n  \"type\": \"single-select\",\r\n  \"titles\": [\"Yes\", \"No\"],\r\n  \"descriptions\": [\r\n    \"The website is compliant. This will release the funds to Alice.\",\r\n    \"The website is not compliant. This will refund Bob.\"\r\n  ],\r\n  \"arbitratorChainID\": 1,\r\n  \"arbitrableChainID\": 100,\r\n  \"arbitrableInterfaceURI\": \"https://my-awesomme.dapp.io/item/1234\",\r\n  \"dynamicScriptRequiredParams\": [\r\n    \"arbitrableChainID\",\r\n    \"arbitrableJsonRpcUrl\"\r\n    \"arbitrableContractAddress\",\r\n  ],\r\n  \"evidenceDisplayInterfaceRequiredParams\": [\r\n    \"disputeID\",\r\n    \"arbitrableContractAddress\",\r\n    \"arbitratorContractAddress\",\r\n    \"arbitratorChainID\",\r\n    \"arbitratorJsonRpcUrl\"\r\n  ],\r\n  \"_v\": \"1.0.0\"\r\n}\r\n\r\n```\r\n\r\n### _v\r\n\r\n`MetaEvidence` JSON files **SHOULD** have a special field explicitly indicating their version:\r\n\r\n```typescript\r\n{\r\n  // ...\r\n  \"_v\": string,\r\n}\r\n```\r\n\r\nIdentifies which version of the standard the files refer to. This enables interfaces and consumers to support multiple versions at the same time.\r\n\r\nThe changes made in this follow-on document constitute the `1.0.0` version. Any additional changes made **SHOULD** be versioned following [SemVer](https://semver.org/).\r\n\r\nWhenever `_v` field is missing, it **SHOULD** be considered a document of the first iteration, conversely `_v: \"0\"` (without the SemVer notation).\r\n\r\n### arbitrableChainID\r\n\r\n```typescript\r\n{\r\n  // ...\r\n  \"arbitrableChainID\": number,\r\n}\r\n```\r\n\r\nThe ID of the chain (as defined by [EIP-155](https://eips.ethereum.org/EIPS/eip-155#list-of-chain-ids)) in which the arbitrable application is running.\r\n\r\nIf omitted, the Arbitrable side **SHOULD** implicitly be considered to be on the same chain as the Arbitrator.\r\n\r\n### arbitratorChainID\r\n\r\n```typescript\r\n{\r\n  // ...\r\n  \"arbitratorChainID\": number,\r\n}\r\n```\r\n\r\nThe ID of the chain (as defined by [EIP-155](https://eips.ethereum.org/EIPS/eip-155#list-of-chain-ids)) in which the arbitrator for the arbitrable application is running.\r\n\r\nWhen present, the Arbitrator interface **MUST** validate whether it is currently connected to the same chain ID or not. If there is a mismatch, the interface **SHOULD** consider the `MetaEvidence` invalid.\r\n\r\nIf omitted, the Arbitrable side can implicitly be connected to arbitrators on any chain.\r\n\r\n### arbitrableInterfaceURI\r\n\r\n```typescript\r\n{\r\n  // ...\r\n  \"arbitrableInterfaceURI\": string,\r\n}\r\n```\r\n\r\nAn URI pointing directly to the arbitrable item on the arbitrable application to make it easier for jurors to view the full context of what originated the dispute.\r\n\r\n### dynamicScriptRequiredParams\r\n\r\n```typescript\r\n{\r\n  // ...\r\n  \"dynamicScriptRequiredParams\": string[],\r\n}\r\n```\r\nThe name of the parameters that are required to be injected into the script defined in `dynamicScriptURI` for it to work properly. It **MUST** be a subset of the names of the **Injected Parameters** described later in this proposal.\r\n\r\nWhen provided, only the required parameters **SHOULD** be injected. If omitted, all parameters **MUST** be injected.\r\n\r\n### evidenceDisplayInterfaceRequiredParams\r\n\r\n```typescript\r\n{\r\n  // ...\r\n  \"evidenceDisplayInterfaceRequiredParams\": string[],\r\n}\r\n```\r\nThe name of the parameters that are required to be injected into the interface defined in `evidenceDisplayInterfaceURI` for it to work properly. It **MUST** be a subset of the names of the **Injected Parameters** described later in this proposal.\r\n\r\nWhen provided, only the required parameters **SHOULD** be injected. If omitted, all parameters **MUST** be injected.\r\n\r\n## Injected Parameters\r\n\r\nThe script defined by `dynamicScriptURI` and the interface defined by `evidenceDisplayInterfaceURI` **MAY** both require parameters to work properly. The code consuming them **MUST** inject at least the following parameters by default:\r\n\r\n- `disputeID: string`: the ID of the dispute in the arbitrator contract;\r\n- `arbitratorContractAddress: string`: the address of the arbitrator contract;\r\n- `arbitratorChainID: number`: the ID of the chain (as defined by [EIP-155](https://eips.ethereum.org/EIPS/eip-155#list-of-chain-ids)) in which the arbitrator application is running;\r\n- `arbitratorJsonRpcUrl: string`: the URL of JSON RPC endpoint connecting to a node on the network. It **MUST** be pointing to a node from the same chain identified by `arbitratorChainID`.\r\n- `arbitrableContractAddress: string`: the address of the arbitrable contract;\r\n- `arbitrableChainID: number`: the ID of the chain (as defined by [EIP-155](https://eips.ethereum.org/EIPS/eip-155#list-of-chain-ids)) in which the arbitrable application is running. If not provided by the Meta Evidence file, it **SHOULD** have the same value as `arbitratorChainID`.\r\n- `arbitrableJsonRpcUrl: string`: the URL of JSON RPC endpoint connecting to a node on the network. It **MUST** be pointing to a node from the same chain identified by `arbitrableChainID`.\r\n\r\n### Injecting parameters into dynamic scripts\r\n\r\nFrom the original spec:\r\n\r\n> **NOTE:** Arbitrator interfaces should take security precautions when running an external script. A script should never be run directly inline as this would give the script full access to the DOM and make calls on behalf of the arbitrator. Instead the script should be run in a sandbox such as an iframe so that the scope is limited.\r\n\r\nArbitrator interfaces **MUST** include a read-only global variable named `scriptParameters` into the sandbox scope, which is an object containing the parameters listed above:\r\n\r\n```\r\nscriptParameters = {\r\n  disputeID,\r\n  arbitratorContractAddress,\r\n  arbitratorChainID,\r\n  arbitratorJsonRpcUrl,\r\n  arbitrableContractAddress,\r\n  arbitrableChainID,\r\n  arbitratrableJsonRpcUrl,\r\n};\r\n```\r\n\r\n### Injecting parameters into evidence display interfaces\r\n\r\nFrom the original spec:\r\n\r\n> **NOTE:** Arbitrator interfaces should take security precautions when injecting the evidence display interface code into their page. The iframe used to render the external interface should be secured properly with a sandbox or other means of disabling functionality that could pose a security risk to the interface or users. For example, an interface should disallow the injected web3 object from MetaMask or a different browser wallet from requesting signatures from the user. This can be accomplished by using a sandbox to disallow the external interface from retaining its origin (and therefore using the browser‚Äôs built in security features to block API requests), or by removing methods such as sign and personalSign from the injected web3 object.\r\n\r\nModern browsers already take care of most of the aspects pointed above. For example, a script from a page within an `<iframe>` is blocked from accessing the parent window global scope, which means trying to access `window.ethereum` from the Evidence Display Interface will not work.\r\n\r\nThe Arbitrator interface **SHOULD** inject the parameters into the Evidence Display Interface using standardized methods available. The most straightforward way of doing this is by appending a search part to `evidenceDisplayInterfaceURI` with all parameters properly encoded as URI components.\r\n\r\nSupposing the `evidenceDisplayURI` value is `https://my-awesome.display.app`, when generating the `src` attribute of the `<iframe>` tag, it should become something like:\r\n\r\n```\r\nhttps://my-awesome.display.app/?\r\n  arbitratorContractAddress=0x0000000000000000000000000000000000000000&\r\n  disputeID=1&\r\n  arbitratorChainID=1&\r\n  arbitratorJsonRpcUrl=https%3A%2F%2Fmy-awesome.node.io&\r\n  arbitrableContractAddress=0xC000000000000000000000000000000000000000&\r\n  arbitratrableChainID=1&\r\n  arbitratrableJsonRpcUrl=https%3A%2F%2Fmy-awesome.node.io&\r\n```\r\n\r\nTo avoid issues with the encoding of the parameters, the Arbitrator interface **SHOULD** use proper APIs to generate the search part of the URL, such as [`URLSearchParams`](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams) or [`encodeURIComponent`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent).\r\n\r\n## Common Pitfalls\r\n\r\n### Hard-coded JSON RPC endpoints\r\n\r\nDynamic Scripts and Evidence Display Interfaces are meant to be immutable. If they include hard-coded parameters, such as the chain ID or the JSON RPC endpoint URL, it means that those cannot be patched in the future.\r\n\r\nOne clear example on how this falls short is when using RPC endpoints from Infura. They include an Infura project ID in them in order to identify the account responsible for it. Having an Infura endpoint is hard-coded into a dynamic script or an evidence display interface brings the following problems:\r\n1. The project ID is made public, since these components have to be publicly available.\r\n2. There is a hard limit in the amount of projects one can create on Infura. If there is ever a need for new projects, the only alternative is to remove old ones, which would break any dynamic script or evidence display interface depending on it.\r\n\r\nProblem 2. above has further consequences:\r\n1. The Arbitrator application being permanently unable to display the right Evidence Display Interface or fetching the appropriate data with the Dynamic Script, which could lead to jurors refusing to rule on an otherwise valid case.\r\n2. For older cases, there would be a loss of historical data.\r\n\r\nFor that reason, neither dynamic script nor evidence display interfaces should rely on hard-coded parameters in order to connect to the blockchain.\r\n\r\n### Cross-chain/cross-rollup `MetaEvidence`\r\n\r\nWhen defining `MetaEvidence` that will be on a chain that is different than the one where the Arbitrator is, the `arbitrableChainID` parameter **MUST** be hard-coded into it.\r\n\r\nWhen injecting the parameters into dynamic scripts and evidence display interfaces, the Arbitrator interface **SHOULD** inject the proper JSON RPC endpoint for the respective `aribtrableChainID`.\r\n\r\nThe Arbitrator interface **MUST** be able to provide a valid JSON RPC endpoint for all chains it supports.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/924384244/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/930324434",
    "html_url": "https://github.com/ethereum/EIPs/issues/1497#issuecomment-930324434",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1497",
    "id": 930324434,
    "node_id": "IC_kwDOAq426M43c5_S",
    "user": {
      "login": "0xferit",
      "id": 3106907,
      "node_id": "MDQ6VXNlcjMxMDY5MDc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3106907?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/0xferit",
      "html_url": "https://github.com/0xferit",
      "followers_url": "https://api.github.com/users/0xferit/followers",
      "following_url": "https://api.github.com/users/0xferit/following{/other_user}",
      "gists_url": "https://api.github.com/users/0xferit/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/0xferit/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/0xferit/subscriptions",
      "organizations_url": "https://api.github.com/users/0xferit/orgs",
      "repos_url": "https://api.github.com/users/0xferit/repos",
      "events_url": "https://api.github.com/users/0xferit/events{/privacy}",
      "received_events_url": "https://api.github.com/users/0xferit/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-09-29T16:13:00Z",
    "updated_at": "2021-09-29T16:40:21Z",
    "author_association": "NONE",
    "body": "### DateTime Ruling Option Type\r\nIntroducing a new type `datetime` for `rulingOptions.type`. Rulings will be signaled as UNIX timestamps.\r\n\r\nExample: \r\n\r\nRuling code 1632930595 translates to Wed Sep 29 2021 15:49:55 GMT+0000.\r\nRuling code 1 translates to Thu Jan 01 1970 00:00:01 GMT+0000.\r\n\r\n\r\n### Reserved Rulings\r\n\r\nTo let arbitrable applications create reserved ruling options, we are introducing a new field `rulingOptions.reserved`.  Values inside this object will be treated specially, the way it is defined in metaevidence.\r\n\r\nExample:\r\n```\r\n 'rulingOptions': {\r\n    ...\r\n    'reserved': {\r\n        '0x0': 'Invalid / Refuse to Arbitrate',\r\n        '0x123454321': 'My Special Ruling Option'\r\n    }\r\n  }\r\n```\r\n\r\nNote that ruling code zero was always reserved for 'Invalid / Refuse to Arbitrate' implicitly, and it will stay that way. For sake of being explicit, you can include it inside metaevidence. User interfaces will ignore definitions for '0x0' anyway.\r\n\r\nReserved ruling options take precedence of regular ruling options. So for example, in a `multiple-select` dispute, if you define a ruling for code `0x4`, using `titles`, and then you also define a reserved ruling on the same code, it will be overridden.\r\n\r\n\r\nExample:\r\n```\r\n 'rulingOptions': {\r\n    'type': 'multiple-select',\r\n    'titles': ['Yes', 'No', 'Maybe', 'Perhaps'],\r\n    'reserved': {\r\n        '0x0': 'Invalid / Refuse to Arbitrate',\r\n        '0x4': 'My Special Ruling Option'\r\n    }\r\n  }\r\n```\r\n\r\n'My Special Ruling Option' will override 'Perhaps' in the above configuration.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/930324434/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/1086636680",
    "html_url": "https://github.com/ethereum/EIPs/issues/1497#issuecomment-1086636680",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1497",
    "id": 1086636680,
    "node_id": "IC_kwDOAq426M5AxMKI",
    "user": {
      "login": "github-actions[bot]",
      "id": 41898282,
      "node_id": "MDM6Qm90NDE4OTgyODI=",
      "avatar_url": "https://avatars.githubusercontent.com/in/15368?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/github-actions%5Bbot%5D",
      "html_url": "https://github.com/apps/github-actions",
      "followers_url": "https://api.github.com/users/github-actions%5Bbot%5D/followers",
      "following_url": "https://api.github.com/users/github-actions%5Bbot%5D/following{/other_user}",
      "gists_url": "https://api.github.com/users/github-actions%5Bbot%5D/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/github-actions%5Bbot%5D/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/github-actions%5Bbot%5D/subscriptions",
      "organizations_url": "https://api.github.com/users/github-actions%5Bbot%5D/orgs",
      "repos_url": "https://api.github.com/users/github-actions%5Bbot%5D/repos",
      "events_url": "https://api.github.com/users/github-actions%5Bbot%5D/events{/privacy}",
      "received_events_url": "https://api.github.com/users/github-actions%5Bbot%5D/received_events",
      "type": "Bot",
      "site_admin": false
    },
    "created_at": "2022-04-02T13:06:20Z",
    "updated_at": "2022-04-02T13:06:20Z",
    "author_association": "NONE",
    "body": "There has been no activity on this issue for two months. It will be closed in a week if no further activity occurs. If you would like to move this EIP forward, please respond to any outstanding feedback or add a comment indicating that you have addressed all required feedback and are ready for a review.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/1086636680/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/1100659328",
    "html_url": "https://github.com/ethereum/EIPs/issues/1497#issuecomment-1100659328",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1497",
    "id": 1100659328,
    "node_id": "IC_kwDOAq426M5BmrqA",
    "user": {
      "login": "github-actions[bot]",
      "id": 41898282,
      "node_id": "MDM6Qm90NDE4OTgyODI=",
      "avatar_url": "https://avatars.githubusercontent.com/in/15368?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/github-actions%5Bbot%5D",
      "html_url": "https://github.com/apps/github-actions",
      "followers_url": "https://api.github.com/users/github-actions%5Bbot%5D/followers",
      "following_url": "https://api.github.com/users/github-actions%5Bbot%5D/following{/other_user}",
      "gists_url": "https://api.github.com/users/github-actions%5Bbot%5D/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/github-actions%5Bbot%5D/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/github-actions%5Bbot%5D/subscriptions",
      "organizations_url": "https://api.github.com/users/github-actions%5Bbot%5D/orgs",
      "repos_url": "https://api.github.com/users/github-actions%5Bbot%5D/repos",
      "events_url": "https://api.github.com/users/github-actions%5Bbot%5D/events{/privacy}",
      "received_events_url": "https://api.github.com/users/github-actions%5Bbot%5D/received_events",
      "type": "Bot",
      "site_admin": false
    },
    "created_at": "2022-04-16T13:07:14Z",
    "updated_at": "2022-04-16T13:07:14Z",
    "author_association": "NONE",
    "body": "This issue was closed due to inactivity. If you are still pursuing it, feel free to reopen it and respond to any feedback or request a review in a comment.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/1100659328/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/1210784519",
    "html_url": "https://github.com/ethereum/EIPs/issues/1497#issuecomment-1210784519",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1497",
    "id": 1210784519,
    "node_id": "IC_kwDOAq426M5IKxsH",
    "user": {
      "login": "Ramarti",
      "id": 2632384,
      "node_id": "MDQ6VXNlcjI2MzIzODQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2632384?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Ramarti",
      "html_url": "https://github.com/Ramarti",
      "followers_url": "https://api.github.com/users/Ramarti/followers",
      "following_url": "https://api.github.com/users/Ramarti/following{/other_user}",
      "gists_url": "https://api.github.com/users/Ramarti/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Ramarti/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Ramarti/subscriptions",
      "organizations_url": "https://api.github.com/users/Ramarti/orgs",
      "repos_url": "https://api.github.com/users/Ramarti/repos",
      "events_url": "https://api.github.com/users/Ramarti/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Ramarti/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-08-10T14:49:32Z",
    "updated_at": "2022-08-10T14:49:32Z",
    "author_association": "NONE",
    "body": "\r\n> For that reason, neither dynamic script nor evidence display interfaces should rely on hard-coded parameters in order to connect to the blockchain.\r\n\r\nWhy add that parameter then? Shouldn't be the display interface's responsibility to connect to a JSON-RPC endpoint? It knows the chainId.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/1210784519/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
