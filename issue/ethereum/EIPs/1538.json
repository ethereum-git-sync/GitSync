{
  "url": "https://api.github.com/repos/ethereum/EIPs/issues/1538",
  "repository_url": "https://api.github.com/repos/ethereum/EIPs",
  "labels_url": "https://api.github.com/repos/ethereum/EIPs/issues/1538/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/EIPs/issues/1538/comments",
  "events_url": "https://api.github.com/repos/ethereum/EIPs/issues/1538/events",
  "html_url": "https://github.com/ethereum/EIPs/issues/1538",
  "id": 375653151,
  "node_id": "MDU6SXNzdWUzNzU2NTMxNTE=",
  "number": 1538,
  "title": "ERC1538: Transparent Contract Standard",
  "user": {
    "login": "mudgen",
    "id": 49092,
    "node_id": "MDQ6VXNlcjQ5MDky",
    "avatar_url": "https://avatars.githubusercontent.com/u/49092?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/mudgen",
    "html_url": "https://github.com/mudgen",
    "followers_url": "https://api.github.com/users/mudgen/followers",
    "following_url": "https://api.github.com/users/mudgen/following{/other_user}",
    "gists_url": "https://api.github.com/users/mudgen/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/mudgen/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/mudgen/subscriptions",
    "organizations_url": "https://api.github.com/users/mudgen/orgs",
    "repos_url": "https://api.github.com/users/mudgen/repos",
    "events_url": "https://api.github.com/users/mudgen/events{/privacy}",
    "received_events_url": "https://api.github.com/users/mudgen/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 2328627851,
      "node_id": "MDU6TGFiZWwyMzI4NjI3ODUx",
      "url": "https://api.github.com/repos/ethereum/EIPs/labels/stale",
      "name": "stale",
      "color": "000000",
      "default": false,
      "description": ""
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 78,
  "created_at": "2018-10-30T19:20:51Z",
  "updated_at": "2022-03-04T11:58:58Z",
  "closed_at": "2021-12-08T10:12:14Z",
  "author_association": "CONTRIBUTOR",
  "active_lock_reason": null,
  "body": "---\r\neip: 1538\r\ntitle: Transparent Contract Standard\r\nauthor: Nick Mudge <nick@perfectabstractions.com>\r\nstatus: Draft\r\ntype: Standards Track\r\ncategory: ERC\r\ncreated: 31 October 2018\r\n---\r\n**None:** An EIP has been written for this standard and is here: https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1538.md\r\n\r\n## Simple Summary\r\n<!--\"If you can't explain it simply, you don't understand it well enough.\" Provide a simplified and layman-accessible explanation of the EIP.-->\r\nThis standard provides a contract architecture that makes upgradeable contracts flexible, unlimited in size, and transparent. \r\n\r\nA transparent contract publicly documents the full history of all changes made to it.\r\n\r\nAll changes to a transparent contract are reported in a standard format.\r\n\r\n## Abstract\r\n<!--A short (~200 word) description of the technical issue being addressed.-->\r\nA transparent contract is a proxy contract design pattern that provides the following:\r\n\r\n1. A way to add, replace and remove multiple functions of a contract atomically (at the same time).\r\n1. Standard events to show what functions are added, replaced and removed from a contract, and why the changes are made.\r\n2. A standard way to query a contract to discover and retrieve information about all functions exposed by it.\r\n3. Solves the 24KB maximum contract size limitation, making the maximum contract size of a transparent contract practically unlimited. This standard makes the worry about contract size a thing of the past.\r\n4. Enables an upgradeable contract to become immutable in the future if desired.\r\n\r\n## Motivation\r\n<!--The motivation is critical for EIPs that want to change the Ethereum protocol. It should clearly explain why the existing protocol specification is inadequate to address the problem that the EIP solves. EIP submissions without sufficient motivation may be rejected outright.-->\r\nA fundamental benefit of Ethereum contracts is that their code is immutable, thereby acquiring trust by trustlessness. People do not have to trust others if it is not possible for a contract to be changed.\r\n\r\nHowever, a fundamental problem with trustless contracts that cannot be changed is that they cannot be changed. \r\n\r\n#### Bugs\r\n\r\nBugs and security vulnerabilities are unwittingly written into immutable contracts that ruin them.\r\n\r\n#### Improvements\r\n\r\nImmutable, trustless contracts cannot be improved, resulting in increasingly inferior contracts over time.\r\n\r\nContract standards evolve, new ones come out. People, groups and organizations learn over time what people want and what is better and what should be built next. Contracts that cannot be improved not only hold back the authors that create them, but everybody who uses them.\r\n\r\n#### Upgradeable Contracts vs. Centralized Private Database\r\nWhy have an upgradeable contract instead of a centralized, private, mutable database?\r\nHere are some reasons:\r\n1. Because of the openness of storage data and verified code, it is possible to show a provable history of trustworthiness.\r\n2. Because of the openness, bad behavior can be spotted and reported when it happens.\r\n3. Independent security and domain experts can review the change history of contracts and vouch for their history of trustworthiness.\r\n4. It is possible for an upgradeable contract to become immutable and trustless.\r\n5. An upgradeable contract can have parts of it that are not upgradeable and so are partially immutable and trustless.\r\n\r\n#### Immutability\r\n\r\nIn some cases immutable, trustless contracts are the right fit. This is the case when a contract is only needed for a short time or it is known ahead of time that there will never be any reason to change or improve it.\r\n\r\n### Middle Ground\r\n\r\nTransparent contracts provide a middle ground between immutable trustless contracts that can't be improved and upgradeable contracts that can't be trusted.\r\n\r\n### Purposes\r\n\r\n1. Create upgradeable contracts that earn trust by showing a provable history of trustworthiness. \r\n2. Document the development of contracts so their development and change is provably public and can be understood.\r\n3. Create upgradeable contracts that can become immutable in the future if desired.\r\n4. Create contracts that are not limited by a max size.\r\n\r\n### Benefits & Use Cases\r\nThis standard is for use cases that benefit from the following:\r\n1. The ability to add, replace or remove multiple functions of a contract atomically (at the same time).\r\n2. Each time a function is added, replaced or removed, it is documented with events.\r\n3. Build trust over time by showing all changes made to a contract.\r\n4. Unlimited contract size.\r\n5. The ability to query information about functions currently supported by the contract.\r\n6. One contract address that provides all needed functionality and never needs to be replaced by another contract address.\r\n7. The ability for a contract to be upgradeable for a time, and then become immutable.\r\n8. Add trustless guarantees to a contract with \"unchangeable functions\". \r\n\r\n### New Software Possibilities\r\n\r\nThis standard enables a form of contract version control software to be written.\r\n\r\nSoftware and user interfaces can be written to filter the `FunctionUpdate` and `CommitMessage` events of a contract address. Such software can show the full history of changes of any contract that implements this standard. \r\n\r\nUser interfaces and software can also use this standard to assist or automate changes of contracts.\r\n\r\n## Specification\r\n<!--The technical specification should describe the syntax and semantics of any new feature. The specification should be detailed enough to allow competing, interoperable implementations for any of the current Ethereum platforms (go-ethereum, parity, cpp-ethereum, ethereumj, ethereumjs, and [others](https://github.com/ethereum/wiki/wiki/Clients)).-->\r\n\r\n> **Note:**\r\nThe solidity `delegatecall` opcode enables a contract to execute a function from another contract, but it is executed as if the function was from the calling contract. Essentially `delegatecall` enables a contract to \"borrow\" another contract's function. Functions executed with `delegatecall` affect the storage variables of the calling contract, not the contract where the functions are defined.\r\n\r\n### General Summary\r\n\r\nA transparent contract delegates or forwards function calls to it to other contracts using `delegatecode`. \r\n\r\nA transparent contract has an `updateContract` function that enables multiple functions to be added, replaced or removed.\r\n\r\nAn event is emitted for every function that is added, replaced or removed so that all changes to a contract can be tracked in a standard way.\r\n\r\nA transparent contract is a contract that implements and complies with the design points below.\r\n\r\n### Terms\r\n\r\n1. In this standard a **delegate contract** is a contract that a transparent contract fallback function forwards function calls to using `delegatecall`.\r\n2. In this standard an **unchangeable function** is a function that is defined directly in a transparent contract and so cannot be replaced or removed.\r\n\r\n### Design Points\r\n\r\nA contract is a transparent contract if it implements the following design points:\r\n\r\n1. A transparent contract is a contract that contains a fallback function, a constructor, and zero or more unchangeable functions that are defined directly within it.\r\n2. The constructor of a transparent contract associates the `updateContract` function with a contract that implements the ERC1538 interface. The `updateContract` function can be an \"unchangeable function\" that is defined directly in the transparent contract or it can be defined in a delegate contract. Other functions can also be associated with contracts in the constructor.\r\n3. After a transparent contract is deployed functions are added, replaced and removed by calling the `updateContract` function.\r\n4. The `updateContract` function associates functions with contracts that implement those functions, and emits the `CommitMessage` and `FunctionUpdate` events that document function changes.\r\n5. The `FunctionUpdate` event is emitted for each function that is added, replaced or removed. The `CommitMessage` event is emitted one time for each time the `updateContract` function is called and is emitted after any `FunctionUpdate` events are emitted.\r\n6. The `updateContract` function can take a list of multiple function signatures in its `_functionSignatures` parameter and so add/replace/remove multiple functions at the same time.\r\n7. When a function is called on a transparent contract it executes immediately if it is an \"unchangeable function\". Otherwise the fallback function is executed. The fallback function finds the delegate contract associated with the function and executes the function using `delegatecall`. If there is no delegate contract for the function then execution reverts.\r\n8. The source code of a transparent contract and all delegate contracts used by it are publicly viewable and verified.\r\n\r\nThe transparent contract address is the address that users interact with. The transparent contract address never changes. Only delegate addresses can change by using the `updateContracts` function.\r\n\r\nTypically some kind of authentication is needed for adding/replacing/removing functions from a transparent contract, **however the scheme for authentication or ownership is not part of this standard**.\r\n\r\n### Example\r\n\r\nHere is an example of an implementation of a transparent contract. Please note that the example below is an **example only.  It is not the standard**. A contract is a transparent contract when it implements and complies with the design points listed above.\r\n\r\n```solidity\r\npragma solidity ^0.5.7;\r\n\r\ncontract ExampleTransparentContract {\r\n  // owner of the contract\r\n  address internal contractOwner;\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n  // maps functions to the delegate contracts that execute the functions\r\n  // funcId => delegate contract\r\n  mapping(bytes4 => address) internal delegates;\r\n\r\n  // maps each function signature to its position in the funcSignatures array.\r\n  // signature => index+1\r\n  mapping(bytes => uint256) internal funcSignatureToIndex;\r\n    \r\n  event CommitMessage(string message);\r\n  event FunctionUpdate(bytes4 indexed functionId, address indexed oldDelegate, address indexed newDelegate, string functionSignature);\r\n  \r\n  // this is an example of an \"unchangeable function\".\r\n  // return the delegate contract address for the supplied function signature\r\n  function delegateAddress(string calldata _functionSignature) external view returns(address) {\r\n    require(funcSignatureToIndex[bytes(_functionSignature)] != 0, \"Function signature not found.\");\r\n    return delegates[bytes4(keccak256(bytes(_functionSignature)))];\r\n  }\r\n  \r\n  // add a function using the updateContract function\r\n  // this is an internal helper function\r\n  function addFunction(address _erc1538Delegate, address contractAddress, string memory _functionSignatures, string memory _commitMessage) internal {    \r\n    // 0x03A9BCCF == bytes4(keccak256(\"updateContract(address,string,string)\"))\r\n    bytes memory funcdata = abi.encodeWithSelector(0x03A9BCCF, contractAddress, _functionSignatures, _commitMessage);\r\n    bool success;\r\n    assembly {\r\n      success := delegatecall(gas, _erc1538Delegate, add(funcdata, 0x20), mload(funcdata), funcdata, 0)\r\n    }\r\n    require(success, \"Adding a function failed\");   \r\n  }\r\n\r\n  constructor(address _erc1538Delegate) public {\r\n    contractOwner = msg.sender;\r\n    emit OwnershipTransferred(address(0), msg.sender);\r\n\r\n    // adding ERC1538 updateContract function\r\n    bytes memory signature = \"updateContract(address,string,string)\";\r\n    bytes4 funcId = bytes4(keccak256(signature));\r\n    delegates[funcId] = _erc1538Delegate;\r\n    emit FunctionUpdate(funcId, address(0), _erc1538Delegate, string(signature));\r\n    emit CommitMessage(\"Added ERC1538 updateContract function at contract creation\");\r\n\t\r\n    // associate \"unchangeable functions\" with this transparent contract address\r\n    // prevents function selector clashes with delegate contract functions\r\n    // uses the updateContract function\r\n    string memory functions = \"delegateAddress(string)\";\r\n    addFunction(_erc1538Delegate, address(this), functions, \"Associating unchangeable functions\");\r\n\t\r\n    // adding ERC1538Query interface functions\r\n    functions = \"functionByIndex(uint256)functionExists(string)delegateAddresses()delegateFunctionSignatures(address)functionById(bytes4)functionBySignature(string)functionSignatures()totalFunctions()\";    \r\n    // \"0x01234567891011121314\" is an example address of an ERC1538Query delegate contract\r\n    addFunction(_erc1538Delegate, 0x01234567891011121314, functions, \"Adding ERC1538Query functions\");\r\n    \r\n    // additional functions could be added at this point\r\n  }\r\n\r\n  // Making the fallback function payable makes it work for delegate contract functions \r\n  // that are payable and not payable.\r\n  function() external payable {\r\n    // Delegate every function call to a delegate contract\r\n    address delegate = delegates[msg.sig];\r\n    require(delegate != address(0), \"Function does not exist.\");\r\n    assembly {\r\n      let ptr := mload(0x40)\r\n      calldatacopy(ptr, 0, calldatasize)\r\n      let result := delegatecall(gas, delegate, ptr, calldatasize, 0, 0)\r\n      let size := returndatasize\r\n      returndatacopy(ptr, 0, size)\r\n      switch result\r\n      case 0 {revert(ptr, size)}\r\n      default {return (ptr, size)}\r\n    }\r\n  }\r\n}\r\n```\r\nAs can be seen in the above example, every function call is delegated to a delegate contract, unless the function is defined directly in the transparent contract (making it an unchangeable function).\r\n\r\nThe constructor function adds the `updateContract` function to the transparent contract, which is then used to add other functions to the transparent contract.\r\n\r\nEach time a function is added to a transparent contract the events `CommitMessage` and `FunctionUpdate` are emitted to document exactly what functions where added or replaced and why.\r\n\r\nThe delegate contract that implements the `updateContract` function implements the following interface: \r\n### ERC1538 Interface\r\n\r\n```solidity\r\npragma solidity ^0.5.7;\r\n\r\n/// @title ERC1538 Transparent Contract Standard\r\n/// @dev Required interface\r\n///  Note: the ERC-165 identifier for this interface is 0x61455567\r\ninterface ERC1538 {\r\n  /// @dev This emits when one or a set of functions are updated in a transparent contract.\r\n  ///  The message string should give a short description of the change and why\r\n  ///  the change was made.\r\n  event CommitMessage(string message);\r\n  \r\n  /// @dev This emits for each function that is updated in a transparent contract.\r\n  ///  functionId is the bytes4 of the keccak256 of the function signature.\r\n  ///  oldDelegate is the delegate contract address of the old delegate contract if\r\n  ///  the function is being replaced or removed.\r\n  ///  oldDelegate is the zero value address(0) if a function is being added for the\r\n  ///  first time.\r\n  ///  newDelegate is the delegate contract address of the new delegate contract if \r\n  ///  the function is being added for the first time or if the function is being \r\n  ///  replaced.\r\n  ///  newDelegate is the zero value address(0) if the function is being removed.\r\n  event FunctionUpdate(\r\n    bytes4 indexed functionId, \r\n    address indexed oldDelegate, \r\n    address indexed newDelegate, \r\n    string functionSignature\r\n  );\r\n\r\n  /// @notice Updates functions in a transparent contract.\r\n  /// @dev If the value of _delegate is zero then the functions specified \r\n  ///  in _functionSignatures are removed.\r\n  ///  If the value of _delegate is a delegate contract address then the functions \r\n  ///  specified in _functionSignatures will be delegated to that address.\r\n  /// @param _delegate The address of a delegate contract to delegate to or zero\r\n  ///        to remove functions.      \r\n  /// @param _functionSignatures A list of function signatures listed one after the other\r\n  /// @param _commitMessage A short description of the change and why it is made\r\n  ///        This message is passed to the CommitMessage event.          \r\n  function updateContract(address _delegate, string calldata _functionSignatures, string calldata _commitMessage) external;  \r\n}\r\n```\r\n### Function Signatures String Format\r\n\r\nThe text format for the `_functionSignatures` parameter is simply a string of function signatures. For example: `\"myFirstFunction()mySecondFunction(string)\"` This format is easy to parse and is concise.\r\n\r\nHere is an example of calling the `updateContract` function that adds the ERC721 standard functions to a transparent contract:\r\n```javascript\r\nfunctionSignatures = \"approve(address,uint256)balanceOf(address)getApproved(uint256)isApprovedForAll(address,address)ownerOf(uint256)safeTransferFrom(address,address,uint256)safeTransferFrom(address,address,uint256,bytes)setApprovalForAll(address,bool)transferFrom(address,address,uint256)\"\r\ntx = await transparentContract.updateContract(erc721Delegate.address, functionSignatures, \"Adding ERC721 functions\");\r\n```\r\n\r\n### Removing Functions\r\n\r\nFunctions are removed by passing `address(0)` as the first argument to the `updateContract` function. The list of functions that are passed in are removed.\r\n\r\n### Source Code Verification\r\n\r\nThe transparent contract source code and the source code for the delegate contracts should be verified in a provable way by a third party source such as etherscan.io.\r\n<!--\r\nA transparent contract must implement the [ERC-165 Standard Interface Detection standard](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md) via a delegate contract by adding the `supportsInterface` function using the `updateContract` function. The interfaceID for the ERC1538 standard is `0x61455567`.\r\n-->\r\n\r\n### Function Selector Clash\r\nA function selector clash occurs when a function is added to a contract that hashes to the same four-byte hash as an existing function. This is unlikely to occur but should be prevented in the implementation of the `updateContract` function. See the [reference implementation of ERC1538](https://github.com/mudgen/transparent-contracts-erc1538) to see an example of how function clashes can be prevented.\r\n\r\n### ERC1538Query\r\n\r\nOptionally, the function signatures of a transparent contract can be stored in an array in the transparent contract and queried to get what functions the transparent contract supports and what their delegate contract addresses are.\r\n\r\nThe following is an optional interface for querying function information from a transparent contract:\r\n\r\n```solidity\r\npragma solidity ^0.5.7;\r\n\r\ninterface ERC1538Query {\r\n    \r\n  /// @notice Gets the total number of functions the transparent contract has.\r\n  /// @return The number of functions the transparent contract has,\r\n  ///  not including the fallback function.\r\n  function totalFunctions() external view returns(uint256);\r\n\t\r\n  /// @notice Gets information about a specific function\r\n  /// @dev Throws if `_index` >= `totalFunctions()`\r\n  /// @param _index The index position of a function signature that is stored in an array\r\n  /// @return The function signature, the function selector and the delegate contract address\r\n  function functionByIndex(uint256 _index) \r\n    external \r\n    view \r\n    returns(\r\n      string memory functionSignature, \r\n      bytes4 functionId, \r\n      address delegate\r\n    );\r\n\t\r\n  /// @notice Checks to see if a function exists\r\n  /// @param The function signature to check\r\n  /// @return True if the function exists, false otherwise\r\n  function functionExists(string calldata _functionSignature) external view returns(bool);\r\n\t\r\n  /// @notice Gets all the function signatures of functions supported by the transparent contract\r\n  /// @return A string containing a list of function signatures\r\n  function functionSignatures() external view returns(string memory);\r\n\t\r\n  /// @notice Gets all the function signatures supported by a specific delegate contract\r\n  /// @param _delegate The delegate contract address\r\n  /// @return A string containing a list of function signatures\r\n  function delegateFunctionSignatures(address _delegate) external view returns(string memory);\r\n\t\r\n  /// @notice Gets the delegate contract address that supports the given function signature\r\n  /// @param The function signature\r\n  /// @return The delegate contract address\r\n  function delegateAddress(string calldata _functionSignature) external view returns(address);\r\n\t\r\n  /// @notice Gets information about a function\r\n  /// @dev Throws if no function is found\r\n  /// @param _functionId The id of the function to get information about\r\n  /// @return The function signature and the contract address\r\n  function functionById(bytes4 _functionId) \r\n    external \r\n    view \r\n    returns(\r\n      string memory signature, \r\n      address delegate\r\n    );\r\n\t\r\n  /// @notice Get all the delegate contract addresses used by the transparent contract\r\n  /// @return An array of all delegate contract addresses\r\n  function delegateAddresses() external view returns(address[] memory);\r\n}\r\n```\r\n\r\nSee the [reference implementation of ERC1538](https://github.com/mudgen/transparent-contracts-erc1538) to see how this is implemented.\r\n\r\nThe text format for the list of function signatures returned from the `delegateFunctionSignatures` and `functionSignatures` functions is simply a string of function signatures. Here is an example of such a string: `\"approve(address,uint256)balanceOf(address)getApproved(uint256)isApprovedForAll(address,address)ownerOf(uint256)safeTransferFrom(address,address,uint256)safeTransferFrom(address,address,uint256,bytes)setApprovalForAll(address,bool)transferFrom(address,address,uint256)\"`\r\n\r\n### How To Deploy A Transparent Contract\r\n1. Create and deploy to a blockchain a contract that implements the ERC1538 interface. You can skip this step if there is already such a contract deployed to the blockchain.\r\n2. Create your transparent contract with a fallback function as given above. Your transparent contract also needs a constructor that adds the `updateContract` function.\r\n3. Deploy your transparent contract to a blockchain. Pass in the address of the ERC1538 delegate contract to your constructor if it requires it.\r\n\r\nSee the [reference implementation](https://github.com/mudgen/transparent-contracts-erc1538) for examples of these contracts.\r\n\r\n### Wrapper Contract for Delegate Contracts that Depend on Other Delegate Contracts\r\nIn some cases some delegate contracts may need to call external/public functions that reside in other delegate contracts. A convenient way to solve this problem is to create a contract that contains empty implementations of functions that are needed and import and extend this contract in delegate contracts that call functions from other delegate contracts. This enables delegate contracts to compile without having to provide implementations of the functions that are already given in other delegate contracts. This is a way to save gas, prevent reaching the max contract size limit, and prevent duplication of code. This strategy was given by @amiromayer. [See his comment for more information.](https://github.com/ethereum/EIPs/issues/1538#issuecomment-451985155) Another way to solve this problem is to use assembly to call functions provided by other delegate contracts.\r\n\r\n### Decentralized Authority\r\nIt is possible to extend this standard to add consensus functionality such as an approval function that multiple different people call to approve changes before they are submitted with the `updateContract` function. Changes only go into effect when the changes are fully approved. The `CommitMessage` and ` FunctionUpdate` events should only be emitted when changes go into effect.\r\n\r\n## Security\r\n> This standard refers to **owner(s)** as one or more individuals that have the power to add/replace/remove functions of an upgradeable contract.\r\n\r\n### General\r\n\r\nThe owners(s) of an upgradeable contract have the ability to alter, add or remove data from the contract's data storage. Owner(s) of a contract can also execute any arbitrary code in the contract on behalf of any address. Owners(s) can do these things by adding a function to the contract that they call to execute arbitrary code. This is an issue for upgradeable contracts in general and is not specific to transparent contracts.\r\n\r\n>**Note:** The design and implementation of contract ownership is **not** part of this standard. The examples given in this standard and in the reference implementation are just **examples** of how it could be done.\r\n\r\n### Unchangeable Functions\r\n\r\n\"Unchangeable functions\" are functions defined in a transparent contract itself and not in a delegate contract. The owner(s) of a transparent contract are not able to replace these functions. The use of unchangeable functions is limited because in some cases they can still be manipulated if they read or write data to the storage of the transparent contract. Data read from the transparent contract's storage could have been altered by the owner(s) of the contract. Data written to the transparent contract's storage can be undone or altered by the owner(s) of the contract.\r\n\r\nIn some cases unchangeble functions add trustless guarantees to a transparent contract.\r\n\r\n### Transparency\r\n\r\nContracts that implement this standard emit an event every time a function is added, replaced or removed. This enables people and software to monitor the changes to a contract. If any bad acting function is added to a contract then it can be seen. To comply with this standard all source code of a transparent contract and delegate contracts must be publicly available and verified. \r\n\r\nSecurity and domain experts can review the history of change of any transparent contract to detect any history of foul play.\r\n\r\n## Rationale\r\n<!--The rationale fleshes out the specification by describing what motivated the design and why particular design decisions were made. It should describe alternate designs that were considered and related work, e.g. how the feature is supported in other languages. The rationale may also provide evidence of consensus within the community, and should discuss important objections or concerns raised during discussion.-->\r\n\r\n### String of Function Signatures Instead of bytes4[] Array of Function Selectors\r\n\r\nThe `updateContract` function takes a `string` list of functions signatures as an argument instead of a `bytes4[]` array of function selectors for three reasons:\r\n\r\n1. Passing in function signatures enables the implementation of `updateContract` to prevent selector clashes. \r\n2. A major part of this standard is to make upgradeable contracts more transparent by making it easier to see what has changed over time and why. When a function is added, replaced or removed its function signature is included in the FunctionUpdate event that is emitted. This makes it relatively easy to write software that filters the events of a contract to display to people what functions have been added/removed and changed over time without needing access to the source code or ABI of the contract. If only four-byte function selectors were provided this would not be possible.\r\n3. By looking at the source code of a transparent contract it is not possible to see all the functions that it supports. This is why the ERC1538Query interface exists, so that people and software have a way to look up and examine or show all functions currently supported by a transparent contract. Function signatures are used so that ERC1538Query functions can show them.\r\n\r\n### Gas Considerations\r\n\r\nDelegating function calls does have some gas overhead. This is mitigated in two ways: \r\n1. Delegate contracts can be small, reducing gas costs. Because it costs more gas to call a function in a contract with many functions than a contract with few functions.\r\n2. Because transparent contracts do not have a max size limitation it is possible to add gas optimizing functions for use cases. For example someone could use a transparent contract to implement the ERC721 standard and implement batch transfer functions from the [ERC1412 standard](https://github.com/ethereum/EIPs/issues/1412) to help reduce gas (and make batch transfers more convenient).\r\n\r\n### Storage\r\n\r\nThe standard does not specify how data is stored or organized by a transparent contract. But here are some suggestions:\r\n\r\n**Inherited Storage**\r\n\r\n1. The storage variables of a transparent contract consist of the storage variables defined in the transparent contract source code and the source code of delegate contracts that have been added.\r\n\r\n2. A delegate contract can use any storage variable that exists in a transparent contract as long as it defines within it all the storage variables that exist, in the order that they exist, up to and including the ones being used.\r\n\r\n3. A delegate contract can create new storage variables as long as it has defined, in the same order, all storage variables that exist in the transparent contract.\r\n\r\nHere is a simple way inherited storage could be implemented:\r\n\r\n1. Create a storage contract that contains the storage variables that your transparent contract and delegate contracts will use.\r\n2. Make your delegate contracts inherit the storage contract.\r\n3. If you want to add a new delegate contract that adds new storage variables then create a new storage contract that adds the new storage variables and inherits from the old storage contract. Use your new storage contract with your new delegate contract.\r\n4. Repeat steps 2 or 3 for every new delegate contract.\r\n\r\n\r\n**Unstructured Storage**\r\n\r\nAssembly is used to store and read data at specific storage locations. An advantage to this approach is that previously used storage locations don't have to be defined or mentioned in a delegate contract if they aren't used by it.\r\n\r\n**Eternal Storage**\r\n\r\nData can be stored using a generic API based on the type of data. [See ERC930 for more information.](https://github.com/ethereum/EIPs/issues/930)\r\n\r\n### Becoming Immutable\r\nIt is possible to make a transparent contract become immutable. This is done by calling the `updateContract` function to remove the `updateContract` function. With this gone it is no longer possible to add, replace and remove functions.\r\n\r\n### Versions of Functions\r\n\r\nSoftware or a user can verify what version of a function is called by getting the delegate contract address of the function. This can be done by calling the `delegateAddress` function from the ERC1538Query interface if it is implemented. This function takes a function signature as an argument and returns the delegate contract address where it is implemented.\r\n\r\n### Best Practices, Tools and More Information\r\n\r\n> More information, tools, tutorials and best practices concerning transparent contracts need to be developed and published. \r\n\r\nBelow is a growing list of articles concerning transparent contracts and their use.  If you have an article about transparent contracts you would like to share then please submit a comment to this issue about it to get it added.\r\n\r\n[ERC1538: Future Proofing Smart Contracts and Tokens](https://coinjournal.net/erc1538-future-proofing-smart-contacts-and-tokens/)\r\n\r\n[The ERC1538 improving towards the “transparent contract” standard](https://www.crypto-economy.net/en/ethereum-eth-erc1538-transparent-contract-standard/)\r\n\r\n### Inspiration\r\n\r\nThis standard was inspired by ZeppelinOS's implementation of [Upgradeability with vtables](https://github.com/zeppelinos/labs/tree/master/upgradeability_with_vtable). \r\n\r\nThis standard was also inspired by the design and implementation of the [Mokens contract](https://etherscan.io/address/0xc1eab49cf9d2e23e43bcf23b36b2be14fc2f8838#code) from the [Mokens project](https://github.com/Mokens/MIPs/blob/master/MIPS/mip-2-Goals-and-Objectives.md). The Mokens contract has been [upgraded to implement this standard](https://etherscan.io/address/0x0ac5637fe62ec14fd9e237a81a9679d4adef701f#code).\r\n\r\n\r\n## Backwards Compatibility\r\n<!--All EIPs that introduce backwards incompatibilities must include a section describing these incompatibilities and their severity. The EIP must explain how the author proposes to deal with these incompatibilities. EIP submissions without a sufficient backwards compatibility treatise may be rejected outright.-->\r\nThis standard makes a contract compatible with future standards and functionality because new functions can be added and existing functions can be replaced or removed.\r\n\r\nThis standard future proofs a contract.\r\n\r\n## Implementation\r\n<!--The implementations must be completed before any EIP is given status \"Final\", but it need not be completed before the EIP is accepted. While there is merit to the approach of reaching consensus on the specification and rationale before writing code, the principle of \"rough consensus and running code\" is still useful when it comes to resolving many discussions of API details.-->\r\nA reference implementation of this standard is given in the [transparent-contracts-erc1538](https://github.com/mudgen/transparent-contracts-erc1538) repository.\r\n\r\n\r\n## Copyright\r\nCopyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).\r\n",
  "closed_by": {
    "login": "github-actions[bot]",
    "id": 41898282,
    "node_id": "MDM6Qm90NDE4OTgyODI=",
    "avatar_url": "https://avatars.githubusercontent.com/in/15368?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/github-actions%5Bbot%5D",
    "html_url": "https://github.com/apps/github-actions",
    "followers_url": "https://api.github.com/users/github-actions%5Bbot%5D/followers",
    "following_url": "https://api.github.com/users/github-actions%5Bbot%5D/following{/other_user}",
    "gists_url": "https://api.github.com/users/github-actions%5Bbot%5D/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/github-actions%5Bbot%5D/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/github-actions%5Bbot%5D/subscriptions",
    "organizations_url": "https://api.github.com/users/github-actions%5Bbot%5D/orgs",
    "repos_url": "https://api.github.com/users/github-actions%5Bbot%5D/repos",
    "events_url": "https://api.github.com/users/github-actions%5Bbot%5D/events{/privacy}",
    "received_events_url": "https://api.github.com/users/github-actions%5Bbot%5D/received_events",
    "type": "Bot",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/1538/reactions",
    "total_count": 19,
    "+1": 14,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 5,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/EIPs/issues/1538/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/434885584",
    "html_url": "https://github.com/ethereum/EIPs/issues/1538#issuecomment-434885584",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1538",
    "id": 434885584,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzNDg4NTU4NA==",
    "user": {
      "login": "mattlockyer",
      "id": 321340,
      "node_id": "MDQ6VXNlcjMyMTM0MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/321340?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mattlockyer",
      "html_url": "https://github.com/mattlockyer",
      "followers_url": "https://api.github.com/users/mattlockyer/followers",
      "following_url": "https://api.github.com/users/mattlockyer/following{/other_user}",
      "gists_url": "https://api.github.com/users/mattlockyer/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mattlockyer/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mattlockyer/subscriptions",
      "organizations_url": "https://api.github.com/users/mattlockyer/orgs",
      "repos_url": "https://api.github.com/users/mattlockyer/repos",
      "events_url": "https://api.github.com/users/mattlockyer/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mattlockyer/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-10-31T23:49:09Z",
    "updated_at": "2018-10-31T23:49:09Z",
    "author_association": "NONE",
    "body": "First Questions:\r\n1) what else is out there?\r\n2) how come the only delegate is payable? What about non-payable? or did I miss something?\r\n3) any security issues?\r\n4) how come you don't inherit Ownable.sol, is this because the owner of root will never change?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/434885584/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/434891482",
    "html_url": "https://github.com/ethereum/EIPs/issues/1538#issuecomment-434891482",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1538",
    "id": 434891482,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzNDg5MTQ4Mg==",
    "user": {
      "login": "mudgen",
      "id": 49092,
      "node_id": "MDQ6VXNlcjQ5MDky",
      "avatar_url": "https://avatars.githubusercontent.com/u/49092?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mudgen",
      "html_url": "https://github.com/mudgen",
      "followers_url": "https://api.github.com/users/mudgen/followers",
      "following_url": "https://api.github.com/users/mudgen/following{/other_user}",
      "gists_url": "https://api.github.com/users/mudgen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mudgen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mudgen/subscriptions",
      "organizations_url": "https://api.github.com/users/mudgen/orgs",
      "repos_url": "https://api.github.com/users/mudgen/repos",
      "events_url": "https://api.github.com/users/mudgen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mudgen/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-11-01T00:25:59Z",
    "updated_at": "2018-11-14T21:04:07Z",
    "author_association": "CONTRIBUTOR",
    "body": "Great questions.  I'll answer the last three questions first:\r\n\r\n> First Questions:\r\n> \r\n> 1. what else is out there?\r\n> 2. how come the only delegate is payable? What about non-payable? or did I miss something?\r\n> 3. any security issues?\r\n> 4. how come you don't inherit Ownable.sol, is this because the owner of root will never change?\r\n\r\n2. The fallback function delegates every function call to a delegate contract. The fallback function is payable because some of the functions in a delegate contract may be payable. Making the fallback function payable makes it work for delegate contract functions that are payable and not payable.\r\n\r\n3. See the newly added Security section in the standard.\r\n\r\n4. A transparent contract could inherit Ownable.sol if someone wants the `owner()` function to be unchangeable. The above implementation is just an example of implementing ERC1538.\r\n\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/434891482/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/435210911",
    "html_url": "https://github.com/ethereum/EIPs/issues/1538#issuecomment-435210911",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1538",
    "id": 435210911,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzNTIxMDkxMQ==",
    "user": {
      "login": "mudgen",
      "id": 49092,
      "node_id": "MDQ6VXNlcjQ5MDky",
      "avatar_url": "https://avatars.githubusercontent.com/u/49092?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mudgen",
      "html_url": "https://github.com/mudgen",
      "followers_url": "https://api.github.com/users/mudgen/followers",
      "following_url": "https://api.github.com/users/mudgen/following{/other_user}",
      "gists_url": "https://api.github.com/users/mudgen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mudgen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mudgen/subscriptions",
      "organizations_url": "https://api.github.com/users/mudgen/orgs",
      "repos_url": "https://api.github.com/users/mudgen/repos",
      "events_url": "https://api.github.com/users/mudgen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mudgen/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-11-01T22:39:00Z",
    "updated_at": "2018-11-01T22:42:15Z",
    "author_association": "CONTRIBUTOR",
    "body": "> First Questions:\r\n> \r\n> 1. what else is out there?\r\n\r\nThere are various ideas about different designs and implementations of upgradeable contracts. These are found on the web. \r\n\r\nI didn't find any that provide the same list of benefits that this standard provides. The closest I found was [zepplin's vtable implementation](https://github.com/zeppelinos/labs/tree/master/upgradeability_with_vtable).  ERC1538 was inspired by the vtable implementation, specifically from the idea of managing an upgradeable contract by function, instead of by contract address.\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/435210911/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/435519386",
    "html_url": "https://github.com/ethereum/EIPs/issues/1538#issuecomment-435519386",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1538",
    "id": 435519386,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzNTUxOTM4Ng==",
    "user": {
      "login": "AC0DEM0NK3Y",
      "id": 36201133,
      "node_id": "MDQ6VXNlcjM2MjAxMTMz",
      "avatar_url": "https://avatars.githubusercontent.com/u/36201133?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/AC0DEM0NK3Y",
      "html_url": "https://github.com/AC0DEM0NK3Y",
      "followers_url": "https://api.github.com/users/AC0DEM0NK3Y/followers",
      "following_url": "https://api.github.com/users/AC0DEM0NK3Y/following{/other_user}",
      "gists_url": "https://api.github.com/users/AC0DEM0NK3Y/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/AC0DEM0NK3Y/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/AC0DEM0NK3Y/subscriptions",
      "organizations_url": "https://api.github.com/users/AC0DEM0NK3Y/orgs",
      "repos_url": "https://api.github.com/users/AC0DEM0NK3Y/repos",
      "events_url": "https://api.github.com/users/AC0DEM0NK3Y/events{/privacy}",
      "received_events_url": "https://api.github.com/users/AC0DEM0NK3Y/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-11-02T21:49:11Z",
    "updated_at": "2018-11-02T21:55:16Z",
    "author_association": "CONTRIBUTOR",
    "body": "Looks pretty good on the face of it. I'll have to go deeper and think any caveats when I get a little more time to jump in but yeah, nice format to allow flexibility while making things have some standard visibility on change history/reason.\r\n\r\nI think there could be some improvements or cuts to ERC1538Query perhaps, quick example being in what format should functionSignatures() return, comma/semi-colon delimited for eg. but that is minor detail.\r\n\r\n\r\nQuestion on this: \"Delegate contracts can be small, reducing gas costs. Because it costs more gas to call a function in a contract with many functions than a contract with few functions.\"\r\n\r\nDo you have numbers or have links to numbers?\r\n\r\n\r\nedit: One thing you should perhaps think about adding/talking about is this is not something that should be done by default, and if it is used then people should be ideally putting in capability to pull authority out on being able to change the functions and where they delegate to.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/435519386/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/435525098",
    "html_url": "https://github.com/ethereum/EIPs/issues/1538#issuecomment-435525098",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1538",
    "id": 435525098,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzNTUyNTA5OA==",
    "user": {
      "login": "mudgen",
      "id": 49092,
      "node_id": "MDQ6VXNlcjQ5MDky",
      "avatar_url": "https://avatars.githubusercontent.com/u/49092?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mudgen",
      "html_url": "https://github.com/mudgen",
      "followers_url": "https://api.github.com/users/mudgen/followers",
      "following_url": "https://api.github.com/users/mudgen/following{/other_user}",
      "gists_url": "https://api.github.com/users/mudgen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mudgen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mudgen/subscriptions",
      "organizations_url": "https://api.github.com/users/mudgen/orgs",
      "repos_url": "https://api.github.com/users/mudgen/repos",
      "events_url": "https://api.github.com/users/mudgen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mudgen/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-11-02T22:15:46Z",
    "updated_at": "2018-11-07T22:08:38Z",
    "author_association": "CONTRIBUTOR",
    "body": "@AC0DEM0NK3Y thanks for the great feedback!\r\n\r\nWhen a function is called on a contract there is a linear search to find the function in the contract. So every function costs a different amount of gas to be called. I did a simple test with a simple function. I made a contract with one function. The gas cost to execute it was 384. I made a second contract with the same exact function 26 times but with slightly different function names.  The most expensive function to call was 934.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/435525098/reactions",
      "total_count": 5,
      "+1": 5,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/435527547",
    "html_url": "https://github.com/ethereum/EIPs/issues/1538#issuecomment-435527547",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1538",
    "id": 435527547,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzNTUyNzU0Nw==",
    "user": {
      "login": "mudgen",
      "id": 49092,
      "node_id": "MDQ6VXNlcjQ5MDky",
      "avatar_url": "https://avatars.githubusercontent.com/u/49092?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mudgen",
      "html_url": "https://github.com/mudgen",
      "followers_url": "https://api.github.com/users/mudgen/followers",
      "following_url": "https://api.github.com/users/mudgen/following{/other_user}",
      "gists_url": "https://api.github.com/users/mudgen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mudgen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mudgen/subscriptions",
      "organizations_url": "https://api.github.com/users/mudgen/orgs",
      "repos_url": "https://api.github.com/users/mudgen/repos",
      "events_url": "https://api.github.com/users/mudgen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mudgen/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-11-02T22:28:02Z",
    "updated_at": "2018-11-02T22:31:48Z",
    "author_association": "CONTRIBUTOR",
    "body": "@AC0DEM0NK3Y Yes, people can call the `updateContract` function to remove the `updateContract` function.  That would remove the ability to change the contract, making it immutable. I added that in.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/435527547/reactions",
      "total_count": 5,
      "+1": 5,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/435541616",
    "html_url": "https://github.com/ethereum/EIPs/issues/1538#issuecomment-435541616",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1538",
    "id": 435541616,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzNTU0MTYxNg==",
    "user": {
      "login": "mudgen",
      "id": 49092,
      "node_id": "MDQ6VXNlcjQ5MDky",
      "avatar_url": "https://avatars.githubusercontent.com/u/49092?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mudgen",
      "html_url": "https://github.com/mudgen",
      "followers_url": "https://api.github.com/users/mudgen/followers",
      "following_url": "https://api.github.com/users/mudgen/following{/other_user}",
      "gists_url": "https://api.github.com/users/mudgen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mudgen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mudgen/subscriptions",
      "organizations_url": "https://api.github.com/users/mudgen/orgs",
      "repos_url": "https://api.github.com/users/mudgen/repos",
      "events_url": "https://api.github.com/users/mudgen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mudgen/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-11-02T23:56:02Z",
    "updated_at": "2018-11-04T14:39:40Z",
    "author_association": "CONTRIBUTOR",
    "body": "From solidity documentation:\r\n\r\n>The low-level call, delegatecall and callcode will return success if the called account is non-existent, as part of the design of EVM. Existence must be checked prior to calling if desired.\r\n\r\nThis is not a security vulnerability in a transparent contract because the code above does check that a contract address exists before making a delegate call.  It is possible for a user to submit an invalid address to the `updateContract` function, but that function could also check for the existence of code for the submitted address, and throw if the address is not a contract address.\r\n\r\n\r\n\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/435541616/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/435713060",
    "html_url": "https://github.com/ethereum/EIPs/issues/1538#issuecomment-435713060",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1538",
    "id": 435713060,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzNTcxMzA2MA==",
    "user": {
      "login": "mwherman2000",
      "id": 6101736,
      "node_id": "MDQ6VXNlcjYxMDE3MzY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6101736?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mwherman2000",
      "html_url": "https://github.com/mwherman2000",
      "followers_url": "https://api.github.com/users/mwherman2000/followers",
      "following_url": "https://api.github.com/users/mwherman2000/following{/other_user}",
      "gists_url": "https://api.github.com/users/mwherman2000/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mwherman2000/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mwherman2000/subscriptions",
      "organizations_url": "https://api.github.com/users/mwherman2000/orgs",
      "repos_url": "https://api.github.com/users/mwherman2000/repos",
      "events_url": "https://api.github.com/users/mwherman2000/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mwherman2000/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-11-04T22:14:04Z",
    "updated_at": "2018-11-04T22:14:04Z",
    "author_association": "NONE",
    "body": "Why not simply create a generic worklow engine SC that understands BPMN workflow templates that have been transcompiled into a BPMN specific byecode?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/435713060/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/435933915",
    "html_url": "https://github.com/ethereum/EIPs/issues/1538#issuecomment-435933915",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1538",
    "id": 435933915,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzNTkzMzkxNQ==",
    "user": {
      "login": "mudgen",
      "id": 49092,
      "node_id": "MDQ6VXNlcjQ5MDky",
      "avatar_url": "https://avatars.githubusercontent.com/u/49092?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mudgen",
      "html_url": "https://github.com/mudgen",
      "followers_url": "https://api.github.com/users/mudgen/followers",
      "following_url": "https://api.github.com/users/mudgen/following{/other_user}",
      "gists_url": "https://api.github.com/users/mudgen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mudgen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mudgen/subscriptions",
      "organizations_url": "https://api.github.com/users/mudgen/orgs",
      "repos_url": "https://api.github.com/users/mudgen/repos",
      "events_url": "https://api.github.com/users/mudgen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mudgen/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-11-05T16:14:12Z",
    "updated_at": "2018-11-05T18:52:05Z",
    "author_association": "CONTRIBUTOR",
    "body": "@mwherman2000 Sorry, I am not familiar with how that works so I can't answer that question.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/435933915/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/436186512",
    "html_url": "https://github.com/ethereum/EIPs/issues/1538#issuecomment-436186512",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1538",
    "id": 436186512,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzNjE4NjUxMg==",
    "user": {
      "login": "theblockstalk",
      "id": 25777536,
      "node_id": "MDQ6VXNlcjI1Nzc3NTM2",
      "avatar_url": "https://avatars.githubusercontent.com/u/25777536?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theblockstalk",
      "html_url": "https://github.com/theblockstalk",
      "followers_url": "https://api.github.com/users/theblockstalk/followers",
      "following_url": "https://api.github.com/users/theblockstalk/following{/other_user}",
      "gists_url": "https://api.github.com/users/theblockstalk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theblockstalk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theblockstalk/subscriptions",
      "organizations_url": "https://api.github.com/users/theblockstalk/orgs",
      "repos_url": "https://api.github.com/users/theblockstalk/repos",
      "events_url": "https://api.github.com/users/theblockstalk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theblockstalk/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-11-06T09:28:19Z",
    "updated_at": "2018-11-06T09:28:19Z",
    "author_association": "NONE",
    "body": "I would suggest that you get the Aaragon and zepplinOS team involved in this EIP, they are leading upgradeable contract researchers.\r\n\r\nThere are in fact multiple ways to implement upgradeable contracts using delegate call and the would not all be compatible.\r\n- Some include a method for initialization which is not considered in this EIP.\r\n- Some of them implement an owner contract in different ways\r\n- Some of them delegate calls to one contract, instead of different contracts for each function\r\n\r\nI would closely check that this is in line with the zepplinOS unstructured storage pattern, as I think this will be the most widely adopted.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/436186512/reactions",
      "total_count": 3,
      "+1": 3,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/436210099",
    "html_url": "https://github.com/ethereum/EIPs/issues/1538#issuecomment-436210099",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1538",
    "id": 436210099,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzNjIxMDA5OQ==",
    "user": {
      "login": "satyamakgec",
      "id": 14581509,
      "node_id": "MDQ6VXNlcjE0NTgxNTA5",
      "avatar_url": "https://avatars.githubusercontent.com/u/14581509?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/satyamakgec",
      "html_url": "https://github.com/satyamakgec",
      "followers_url": "https://api.github.com/users/satyamakgec/followers",
      "following_url": "https://api.github.com/users/satyamakgec/following{/other_user}",
      "gists_url": "https://api.github.com/users/satyamakgec/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/satyamakgec/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/satyamakgec/subscriptions",
      "organizations_url": "https://api.github.com/users/satyamakgec/orgs",
      "repos_url": "https://api.github.com/users/satyamakgec/repos",
      "events_url": "https://api.github.com/users/satyamakgec/events{/privacy}",
      "received_events_url": "https://api.github.com/users/satyamakgec/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-11-06T10:46:10Z",
    "updated_at": "2018-11-06T10:46:10Z",
    "author_association": "NONE",
    "body": "@mudgen It is a very nice approach to make the size of the contract unlimited. My worry point is how you can make communication between two different implementation contracts. AFAICT It only works when we have independent functions that don't depend on the other functions or internal functions.\r\n\r\nEx - some X function is used to change the state that used by other functions and it is implemented in the **contract1** and then some Y function is implemented in the **contract2** and want to use the X function the how do contract1 and contract2 function will communicate (communication between two implementation contract).",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/436210099/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/436261462",
    "html_url": "https://github.com/ethereum/EIPs/issues/1538#issuecomment-436261462",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1538",
    "id": 436261462,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzNjI2MTQ2Mg==",
    "user": {
      "login": "James-Sangalli",
      "id": 16630514,
      "node_id": "MDQ6VXNlcjE2NjMwNTE0",
      "avatar_url": "https://avatars.githubusercontent.com/u/16630514?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/James-Sangalli",
      "html_url": "https://github.com/James-Sangalli",
      "followers_url": "https://api.github.com/users/James-Sangalli/followers",
      "following_url": "https://api.github.com/users/James-Sangalli/following{/other_user}",
      "gists_url": "https://api.github.com/users/James-Sangalli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/James-Sangalli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/James-Sangalli/subscriptions",
      "organizations_url": "https://api.github.com/users/James-Sangalli/orgs",
      "repos_url": "https://api.github.com/users/James-Sangalli/repos",
      "events_url": "https://api.github.com/users/James-Sangalli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/James-Sangalli/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-11-06T13:58:21Z",
    "updated_at": "2018-11-06T13:58:21Z",
    "author_association": "CONTRIBUTOR",
    "body": "@mudgen this seems like something quite handy, however it seems that a big bottleneck is the admin key which could be compromised to lead to a dodgy contract or simply lost. Seems you would need a sort of consortium to manage it...",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/436261462/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/436294631",
    "html_url": "https://github.com/ethereum/EIPs/issues/1538#issuecomment-436294631",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1538",
    "id": 436294631,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzNjI5NDYzMQ==",
    "user": {
      "login": "adibas03",
      "id": 6083241,
      "node_id": "MDQ6VXNlcjYwODMyNDE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6083241?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/adibas03",
      "html_url": "https://github.com/adibas03",
      "followers_url": "https://api.github.com/users/adibas03/followers",
      "following_url": "https://api.github.com/users/adibas03/following{/other_user}",
      "gists_url": "https://api.github.com/users/adibas03/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/adibas03/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/adibas03/subscriptions",
      "organizations_url": "https://api.github.com/users/adibas03/orgs",
      "repos_url": "https://api.github.com/users/adibas03/repos",
      "events_url": "https://api.github.com/users/adibas03/events{/privacy}",
      "received_events_url": "https://api.github.com/users/adibas03/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-11-06T15:32:18Z",
    "updated_at": "2018-11-06T15:32:18Z",
    "author_association": "NONE",
    "body": "@mudgen One thing I think is missing is a default `delegate` address, so in a case where the first deployment has all the contracts in one address, this becomes important, this can always be removed by upgrading a function to address(0) if the function is no longer supported. In a scenario where there is no default delegate, it is simply set as `address(0)`.\r\n@James-Sangalli Adding a consortium needs not be part of the standard, as that is no longer miimum Viable. As for the issue with the ownership, the delegate of the `contractOwner()` can be set to zero to return `null` for the `contractOwner` and remove the `compromise` issue, or in another option is to make the contract `non-upgradable` if that is the case just as @AC0DEM0NK3Y mentioned",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/436294631/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/436305645",
    "html_url": "https://github.com/ethereum/EIPs/issues/1538#issuecomment-436305645",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1538",
    "id": 436305645,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzNjMwNTY0NQ==",
    "user": {
      "login": "mudgen",
      "id": 49092,
      "node_id": "MDQ6VXNlcjQ5MDky",
      "avatar_url": "https://avatars.githubusercontent.com/u/49092?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mudgen",
      "html_url": "https://github.com/mudgen",
      "followers_url": "https://api.github.com/users/mudgen/followers",
      "following_url": "https://api.github.com/users/mudgen/following{/other_user}",
      "gists_url": "https://api.github.com/users/mudgen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mudgen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mudgen/subscriptions",
      "organizations_url": "https://api.github.com/users/mudgen/orgs",
      "repos_url": "https://api.github.com/users/mudgen/repos",
      "events_url": "https://api.github.com/users/mudgen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mudgen/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-11-06T16:00:22Z",
    "updated_at": "2018-11-06T21:25:37Z",
    "author_association": "CONTRIBUTOR",
    "body": "@jackandtheblockstalk Thanks for your feedback.  I will check with the Aaragon and zepplinOS teams. \r\n\r\nTo be clear, multiple functions from the same delegate contract can be added to a transparent contract at the same time with the `updateContracts` function.  Some people have the idea that each function that is added has to be from a different delegate contract. \r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/436305645/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/436306944",
    "html_url": "https://github.com/ethereum/EIPs/issues/1538#issuecomment-436306944",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1538",
    "id": 436306944,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzNjMwNjk0NA==",
    "user": {
      "login": "mudgen",
      "id": 49092,
      "node_id": "MDQ6VXNlcjQ5MDky",
      "avatar_url": "https://avatars.githubusercontent.com/u/49092?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mudgen",
      "html_url": "https://github.com/mudgen",
      "followers_url": "https://api.github.com/users/mudgen/followers",
      "following_url": "https://api.github.com/users/mudgen/following{/other_user}",
      "gists_url": "https://api.github.com/users/mudgen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mudgen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mudgen/subscriptions",
      "organizations_url": "https://api.github.com/users/mudgen/orgs",
      "repos_url": "https://api.github.com/users/mudgen/repos",
      "events_url": "https://api.github.com/users/mudgen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mudgen/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-11-06T16:03:46Z",
    "updated_at": "2018-11-06T16:06:59Z",
    "author_association": "CONTRIBUTOR",
    "body": "@satyamakgec communication between functions from different contracts is not a problem.\r\n\r\nIf `contract2` needs to use a function that is defined in `contract1` then the solution is to add the same function, with the same definition, to `contract2`. Or if `contract2` is already deployed then create a `contract3` contract that has all the needed functionality, deploy it, and use that contract to add the functions to the transparent contract.\r\n\r\nThe problem can also be avoided by putting all the related functionality into one contract and then adding all the external/public functions to the transparent contract with one call to `updateContract`.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/436306944/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/436309365",
    "html_url": "https://github.com/ethereum/EIPs/issues/1538#issuecomment-436309365",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1538",
    "id": 436309365,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzNjMwOTM2NQ==",
    "user": {
      "login": "mudgen",
      "id": 49092,
      "node_id": "MDQ6VXNlcjQ5MDky",
      "avatar_url": "https://avatars.githubusercontent.com/u/49092?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mudgen",
      "html_url": "https://github.com/mudgen",
      "followers_url": "https://api.github.com/users/mudgen/followers",
      "following_url": "https://api.github.com/users/mudgen/following{/other_user}",
      "gists_url": "https://api.github.com/users/mudgen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mudgen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mudgen/subscriptions",
      "organizations_url": "https://api.github.com/users/mudgen/orgs",
      "repos_url": "https://api.github.com/users/mudgen/repos",
      "events_url": "https://api.github.com/users/mudgen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mudgen/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-11-06T16:10:06Z",
    "updated_at": "2018-11-06T16:18:28Z",
    "author_association": "CONTRIBUTOR",
    "body": "@James-Sangalli yes, I think it is possible to build various kinds of systems on top of a transparent contract, such as governance, decentralized schemes, authentication schemes etc. \r\n\r\nI modified the proposal, saying that the scheme for ownership or authentication is not part of the standard.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/436309365/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/436330464",
    "html_url": "https://github.com/ethereum/EIPs/issues/1538#issuecomment-436330464",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1538",
    "id": 436330464,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzNjMzMDQ2NA==",
    "user": {
      "login": "mudgen",
      "id": 49092,
      "node_id": "MDQ6VXNlcjQ5MDky",
      "avatar_url": "https://avatars.githubusercontent.com/u/49092?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mudgen",
      "html_url": "https://github.com/mudgen",
      "followers_url": "https://api.github.com/users/mudgen/followers",
      "following_url": "https://api.github.com/users/mudgen/following{/other_user}",
      "gists_url": "https://api.github.com/users/mudgen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mudgen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mudgen/subscriptions",
      "organizations_url": "https://api.github.com/users/mudgen/orgs",
      "repos_url": "https://api.github.com/users/mudgen/repos",
      "events_url": "https://api.github.com/users/mudgen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mudgen/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-11-06T17:06:36Z",
    "updated_at": "2018-11-06T18:54:42Z",
    "author_association": "CONTRIBUTOR",
    "body": "@adibas03 I see that a default delegate address could be convenient. Would it be necessary?\r\n\r\nThe initial functions of a transparent contract could be added to it in the transparent contract's constructor. Various kinds of initialization of a transparent contract could be done in the constructor. Here is an example that adds initial functions to a transparent contract in the constructor.\r\n\r\n```solidity\r\n constructor(address _erc1538Delegate) public {\r\n    contractOwner = msg.sender;\r\n    emit OwnershipTransferred(address(0), msg.sender);\r\n\r\n    // adding ERC1538 updateContract function\r\n    bytes memory signature = \"updateContract(address,string,string)\";\r\n    bytes4 funcId = bytes4(keccak256(signature));\r\n    delegates[funcId] = _erc1538Delegate;\r\n    emit FunctionUpdate(funcId, address(0), _erc1538Delegate, string(signature));\r\n    emit CommitMessage(\"Added ERC1538 updateContract function at contract creation\");\r\n  \r\n    // add initial functions\r\n    // uses the updateContract function to add initial functions\r\n    bytes memory initialFunctions = \"myFirstFunction()mySecondFunction(string)\";\r\n    address initialDelegate = 0x343434353222222;\r\n    bytes memory calldata = abi.encodeWithSelector(signature, initialDelegate, initialFunctions, \"Adding initial functions\");\r\n    bool success;\r\n    assembly {\r\n      success := delegatecall(gas, _erc1538Delegate, add(calldata, 0x20), mload(calldata), calldata, 0)\r\n    }\r\n    require(success, \"Adding initial functions failed.\");   \r\n  }\r\n```\r\n\r\n@adibas03 I agree with you that a consortium need not be part of the standard.\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/436330464/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/436495237",
    "html_url": "https://github.com/ethereum/EIPs/issues/1538#issuecomment-436495237",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1538",
    "id": 436495237,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzNjQ5NTIzNw==",
    "user": {
      "login": "Droopy78",
      "id": 6580834,
      "node_id": "MDQ6VXNlcjY1ODA4MzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6580834?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Droopy78",
      "html_url": "https://github.com/Droopy78",
      "followers_url": "https://api.github.com/users/Droopy78/followers",
      "following_url": "https://api.github.com/users/Droopy78/following{/other_user}",
      "gists_url": "https://api.github.com/users/Droopy78/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Droopy78/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Droopy78/subscriptions",
      "organizations_url": "https://api.github.com/users/Droopy78/orgs",
      "repos_url": "https://api.github.com/users/Droopy78/repos",
      "events_url": "https://api.github.com/users/Droopy78/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Droopy78/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-11-07T03:48:16Z",
    "updated_at": "2018-11-07T03:48:16Z",
    "author_association": "NONE",
    "body": "@mudgen This is great. There is no chance of [selector clashing exploit](https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357) with this implementation.\r\n\r\nAs far as storage goes, the reference implementation is the way to go as best practice (i.e. inherited storage). All delegates will probably also want to inherit from the ERC1538Delegate reference implementation for updateContract().\r\n\r\nI'm trying to remember... assume a transparent contract's storage variables are all in the inherited base contract, and delegate contract 1 and delegate contract 2 also inherit these variables from the same base contract. Can delegate contract 1 and 2 then define their own separate storage vars on top of that or do they also need to line up in memory? I was assuming the former, as that is how it is worded in the description (also, it would be a pretty clear, hassle-free implementation at that point).",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/436495237/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/436653378",
    "html_url": "https://github.com/ethereum/EIPs/issues/1538#issuecomment-436653378",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1538",
    "id": 436653378,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzNjY1MzM3OA==",
    "user": {
      "login": "mudgen",
      "id": 49092,
      "node_id": "MDQ6VXNlcjQ5MDky",
      "avatar_url": "https://avatars.githubusercontent.com/u/49092?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mudgen",
      "html_url": "https://github.com/mudgen",
      "followers_url": "https://api.github.com/users/mudgen/followers",
      "following_url": "https://api.github.com/users/mudgen/following{/other_user}",
      "gists_url": "https://api.github.com/users/mudgen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mudgen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mudgen/subscriptions",
      "organizations_url": "https://api.github.com/users/mudgen/orgs",
      "repos_url": "https://api.github.com/users/mudgen/repos",
      "events_url": "https://api.github.com/users/mudgen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mudgen/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-11-07T15:04:28Z",
    "updated_at": "2018-11-07T15:06:43Z",
    "author_association": "CONTRIBUTOR",
    "body": "@Droopy78 Yes!   The lack of functions directly in a transparent contract completely avoids selector clashing and the complexity of dealing with that issue.\r\n\r\nYes, the variable storage of contract1 and contract2 need to line up.  I found this sort of thing easiest to manage by creating a new storage contract for each new delegate contract that inherits the storage class from the previous delegate contract. This strategy keeps the storage variables lined up without duplicate code and without the chance of creating bugs.\r\n\r\nHere's some examples of storage scenarios:\r\n\r\nLet's say that contract1 was created and added to a transparent contract. Now you want to add contract2 to the transparent contract.\r\n\r\n1. If contract2 does not use variables defined by contract1 (or later contracts) then it does not need to define variables created in contract1.\r\n2. If contract2 uses variables defined in contract1 then contract2 also needs to define those variables.\r\n3. If contract2 defines new variables then it also needs to define all the variables defined by contract1.\r\n\r\nI am also interested in unstructured storage. The advantage of this approach is that later contracts can create new storage locations without having to define previous ones that it doesn't use.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/436653378/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/436690711",
    "html_url": "https://github.com/ethereum/EIPs/issues/1538#issuecomment-436690711",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1538",
    "id": 436690711,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzNjY5MDcxMQ==",
    "user": {
      "login": "adibas03",
      "id": 6083241,
      "node_id": "MDQ6VXNlcjYwODMyNDE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6083241?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/adibas03",
      "html_url": "https://github.com/adibas03",
      "followers_url": "https://api.github.com/users/adibas03/followers",
      "following_url": "https://api.github.com/users/adibas03/following{/other_user}",
      "gists_url": "https://api.github.com/users/adibas03/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/adibas03/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/adibas03/subscriptions",
      "organizations_url": "https://api.github.com/users/adibas03/orgs",
      "repos_url": "https://api.github.com/users/adibas03/repos",
      "events_url": "https://api.github.com/users/adibas03/events{/privacy}",
      "received_events_url": "https://api.github.com/users/adibas03/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-11-07T16:41:36Z",
    "updated_at": "2018-11-07T16:41:36Z",
    "author_association": "NONE",
    "body": "@mudgen You are right, it seems not necessary, but it might help to have it as part of the standard.\r\nAnother use case, might be if a  another proxy or Identity contract is used to handle the call, and therefore should handle all calls by default.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/436690711/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/437057659",
    "html_url": "https://github.com/ethereum/EIPs/issues/1538#issuecomment-437057659",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1538",
    "id": 437057659,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzNzA1NzY1OQ==",
    "user": {
      "login": "wighawag",
      "id": 790580,
      "node_id": "MDQ6VXNlcjc5MDU4MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/790580?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/wighawag",
      "html_url": "https://github.com/wighawag",
      "followers_url": "https://api.github.com/users/wighawag/followers",
      "following_url": "https://api.github.com/users/wighawag/following{/other_user}",
      "gists_url": "https://api.github.com/users/wighawag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/wighawag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/wighawag/subscriptions",
      "organizations_url": "https://api.github.com/users/wighawag/orgs",
      "repos_url": "https://api.github.com/users/wighawag/repos",
      "events_url": "https://api.github.com/users/wighawag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/wighawag/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-11-08T16:23:04Z",
    "updated_at": "2018-11-08T16:23:04Z",
    "author_association": "CONTRIBUTOR",
    "body": "That's a cool pattern.\r\n\r\nOne thing to add would be to add a security mechanism that invalidate transaction if the contract changed while the transaction was in transit, or simply if the user was not yet aware of the changes.\r\n\r\nWhenever the contract change, a version number is generated and that version is always used as part of the transaction data.\r\n\r\nImplementation could then check the version number matches the current contract version. If it matches, the transaction is allowed. If not it is rejected since the sender was not aware of the changes at that point.\r\n\r\nThis would prevent frontrunning attack where the owner of the contract could change the contract logic just in time to compromise a wealthy sender.\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/437057659/reactions",
      "total_count": 4,
      "+1": 4,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/437083236",
    "html_url": "https://github.com/ethereum/EIPs/issues/1538#issuecomment-437083236",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1538",
    "id": 437083236,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzNzA4MzIzNg==",
    "user": {
      "login": "mudgen",
      "id": 49092,
      "node_id": "MDQ6VXNlcjQ5MDky",
      "avatar_url": "https://avatars.githubusercontent.com/u/49092?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mudgen",
      "html_url": "https://github.com/mudgen",
      "followers_url": "https://api.github.com/users/mudgen/followers",
      "following_url": "https://api.github.com/users/mudgen/following{/other_user}",
      "gists_url": "https://api.github.com/users/mudgen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mudgen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mudgen/subscriptions",
      "organizations_url": "https://api.github.com/users/mudgen/orgs",
      "repos_url": "https://api.github.com/users/mudgen/repos",
      "events_url": "https://api.github.com/users/mudgen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mudgen/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-11-08T17:18:15Z",
    "updated_at": "2018-11-08T17:23:37Z",
    "author_association": "CONTRIBUTOR",
    "body": "@wighawag Yes, you bring up a good point here. Thanks for this insight. It would definitely be good to prevent frontrunning attacks.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/437083236/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/437116270",
    "html_url": "https://github.com/ethereum/EIPs/issues/1538#issuecomment-437116270",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1538",
    "id": 437116270,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzNzExNjI3MA==",
    "user": {
      "login": "mudgen",
      "id": 49092,
      "node_id": "MDQ6VXNlcjQ5MDky",
      "avatar_url": "https://avatars.githubusercontent.com/u/49092?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mudgen",
      "html_url": "https://github.com/mudgen",
      "followers_url": "https://api.github.com/users/mudgen/followers",
      "following_url": "https://api.github.com/users/mudgen/following{/other_user}",
      "gists_url": "https://api.github.com/users/mudgen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mudgen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mudgen/subscriptions",
      "organizations_url": "https://api.github.com/users/mudgen/orgs",
      "repos_url": "https://api.github.com/users/mudgen/repos",
      "events_url": "https://api.github.com/users/mudgen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mudgen/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-11-08T18:59:27Z",
    "updated_at": "2018-11-08T23:47:43Z",
    "author_association": "CONTRIBUTOR",
    "body": "@wighawag One way to handle frontrunning attacks is to verify the expected state after the call to the function you care about in the same transaction. If the state is not as expected then revert. This is how [Project Wyvern](https://www.projectwyvern.com/) handles frontrunning. Project Wyvern or its protocol handles the exchange contracts for OpenSea.io and other exchanges.\r\n\r\nSo here is an example of this.  Let's say that ContractA is a transparent contract and you want to call function `myFunction()`. So you create ContractB with a function `verifyMyFunction()`. The `verifyMyFunction()` function calls `myFunction()` in ContractA and then it checks that state has been changed correctly and throws if not.\r\n\r\nHandling frontrunning like this works. No change to ERC1538 is needed to implement this.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/437116270/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/437144258",
    "html_url": "https://github.com/ethereum/EIPs/issues/1538#issuecomment-437144258",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1538",
    "id": 437144258,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzNzE0NDI1OA==",
    "user": {
      "login": "adibas03",
      "id": 6083241,
      "node_id": "MDQ6VXNlcjYwODMyNDE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6083241?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/adibas03",
      "html_url": "https://github.com/adibas03",
      "followers_url": "https://api.github.com/users/adibas03/followers",
      "following_url": "https://api.github.com/users/adibas03/following{/other_user}",
      "gists_url": "https://api.github.com/users/adibas03/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/adibas03/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/adibas03/subscriptions",
      "organizations_url": "https://api.github.com/users/adibas03/orgs",
      "repos_url": "https://api.github.com/users/adibas03/repos",
      "events_url": "https://api.github.com/users/adibas03/events{/privacy}",
      "received_events_url": "https://api.github.com/users/adibas03/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-11-08T20:28:15Z",
    "updated_at": "2018-11-08T20:30:00Z",
    "author_association": "NONE",
    "body": "Another implementation of this is openZeppelin's [re-entrancy guard](https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/utils/ReentrancyGuard.sol).\r\nThough it is still a little tricky how to implement in this.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/437144258/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/437188593",
    "html_url": "https://github.com/ethereum/EIPs/issues/1538#issuecomment-437188593",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1538",
    "id": 437188593,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzNzE4ODU5Mw==",
    "user": {
      "login": "mudgen",
      "id": 49092,
      "node_id": "MDQ6VXNlcjQ5MDky",
      "avatar_url": "https://avatars.githubusercontent.com/u/49092?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mudgen",
      "html_url": "https://github.com/mudgen",
      "followers_url": "https://api.github.com/users/mudgen/followers",
      "following_url": "https://api.github.com/users/mudgen/following{/other_user}",
      "gists_url": "https://api.github.com/users/mudgen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mudgen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mudgen/subscriptions",
      "organizations_url": "https://api.github.com/users/mudgen/orgs",
      "repos_url": "https://api.github.com/users/mudgen/repos",
      "events_url": "https://api.github.com/users/mudgen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mudgen/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-11-08T23:04:18Z",
    "updated_at": "2018-11-08T23:04:18Z",
    "author_association": "CONTRIBUTOR",
    "body": "@adibas03 how does a re-entry guard prevent a frontrunning attack?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/437188593/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/437291050",
    "html_url": "https://github.com/ethereum/EIPs/issues/1538#issuecomment-437291050",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1538",
    "id": 437291050,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzNzI5MTA1MA==",
    "user": {
      "login": "wighawag",
      "id": 790580,
      "node_id": "MDQ6VXNlcjc5MDU4MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/790580?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/wighawag",
      "html_url": "https://github.com/wighawag",
      "followers_url": "https://api.github.com/users/wighawag/followers",
      "following_url": "https://api.github.com/users/wighawag/following{/other_user}",
      "gists_url": "https://api.github.com/users/wighawag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/wighawag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/wighawag/subscriptions",
      "organizations_url": "https://api.github.com/users/wighawag/orgs",
      "repos_url": "https://api.github.com/users/wighawag/repos",
      "events_url": "https://api.github.com/users/wighawag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/wighawag/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-11-09T08:47:56Z",
    "updated_at": "2018-11-09T08:48:30Z",
    "author_association": "CONTRIBUTOR",
    "body": "@mudgen Interesting, that would indeed works but for some state changes that might be tricky or maybe not even possible to check, no ?\r\n\r\nThe other solution I was thinking is for all function call to have a version as first argument and the ERC1538 default function would simply  check if it matches the current version. If not it reject.\r\n\r\nThe drawback is that you always have to have this extra parameter for every call. Making it incompatible with existing contract standard.\r\n\r\nYou could use a wrapper contract that add that extra param though. \r\n\r\nAnother way is to add a mapping (address => version) that block user from ever calling function unless they previously authorized the newest version. \r\n\r\nIn other word, if the contract update, users need to call approveVersion(versionNumber) first before being able to call any other function\r\n\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/437291050/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/437319431",
    "html_url": "https://github.com/ethereum/EIPs/issues/1538#issuecomment-437319431",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1538",
    "id": 437319431,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzNzMxOTQzMQ==",
    "user": {
      "login": "cwgoes",
      "id": 24760279,
      "node_id": "MDQ6VXNlcjI0NzYwMjc5",
      "avatar_url": "https://avatars.githubusercontent.com/u/24760279?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cwgoes",
      "html_url": "https://github.com/cwgoes",
      "followers_url": "https://api.github.com/users/cwgoes/followers",
      "following_url": "https://api.github.com/users/cwgoes/following{/other_user}",
      "gists_url": "https://api.github.com/users/cwgoes/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cwgoes/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cwgoes/subscriptions",
      "organizations_url": "https://api.github.com/users/cwgoes/orgs",
      "repos_url": "https://api.github.com/users/cwgoes/repos",
      "events_url": "https://api.github.com/users/cwgoes/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cwgoes/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-11-09T10:36:12Z",
    "updated_at": "2018-11-09T10:36:12Z",
    "author_association": "NONE",
    "body": "> The other solution I was thinking is for all function call to have a version as first argument and the ERC1538 default function would simply check if it matches the current version. If not it reject.\r\n\r\nI think you can just use the query functions in the calling function to check the delegate call target, a la https://github.com/ProjectWyvern/wyvern-ethereum/blob/master/contracts/exchange/ExchangeCore.sol#L713 (similar pattern).\r\n\r\n@mudgen This looks pretty solid to me. A few possibilities to consider:\r\n\r\n- More granular upgradability - adding the ability to lock specific functions (instead of locking the whole contract by replacing the `upgradeContract` target). This would require an additional method and a table of function selectors to booleans, but it would a mix of guarantees for contract users that particular functions will not change with flexibility for other functions.\r\n- Consider combining the two events so that a function update must correspond to exactly one explanatory message (also makes querying easier). ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/437319431/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/437337264",
    "html_url": "https://github.com/ethereum/EIPs/issues/1538#issuecomment-437337264",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1538",
    "id": 437337264,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzNzMzNzI2NA==",
    "user": {
      "login": "wighawag",
      "id": 790580,
      "node_id": "MDQ6VXNlcjc5MDU4MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/790580?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/wighawag",
      "html_url": "https://github.com/wighawag",
      "followers_url": "https://api.github.com/users/wighawag/followers",
      "following_url": "https://api.github.com/users/wighawag/following{/other_user}",
      "gists_url": "https://api.github.com/users/wighawag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/wighawag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/wighawag/subscriptions",
      "organizations_url": "https://api.github.com/users/wighawag/orgs",
      "repos_url": "https://api.github.com/users/wighawag/repos",
      "events_url": "https://api.github.com/users/wighawag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/wighawag/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-11-09T11:49:56Z",
    "updated_at": "2018-11-09T11:50:21Z",
    "author_association": "CONTRIBUTOR",
    "body": "@cwgoes \r\n\r\n> I think you can just use the query functions in the calling function to check the delegate call target, a la https://github.com/ProjectWyvern/wyvern-ethereum/blob/master/contracts/exchange/ExchangeCore.sol#L713 (similar pattern).\r\n\r\nI am not sure I follow you, what is the query function? Remember there could be multiple implementation contract in ERC1538 and each of the implementation could call further implementation. As such the contract state (links to the different implementations) should be considered as a whole. Else you need to pass the full list of implementation's address to be checked. \r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/437337264/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/437373608",
    "html_url": "https://github.com/ethereum/EIPs/issues/1538#issuecomment-437373608",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1538",
    "id": 437373608,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzNzM3MzYwOA==",
    "user": {
      "login": "cwgoes",
      "id": 24760279,
      "node_id": "MDQ6VXNlcjI0NzYwMjc5",
      "avatar_url": "https://avatars.githubusercontent.com/u/24760279?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cwgoes",
      "html_url": "https://github.com/cwgoes",
      "followers_url": "https://api.github.com/users/cwgoes/followers",
      "following_url": "https://api.github.com/users/cwgoes/following{/other_user}",
      "gists_url": "https://api.github.com/users/cwgoes/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cwgoes/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cwgoes/subscriptions",
      "organizations_url": "https://api.github.com/users/cwgoes/orgs",
      "repos_url": "https://api.github.com/users/cwgoes/repos",
      "events_url": "https://api.github.com/users/cwgoes/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cwgoes/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-11-09T14:21:59Z",
    "updated_at": "2018-11-09T14:21:59Z",
    "author_association": "NONE",
    "body": "> I am not sure I follow you, what is the query function? Remember there could be multiple implementation contract in ERC1538 and each of the implementation could call further implementation. As such the contract state (links to the different implementations) should be considered as a whole. Else you need to pass the full list of implementation's address to be checked.\r\n\r\nIt would need to be the case that the query function could not be upgraded and that the delegatecall target was not also an ERC1538 proxy.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/437373608/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/437437908",
    "html_url": "https://github.com/ethereum/EIPs/issues/1538#issuecomment-437437908",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/1538",
    "id": 437437908,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzNzQzNzkwOA==",
    "user": {
      "login": "mudgen",
      "id": 49092,
      "node_id": "MDQ6VXNlcjQ5MDky",
      "avatar_url": "https://avatars.githubusercontent.com/u/49092?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mudgen",
      "html_url": "https://github.com/mudgen",
      "followers_url": "https://api.github.com/users/mudgen/followers",
      "following_url": "https://api.github.com/users/mudgen/following{/other_user}",
      "gists_url": "https://api.github.com/users/mudgen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mudgen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mudgen/subscriptions",
      "organizations_url": "https://api.github.com/users/mudgen/orgs",
      "repos_url": "https://api.github.com/users/mudgen/repos",
      "events_url": "https://api.github.com/users/mudgen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mudgen/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-11-09T17:43:01Z",
    "updated_at": "2018-11-09T18:45:54Z",
    "author_association": "CONTRIBUTOR",
    "body": "> This looks pretty solid to me.\r\n\r\n@cwgoes Thanks.\r\n\r\n> Consider combining the two events so that a function update must correspond to exactly one explanatory message (also makes querying easier).\r\n\r\nYes, I agree. I have looked at this.  I considered one event like this: `event ContractUpdate(address[] oldDelegates, address[] newDelegates, bytes4[] functionIds, string functionSignatures, string commitMessage);` That one event could hold all the changes of one call to the `updateContract` function. But there is no parameter indexed in this event so no way to filter the events based on the parameters.  This one event also has its own complexities of parsing the data. I don't know of other event designs that might work better.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/437437908/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
