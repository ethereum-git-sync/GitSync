{
  "url": "https://api.github.com/repos/ethereum/EIPs/issues/2585",
  "repository_url": "https://api.github.com/repos/ethereum/EIPs",
  "labels_url": "https://api.github.com/repos/ethereum/EIPs/issues/2585/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/EIPs/issues/2585/comments",
  "events_url": "https://api.github.com/repos/ethereum/EIPs/issues/2585/events",
  "html_url": "https://github.com/ethereum/EIPs/issues/2585",
  "id": 593539364,
  "node_id": "MDU6SXNzdWU1OTM1MzkzNjQ=",
  "number": 2585,
  "title": "Minimal And Extensible Meta Transaction Forwarder",
  "user": {
    "login": "wighawag",
    "id": 790580,
    "node_id": "MDQ6VXNlcjc5MDU4MA==",
    "avatar_url": "https://avatars.githubusercontent.com/u/790580?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/wighawag",
    "html_url": "https://github.com/wighawag",
    "followers_url": "https://api.github.com/users/wighawag/followers",
    "following_url": "https://api.github.com/users/wighawag/following{/other_user}",
    "gists_url": "https://api.github.com/users/wighawag/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/wighawag/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/wighawag/subscriptions",
    "organizations_url": "https://api.github.com/users/wighawag/orgs",
    "repos_url": "https://api.github.com/users/wighawag/repos",
    "events_url": "https://api.github.com/users/wighawag/events{/privacy}",
    "received_events_url": "https://api.github.com/users/wighawag/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 2328627851,
      "node_id": "MDU6TGFiZWwyMzI4NjI3ODUx",
      "url": "https://api.github.com/repos/ethereum/EIPs/labels/stale",
      "name": "stale",
      "color": "000000",
      "default": false,
      "description": ""
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 14,
  "created_at": "2020-04-03T17:41:17Z",
  "updated_at": "2021-11-21T03:11:30Z",
  "closed_at": "2021-11-21T03:11:30Z",
  "author_association": "CONTRIBUTOR",
  "active_lock_reason": null,
  "body": "Pull Request Link : https://github.com/ethereum/EIPs/pull/2600\r\n\r\n## Simple Summary\r\n\r\nThis standard defines a universal smart contract, the \"Forwarder\", that accept specially crafted signed message by Externally Owned Accounts (EOA) to be executed as contract calls on their behalf by third parties (relayers). These relayers take the responsibility of signing and broadcasting an ethereum transaction carrying the message (a \"Meta Transaction\" message). The proposal is made so that extra Meta Transaction functionality can be built on top without the need for receiver contract to be changed.\r\n\r\n## Abstract\r\n\r\nNative Meta Transaction allows users that simply own a private key to interact on the Ethereum network by only signing messages (no need for ether or account contract, just a private key). Third parties (the relayers) broadcast these messages through a contract on their behalf. \r\nThat contract is in charge to ensure the signing message is well formed and come from the intended signer. It also ensure replay protection so a message cannot be used twice.\r\n\r\nThis proposal implements a minimal contract with that responsibility, while remaining flexible for future extension. On particular it allows more complex message format (like [EIP-1776](https://github.com/ethereum/EIPs/issues/1776)) to be implemented on top, while meta transaction receiver can remain unchanged and trust only the singleton Forwarder.\r\n\r\nmsg.sender verification is achieved by replacing the use of solidity `msg.sender` with a function that extract the signer address from the call data.\r\n\r\n## Motivation\r\n\r\nSeveral EIPs have been proposed to support Meta Transactions ([EIP-1776](https://github.com/ethereum/EIPs/issues/1776), [EIP-1613](https://eips.ethereum.org/EIPS/eip-1613), [EIP-1077](https://eips.ethereum.org/EIPS/eip-1077)). They all have so far failed to get traction. This can be attributed to several factor but one important aspect is that they all tries to implement much more that simply forwarding message to contracts.\r\nBy being complex, they increase the friction for contract developer that need to trust that these solution are future proof.\r\n\r\nThis proposal aims at finding the most basic features while remaining extensible. As such this proposal will not deal with relayer repayment (that EIP-1776 and other tackle) or relayer coordination (that EIP-1613 tackle). Its sole purpose it to ensure the signed message is valid and that receiver contract have only one contract to trust.\r\n\r\n## Specification \r\nThe key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in [RFC 2119](https://www.ietf.org/rfc/rfc2119.txt).\r\n \r\n### Message format  \r\n  \r\nThe proposal is using a message format based on [EIP-712](https://eips.ethereum.org/EIPS/eip-712) so that wallet that support EIP-712 but do not support the proposal described here can still offer an approval display showing all the information albeit in a less than ideal presentation.  \r\n    \r\nHere is the proposed EIP-712 message format :  \r\n```MetaTransaction(address from,address to,uint256 value,uint256 chainId,address replayProtection,bytes nonce,bytes data,bytes32 innerMessageHash)```  \r\n\r\nThe meaning of each field is as follow:  \r\n  \r\n* **from**: the account from which the meta-transaction is executed for, that value will be appended to the calldata of the meta transaction call. It MUST be either equal to the resulting message signer or have been given execution rights to the signer (via [ERC1271](https://eips.ethereum.org/EIPS/eip-1271) or [ERC1654](https://github.com/ethereum/EIPs/issues/1654))  \r\n* **to**: the target that will receive the meta transaction call.\r\n* **value**: the ether value expected to be given by the relayer to the call. This can be used by more complex meta transaction implementation, to allow user that do own ether to perform tx that requires it. THis can be compensated for example by paying the relayer for it in token or other means. This is outside of the scope of this EIP.\r\n* **chainId**: By specifying the chainId, the meta transaction is not going to be executable in a fork whose chainId is different. See rationale for why we do not use EIP-712 chainId from the domain\r\n* **replayProtection**: address of a contract that will handle replay protection for the user. If set to address(0) or the address of the forwarder, it will use the default replay protection, see below for more details.\r\n* **nonce**:  the nonce value used by the signer and passed to `replayProtection.checkAndUpdateNonce(bytes)`. The default is a 2 dimensional nonce represented as a 256 bit integer split in two.\r\n* **data**: the bytes to be executed at ```to```. the `from` address will be appended to it so that receiver contract can access the signer of the meta transaction.\r\n* **innerMessageHash**: Its purpose is to allow more complex meta transaction mechanism to embed message into a single message. (see below for details)\r\n  \r\n### transaction execution and receiver verification  \r\n  \r\nAfter the singleton Forwarder contract check for the validity of the signature, it append the address of the signer (or the account contract if using EIP-1271 or EIP-1654) to the call data.\r\n\r\nAs the result in order for a contract to receive meta transaction it simply has to extend the following contract and replace text occurrence of `msg.sender` with `_getTxSigner()` :\r\n\r\n```\r\npragma solidity 0.6.4;\r\n\r\ncontract ForwarderReceiverBase {\r\n    address /* immutable */ _forwarder; // can be hardcoded once the Forwarder address is known\r\n    constructor(address forwarder) public {\r\n        _forwarder = forwarder;\r\n    }\r\n\r\n    function _getTxSigner() internal view returns (address payable signer) {\r\n        if (msg.sender == _forwarder) {\r\n            bytes memory data = msg.data;\r\n            uint256 length = msg.data.length;\r\n            assembly { signer := and(mload(sub(add(data, length), 0x00)), 0xffffffffffffffffffffffffffffffffffffffff) }\r\n        } else {\r\n            signer = msg.sender;\r\n        }\r\n\t}\r\n}\r\n``` \r\n\r\n\r\n### default replay protection\r\n\r\nWhile the Forwarder allows user to choose any replay protection they chose, this forwarder comes with a default implementation to get started.\r\nThe default implementation use a 2 dimensional nonce, so that user can send simultaneous transactions in multiple independent batches.\r\n\r\nThe nonce is simply an abi encoded uint256 that is split in two 128 bit values. The higher bits represent the batchId while the lower bits represent the nonce in the batch.\r\n\r\nApplication can request the current nonce by calling the function `getNonce(userAddress, batchId)`\r\n\r\nThe nonce to be sent is equal to the current Nonce. For every use the current Nonce get increased by one for that particular batch.\r\n\r\n### batching calls\r\n\r\nTHe forwarder also provide a mechanism to batch meta transaction in one message allowing the calls to either succeed fully or fails.\r\nThe message need to perform encode a call to the forwarder with this special function : `batch` that can only be called by the forwarder itself.\r\nCalls are a struct containing the destination (`to`), the data (`data`) and the ether value to passed in (`value`). It is up to the user to ensure it sign a value big enough to cover the sum of all values passed in.\r\n\r\n \r\n### wallet / browser  \r\n  \r\nWhile the forwarder use EIP-712 message format and wallet can use the information to display some information about the meta transaction. Wallets should integrate EIP-2585 more comprehensively.\r\nIn particular they should show a UI similar to existing Ethereum transaction.\r\nFurthermore, since that proposal is built to support extensibility via the `innerMessageHash` wallet that supports EIP-2585 should add a specific API for emitting meta transaction :\r\n\r\nSimilar to `eth_signTypedData` (see [article](https://medium.com/metamask/eip712-is-coming-what-to-expect-and-how-to-use-it-bb92fd1a7a26))\r\n\r\nwallet would add a new JSON RPC method :\r\n\r\n```\r\n{\r\n    \"method\": \"eth_signMetaTransaction\",\r\n    \"params:\" [<signer>, <eip2585Message>, <innerMessageData>]\r\n}\r\n``` \r\n\r\n- `signer` would be the account asked to sign the message\r\n- `eip2585Message` would be the message as described in that proposal, except that the `innerMessageHash` is optional, see `innerMessageData` below\r\n- `innerMessageData` is optional. When absent, message need to include the `innerMessageHash` or it default to the zero filled bytes32. If specified, it follows EIP-712 standard and need to specify both the message and types, like specified in EIP-712. But instead of signing such message, it simply hash it. The resulting hash is then used as the `innerMessageHash` field for the eip2585 message.\r\n\r\nWallets that support EIP-2585 will thus be able to display new fields name and their values for proposals built on top of EIP-2585. This allow experimentations at a higher level keeping receiver contract compatible.\r\n\r\nEIP-1776 or EIP-1613 could thus be built without requiring receiver contracts to change. Their extra fields would be displayed to wallet via the inner EIP-712 message. Obviously, once these standards become mainstream, wallet can decide to support them more natively if necessary.\r\n\r\n## Rationale\r\n\r\n### Account Contract Support\r\n\r\nWhile Native Meta Transaction System like this EIP, are designed to allow Externally Owned Accounts (EOA) to emit Meta Transaction, allowing Account contract to use such system is valuable for the following reasons :\r\n- Account Contract can reuse the relayers already setup for EIP-2585\r\n- Any EIP built on top of EIP-2585 would benefit Account Contracts too\r\n- The extra complexity is not big and EIP like EIP-1271 and EIP-1654 already exists\r\n\r\n### Forwarding msg.value\r\n\r\nWhile on its own forwarding `msg.value` might not be used with EIP-2585 alone (as relayer would need to be compensated and EIP-2585 does not attempt to tackle that), EIP built on top, like EIP-1776 would benefit in allowing EOA to pay for service in ETH by rewarding relayers in other tokens.\r\n\r\n### Flexible Replay Protection\r\n\r\nWhile the implementation implements a default 2 dimensional nonce replay protection, it also allows signers to provide their own.\r\n\r\n### innerMessageHash\r\n\r\nThe innerMessageHash's purpose is that more complex message format can be used to support more complex meta transaction system. For example relayer repayment mechanism proposed by EIP-1776 can be built on top.\r\n\r\nThe innerMessageHash is to be used by wallet provider and MUST be the hash of an EIP-712 message, that wallet can then interpret to display the relevant information. See above for a description on how wallet handle such hash. Future message format could be added too.\r\n\r\n### Signature Format : EIP-712\r\n\r\nThe message format is based on EIP-712 so that wallet not supporting EIP-2585 can still display some information. Unfortunately, they would not be able to display any information provided by the message hashed into `innerMessageHash` for EIP-2585 extension, like EIP-1776. Special support from Wallet is needed for that.\r\n\r\n### Fork Replay Protection (and transition)\r\n\r\nThe message format do not use EIP-712 domain for chainId protection as this introduce unnecessary implementation complexity for dealing with EIP-712 domain hash refresh. Instead the chainId is provided as part of the meta transaction message. Since we expect wallet to parse the message for proper display, they can handle chainId verification too.\r\n\r\nThe chainId is then passed in to the call and checked against the current chain's chainId. This is so a proper error message is given in case the chainId do not match.\r\n\r\nNote that such system does not handle fork transition. [EIP-1344](https://eips.ethereum.org/EIPS/eip-1344) is not well suited for it as it would require the maintenance of a chainId cache to handle past chainId and this would add extra complexity. Because contentious chain forks are infrequent and the only downside would be that user would have to resubmit their signed message for the new fork they are interested in, the complexity added is not worth it. Plus even a cache is not full proof as mentioned in [EIP-1965](https://eips.ethereum.org/EIPS/eip-1965)\r\n\r\nOn the other hand if EIP-1965 was implemented we could have used it to offer safe fork transition too.\r\n\r\n### Batching Capability\r\n\r\nThe Forwarder allows Meta transaction to be batched in a single transaction, but instead of complexifying the message format to include an array of calls, the implementation instead relies on a special `batch` function that can be the target of the meta transaction itself.\r\n\r\nWallet will need to parse this special call to display the list of meta transaction call to be executed.\r\n\r\n\r\n## Backwards Compatibility\r\nThis is a new contract and interface, no backward compatibility issues\r\n\r\n## Test Cases\r\n\r\nTests can be found [here](https://github.com/wighawag/eip-2585/tree/master/contracts/test/)\r\n\r\n## Implementation\r\n\r\n```solidity\r\n/* EIP-2585 Minimal Native Meta Transaction Forwarder\r\n * This standard defines a universal native meta transaction smart contract\r\n * that accept specially crafted Externally Owned Accounts (EOA) signed message\r\n * to forward to receiver contract via third parties.\r\n *\r\n * Written in 2020 by Ronan Sandford\r\n *\r\n * To the extent possible under law, the author(s) have dedicated all copyright\r\n * and related and neighboring rights to this software to the public domain\r\n * worldwide. This software is distributed without any warranty.\r\n *\r\n * You should have received a copy of the CC0 Public Domain Dedication along\r\n * with this software. If not, see\r\n * <https://creativecommons.org/publicdomain/zero/1.0/>.\r\n *    \r\n *       .-''-.  .-./`) .-------.               .`````-.  ,--------.     .-''''-.  ,--------.   \r\n *     .'_ _   \\ \\ .-.')\\  _(`)_ \\             /   ,-.  \\ |   _____|    /  _--.  \\ |   _____|   \r\n *    / ( ` )   '/ `-' \\| (_ o._)|            (___/  |   ||  )          |_( )_ ' | |  )         \r\n *   . (_ o _)  | `-'`\"`|  (_,_) /_ _    _ _        .'  / |  '----.     (_ o _). / |  '----.    \r\n *   |  (_,_)___| .---. |   '-.-'( ' )--( ' )   _.-'_.-'  |_.._ _  '.  .'(_,_).  `.|_.._ _  '.  \r\n *   '  \\   .---. |   | |   |   (_{;}_)(_{;}_)_/_  .'        ( ' )   \\|_( )_    \\  |  ( ' )   \\ \r\n *    \\  `-'    / |   | |   |    (_,_)--(_,_)( ' )(__..--. _(_{;}_)  |(_ o _)   /  |_(_{;}_)  | \r\n *     \\       /  |   | /   )               (_{;}_)      ||  (_,_)  /  (_,_)..-' .'|  (_,_)  /  \r\n *      `'-..-'   '---' `---'                (_,_)-------' `...__..'     `-....-'   `...__..'   \r\n *                                                                                           \r\n */\r\npragma solidity 0.6.4;\r\npragma experimental ABIEncoderV2;\r\n\r\ninterface ERC1271 {\r\n    function isValidSignature(bytes calldata data, bytes calldata signature) external view returns (bytes4 magicValue);\r\n}\r\n\r\ninterface ERC1654 {\r\n   function isValidSignature(bytes32 hash, bytes calldata signature) external view returns (bytes4 magicValue);\r\n}\r\n\r\ninterface ReplayProtection {\r\n    function checkAndUpdateNonce(address signer, bytes calldata nonce) external returns (bool);\r\n}\r\n\r\ninterface Forwarder {\r\n\r\n    enum SignatureType { DIRECT, EIP1654, EIP1271 }\r\n\r\n    struct Message {\r\n        address from;\r\n        address to;\r\n        uint256 chainId;\r\n        address replayProtection;\r\n        bytes nonce;\r\n        bytes data;\r\n        bytes32 innerMessageHash;\r\n\t}\r\n\r\n    function forward(\r\n        Message calldata message,\r\n        SignatureType signatureType,\r\n        bytes calldata signature\r\n    ) external payable;\r\n}\r\n\r\nlibrary SigUtil {\r\n    function recover(bytes32 hash, bytes memory sig) internal pure returns (address recovered) {\r\n        require(sig.length == 65, \"SIGNATURE_INVALID_LENGTH\");\r\n\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n        assembly {\r\n            r := mload(add(sig, 32))\r\n            s := mload(add(sig, 64))\r\n            v := byte(0, mload(add(sig, 96)))\r\n        }\r\n\r\n        // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\r\n        if (v < 27) {\r\n            v += 27;\r\n        }\r\n        require(v == 27 || v == 28, \"SIGNATURE_INVALID_V\");\r\n\r\n        recovered = ecrecover(hash, v, r, s);\r\n        require(recovered != address(0), \"SIGNATURE_ZERO_ADDRESS\");\r\n    }\r\n\r\n    function eth_sign_prefix(bytes32 hash) internal pure returns (bytes memory) {\r\n        return abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash);\r\n    }\r\n}\r\n\r\n/// @notice Forwarder for Meta Transactions Using EIP712 Signing Standard, also implement default Replay Protection using 2 dimensional nonces\r\ncontract EIP712Forwarder is Forwarder, ReplayProtection {\r\n\r\n    // ///////////////////////////// FORWARDING EOA META TRANSACTION ///////////////////////////////////\r\n\r\n    bytes4 internal constant ERC1271_MAGICVALUE = 0x20c13b0b;\r\n    bytes4 internal constant ERC1654_MAGICVALUE = 0x1626ba7e;\r\n\r\n    /// @notice forward call from EOA signed message\r\n    /// @param message.from address from which the message come from (For EOA this is the same as signer)\r\n    /// @param message.to target of the call\r\n    /// @param message.replayProtection contract address that check and update nonce\r\n    /// @param message.nonce nonce value\r\n    /// @param message.data call data\r\n    /// @param message.innerMessageHash extra data hashed that can be used as embedded message for implementing more complex scenario, with one sig\r\n    /// @param signatureType signatureType either EOA, EIP1271 or EIP1654\r\n    /// @param signature signature\r\n    function forward(\r\n        Message memory message,\r\n        SignatureType signatureType,\r\n        bytes memory signature\r\n    ) public override payable { // external with ABIEncoderV2 Struct is not supported in solidity < 0.6.4\r\n        require(_isValidChainId(message.chainId), \"INVALID_CHAIN_ID\");\r\n        _checkSigner(message, signatureType, signature);\r\n        // optimization to avoid call if using default nonce strategy\r\n        // this contract implements a default nonce strategy and can be called directly\r\n        if (message.replayProtection == address(0) || message.replayProtection == address(this)) {\r\n            require(checkAndUpdateNonce(message.from, message.nonce), \"NONCE_INVALID\");\r\n        } else {\r\n            require(ReplayProtection(message.replayProtection).checkAndUpdateNonce(message.from, message.nonce), \"NONCE_INVALID\");\r\n        }\r\n\r\n        _call(message.from, message.to, msg.value, message.data);\r\n    }\r\n\r\n\r\n    // /////////////////////////////////// BATCH CALL /////////////////////////////////////\r\n\r\n    struct Call {\r\n        address to;\r\n        bytes data;\r\n        uint256 value;\r\n    }\r\n\r\n    /// @notice batcher function that can be called as part of a meta transaction (allowing to batch call atomically)\r\n    /// @param calls list of call data and destination\r\n    function batch(Call[] memory calls) public payable { // external with ABIEncoderV2 Struct is not supported in solidity < 0.6.4\r\n        require(msg.sender == address(this), \"FORWARDER_ONLY\");\r\n        address signer;\r\n        bytes memory data = msg.data;\r\n        uint256 length = msg.data.length;\r\n        assembly { signer := and(mload(sub(add(data, length), 0x00)), 0xffffffffffffffffffffffffffffffffffffffff) }\r\n        for(uint256 i = 0; i < calls.length; i++) {\r\n            _call(signer, calls[i].to, calls[i].value, calls[i].data);\r\n        }\r\n    }\r\n\r\n    // /////////////////////////////////// REPLAY PROTECTION /////////////////////////////////////\r\n\r\n    mapping(address => mapping(uint128 => uint128)) _batches;\r\n\r\n    /// @notice implement a default nonce stategy\r\n    /// @param signer address to check and update nonce for\r\n    /// @param nonce value of nonce sent as part of the forward call\r\n    function checkAndUpdateNonce(address signer, bytes memory nonce) public override returns (bool) {\r\n        // TODO? default nonce strategy could be different (maybe the most versatile : batchId + Nonce)\r\n        uint256 value = abi.decode(nonce, (uint256));\r\n        uint128 batchId = uint128(value / 2**128);\r\n        uint128 batchNonce = uint128(value % 2**128);\r\n\r\n        uint128 currentNonce = _batches[signer][batchId];\r\n        if (batchNonce == currentNonce) {\r\n            _batches[signer][batchId] = currentNonce + 1;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function getNonce(address signer, uint128 batchId) external view returns (uint128) {\r\n        return _batches[signer][batchId];\r\n    }\r\n\r\n\r\n    // ///////////////////////////////// INTERNAL ////////////////////////////////////////////\r\n\r\n    function _call(\r\n        address from,\r\n        address to,\r\n        uint256 value,\r\n        bytes memory data\r\n    ) internal {\r\n        (bool success,) = to.call.value(value)(abi.encodePacked(data, from));\r\n        if (!success) {\r\n            assembly {\r\n                let returnDataSize := returndatasize()\r\n                returndatacopy(0, 0, returnDataSize)\r\n                revert(0, returnDataSize)\r\n            }\r\n        }\r\n    }\r\n\r\n    function _checkSigner(\r\n        Message memory message,\r\n        SignatureType signatureType,\r\n        bytes memory signature\r\n    ) internal view returns (address) {\r\n        bytes memory dataToHash = _encodeMessage(message);\r\n        if (signatureType == SignatureType.EIP1271) {\r\n            require(ERC1271(message.from).isValidSignature(dataToHash, signature) == ERC1271_MAGICVALUE, \"SIGNATURE_1271_INVALID\");\r\n        } else if(signatureType == SignatureType.EIP1654){\r\n            require(ERC1654(message.from).isValidSignature(keccak256(dataToHash), signature) == ERC1654_MAGICVALUE, \"SIGNATURE_1654_INVALID\");\r\n        } else {\r\n            address signer = SigUtil.recover(keccak256(dataToHash), signature);\r\n            require(signer == message.from, \"SIGNATURE_WRONG_SIGNER\");\r\n        }\r\n    }\r\n\r\n    function _isValidChainId(uint256 chainId) internal view returns (bool) {\r\n        uint256 _chainId;\r\n        assembly {_chainId := chainid() }\r\n        return chainId == _chainId;\r\n    }\r\n\r\n    bytes32 constant EIP712DOMAIN_TYPEHASH = keccak256(\r\n        \"EIP712Domain(string name,string version)\"\r\n    );\r\n    bytes32 constant DOMAIN_SEPARATOR = keccak256(\r\n        abi.encode(\r\n            EIP712DOMAIN_TYPEHASH,\r\n            keccak256(\"Forwarder\"),\r\n            keccak256(\"1\")\r\n        )\r\n    );\r\n\r\n    bytes32 constant METATRANSACTION_TYPEHASH = keccak256(\r\n        \"MetaTransaction(address from,address to,uint256 value,uint256 chainId,address replayProtection,bytes nonce,bytes data,bytes32 innerMessageHash)\"\r\n    );\r\n\r\n    function _encodeMessage(Message memory message) internal view returns (bytes memory) {\r\n        return abi.encodePacked(\r\n            \"\\x19\\x01\",\r\n            DOMAIN_SEPARATOR,\r\n            keccak256(abi.encode(\r\n                METATRANSACTION_TYPEHASH,\r\n                message.from,\r\n                message.to,\r\n                msg.value,\r\n                message.chainId,\r\n                message.replayProtection,\r\n                keccak256(message.nonce),\r\n                keccak256(message.data),\r\n                message.innerMessageHash\r\n            ))\r\n        );\r\n    }\r\n}\r\n```\r\n\r\n## Security Considerations\r\n\r\nThe Security of the proposal relies on the safety of the contract implementation only. One of the reason, native meta transaction has not taken off is that contract creator have to trust a specific mechanism. The proposal aims to be a minimal meta transaction implementation.\r\n\r\n\r\n## References\r\n\r\n- [EIP-1776](https://github.com/ethereum/EIPs/issues/1776)\r\n- [EIP-1613](https://eips.ethereum.org/EIPS/eip-1613)\r\n- [EIP-1077](https://eips.ethereum.org/EIPS/eip-1077)\r\n- [EIP-1271](https://eips.ethereum.org/EIPS/eip-1271)\r\n- [EIP-1654](https://github.com/ethereum/EIPs/issues/1654)\r\n- [EIP-1344](https://eips.ethereum.org/EIPS/eip-1344)\r\n- [EIP-1965](https://eips.ethereum.org/EIPS/eip-1965)\r\n- [EIP-1930](https://eips.ethereum.org/EIPS/eip-1930)\r\n\r\n## Copyright\r\nCopyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).\r\n",
  "closed_by": {
    "login": "github-actions[bot]",
    "id": 41898282,
    "node_id": "MDM6Qm90NDE4OTgyODI=",
    "avatar_url": "https://avatars.githubusercontent.com/in/15368?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/github-actions%5Bbot%5D",
    "html_url": "https://github.com/apps/github-actions",
    "followers_url": "https://api.github.com/users/github-actions%5Bbot%5D/followers",
    "following_url": "https://api.github.com/users/github-actions%5Bbot%5D/following{/other_user}",
    "gists_url": "https://api.github.com/users/github-actions%5Bbot%5D/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/github-actions%5Bbot%5D/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/github-actions%5Bbot%5D/subscriptions",
    "organizations_url": "https://api.github.com/users/github-actions%5Bbot%5D/orgs",
    "repos_url": "https://api.github.com/users/github-actions%5Bbot%5D/repos",
    "events_url": "https://api.github.com/users/github-actions%5Bbot%5D/events{/privacy}",
    "received_events_url": "https://api.github.com/users/github-actions%5Bbot%5D/received_events",
    "type": "Bot",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/2585/reactions",
    "total_count": 13,
    "+1": 9,
    "-1": 0,
    "laugh": 0,
    "hooray": 4,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/EIPs/issues/2585/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/611659270",
    "html_url": "https://github.com/ethereum/EIPs/issues/2585#issuecomment-611659270",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/2585",
    "id": 611659270,
    "node_id": "MDEyOklzc3VlQ29tbWVudDYxMTY1OTI3MA==",
    "user": {
      "login": "danfinlay",
      "id": 542863,
      "node_id": "MDQ6VXNlcjU0Mjg2Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/542863?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/danfinlay",
      "html_url": "https://github.com/danfinlay",
      "followers_url": "https://api.github.com/users/danfinlay/followers",
      "following_url": "https://api.github.com/users/danfinlay/following{/other_user}",
      "gists_url": "https://api.github.com/users/danfinlay/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/danfinlay/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/danfinlay/subscriptions",
      "organizations_url": "https://api.github.com/users/danfinlay/orgs",
      "repos_url": "https://api.github.com/users/danfinlay/repos",
      "events_url": "https://api.github.com/users/danfinlay/events{/privacy}",
      "received_events_url": "https://api.github.com/users/danfinlay/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-04-09T17:42:39Z",
    "updated_at": "2020-04-09T17:42:39Z",
    "author_association": "CONTRIBUTOR",
    "body": "I think this is a wonderful synthesis of many of the best ideas that I saw on display during [the MetaMask MetaTransaction Hackathon](), and I applaud it.\r\n\r\nHaving custom replay-protection is a huge addition to 1776, and pointing to a custom replay protection contract means it's infinitely extensible. A few ideas:\r\n- Dependent transactions can be queued\r\n- Most transactions can be parallelized\r\n- Transaction \"options\" can be handed out that can be submitted at any time, effectively enabling off-chain capabilities.\r\n\r\nIt seems like this can be deployed whenever people find it trustworthy (after an audit?), and then contracts can begin integrating compatibility, so it seems to have a very smooth adoption path.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/611659270/reactions",
      "total_count": 3,
      "+1": 3,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/613896002",
    "html_url": "https://github.com/ethereum/EIPs/issues/2585#issuecomment-613896002",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/2585",
    "id": 613896002,
    "node_id": "MDEyOklzc3VlQ29tbWVudDYxMzg5NjAwMg==",
    "user": {
      "login": "Amxx",
      "id": 2432299,
      "node_id": "MDQ6VXNlcjI0MzIyOTk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2432299?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Amxx",
      "html_url": "https://github.com/Amxx",
      "followers_url": "https://api.github.com/users/Amxx/followers",
      "following_url": "https://api.github.com/users/Amxx/following{/other_user}",
      "gists_url": "https://api.github.com/users/Amxx/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Amxx/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Amxx/subscriptions",
      "organizations_url": "https://api.github.com/users/Amxx/orgs",
      "repos_url": "https://api.github.com/users/Amxx/repos",
      "events_url": "https://api.github.com/users/Amxx/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Amxx/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-04-15T08:26:54Z",
    "updated_at": "2020-04-15T08:26:54Z",
    "author_association": "CONTRIBUTOR",
    "body": "I believe \r\n`ERC1271_MAGICVALUE` and `ERC1654_MAGICVALUE`\r\ncould be replaced with\r\n`ERC1271(0).isValidSignature.selector` and `ERC1654(0).isValidSignature.selector`\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/613896002/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/613897680",
    "html_url": "https://github.com/ethereum/EIPs/issues/2585#issuecomment-613897680",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/2585",
    "id": 613897680,
    "node_id": "MDEyOklzc3VlQ29tbWVudDYxMzg5NzY4MA==",
    "user": {
      "login": "Amxx",
      "id": 2432299,
      "node_id": "MDQ6VXNlcjI0MzIyOTk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2432299?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Amxx",
      "html_url": "https://github.com/Amxx",
      "followers_url": "https://api.github.com/users/Amxx/followers",
      "following_url": "https://api.github.com/users/Amxx/following{/other_user}",
      "gists_url": "https://api.github.com/users/Amxx/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Amxx/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Amxx/subscriptions",
      "organizations_url": "https://api.github.com/users/Amxx/orgs",
      "repos_url": "https://api.github.com/users/Amxx/repos",
      "events_url": "https://api.github.com/users/Amxx/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Amxx/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-04-15T08:30:05Z",
    "updated_at": "2020-04-15T08:30:05Z",
    "author_association": "CONTRIBUTOR",
    "body": "couldn't `_call` be done is vanilia solidity with\r\n\r\n```\r\n(bool success, bytes memory returndata) = to.call{value: value}(abi.encodePacked(data, from));\r\nrequire(success, string(returndata));\r\n```\r\nThat is more readeable\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/613897680/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/613899115",
    "html_url": "https://github.com/ethereum/EIPs/issues/2585#issuecomment-613899115",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/2585",
    "id": 613899115,
    "node_id": "MDEyOklzc3VlQ29tbWVudDYxMzg5OTExNQ==",
    "user": {
      "login": "Amxx",
      "id": 2432299,
      "node_id": "MDQ6VXNlcjI0MzIyOTk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2432299?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Amxx",
      "html_url": "https://github.com/Amxx",
      "followers_url": "https://api.github.com/users/Amxx/followers",
      "following_url": "https://api.github.com/users/Amxx/following{/other_user}",
      "gists_url": "https://api.github.com/users/Amxx/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Amxx/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Amxx/subscriptions",
      "organizations_url": "https://api.github.com/users/Amxx/orgs",
      "repos_url": "https://api.github.com/users/Amxx/repos",
      "events_url": "https://api.github.com/users/Amxx/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Amxx/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-04-15T08:32:49Z",
    "updated_at": "2020-04-15T08:32:49Z",
    "author_association": "CONTRIBUTOR",
    "body": "```\r\nbytes32 constant EIP712DOMAIN_TYPEHASH\r\nbytes32 constant DOMAIN_SEPARATOR\r\nbytes32 constant METATRANSACTION_TYPEHASH\r\n```\r\nShould be hardcoded bytes32, with comment showing the receipe. Unlike what you expect, the current implementation is not computed at compile time and thus optimised.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/613899115/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/613987331",
    "html_url": "https://github.com/ethereum/EIPs/issues/2585#issuecomment-613987331",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/2585",
    "id": 613987331,
    "node_id": "MDEyOklzc3VlQ29tbWVudDYxMzk4NzMzMQ==",
    "user": {
      "login": "wighawag",
      "id": 790580,
      "node_id": "MDQ6VXNlcjc5MDU4MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/790580?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/wighawag",
      "html_url": "https://github.com/wighawag",
      "followers_url": "https://api.github.com/users/wighawag/followers",
      "following_url": "https://api.github.com/users/wighawag/following{/other_user}",
      "gists_url": "https://api.github.com/users/wighawag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/wighawag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/wighawag/subscriptions",
      "organizations_url": "https://api.github.com/users/wighawag/orgs",
      "repos_url": "https://api.github.com/users/wighawag/repos",
      "events_url": "https://api.github.com/users/wighawag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/wighawag/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-04-15T11:41:42Z",
    "updated_at": "2020-04-15T11:41:42Z",
    "author_association": "CONTRIBUTOR",
    "body": "Hi @Amxx thanks for the suggestions. Going to update the code. Probably better to put this low details comment there though : https://github.com/ethereum/EIPs/pull/2600/files so we keep that thread on the high level matters\r\n\r\nRe vanilia solidity call, the issue is that `require(success, string(returndata));` will wrap the error string into another Error(string) \r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/613987331/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/614870377",
    "html_url": "https://github.com/ethereum/EIPs/issues/2585#issuecomment-614870377",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/2585",
    "id": 614870377,
    "node_id": "MDEyOklzc3VlQ29tbWVudDYxNDg3MDM3Nw==",
    "user": {
      "login": "Amxx",
      "id": 2432299,
      "node_id": "MDQ6VXNlcjI0MzIyOTk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2432299?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Amxx",
      "html_url": "https://github.com/Amxx",
      "followers_url": "https://api.github.com/users/Amxx/followers",
      "following_url": "https://api.github.com/users/Amxx/following{/other_user}",
      "gists_url": "https://api.github.com/users/Amxx/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Amxx/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Amxx/subscriptions",
      "organizations_url": "https://api.github.com/users/Amxx/orgs",
      "repos_url": "https://api.github.com/users/Amxx/repos",
      "events_url": "https://api.github.com/users/Amxx/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Amxx/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-04-16T20:12:30Z",
    "updated_at": "2020-04-16T20:12:30Z",
    "author_association": "CONTRIBUTOR",
    "body": "Any reason why gas amount value for the forward call is not specified in the message ?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/614870377/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/614896421",
    "html_url": "https://github.com/ethereum/EIPs/issues/2585#issuecomment-614896421",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/2585",
    "id": 614896421,
    "node_id": "MDEyOklzc3VlQ29tbWVudDYxNDg5NjQyMQ==",
    "user": {
      "login": "wighawag",
      "id": 790580,
      "node_id": "MDQ6VXNlcjc5MDU4MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/790580?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/wighawag",
      "html_url": "https://github.com/wighawag",
      "followers_url": "https://api.github.com/users/wighawag/followers",
      "following_url": "https://api.github.com/users/wighawag/following{/other_user}",
      "gists_url": "https://api.github.com/users/wighawag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/wighawag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/wighawag/subscriptions",
      "organizations_url": "https://api.github.com/users/wighawag/orgs",
      "repos_url": "https://api.github.com/users/wighawag/repos",
      "events_url": "https://api.github.com/users/wighawag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/wighawag/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-04-16T21:07:07Z",
    "updated_at": "2020-04-16T21:07:07Z",
    "author_association": "CONTRIBUTOR",
    "body": "This is because this is unnecessary as the forwarder does not deal with fee repayment.\r\nthe whole gas is passed and if it error due to a lack of gas the whole call fails.\r\n\r\ngas fee repayment can be implemented on top though, in which case the gas to be passed will be passed to the forwarder. See EIP-1776 implementation here : https://github.com/wighawag/eip-2585/blob/ee20b96ba284e45be09c01adec76c21b98dfd4bb/contracts/src/EIP1776ForwarderWrapper.sol#L108\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/614896421/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/615214250",
    "html_url": "https://github.com/ethereum/EIPs/issues/2585#issuecomment-615214250",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/2585",
    "id": 615214250,
    "node_id": "MDEyOklzc3VlQ29tbWVudDYxNTIxNDI1MA==",
    "user": {
      "login": "vincentlg",
      "id": 813911,
      "node_id": "MDQ6VXNlcjgxMzkxMQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/813911?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vincentlg",
      "html_url": "https://github.com/vincentlg",
      "followers_url": "https://api.github.com/users/vincentlg/followers",
      "following_url": "https://api.github.com/users/vincentlg/following{/other_user}",
      "gists_url": "https://api.github.com/users/vincentlg/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vincentlg/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vincentlg/subscriptions",
      "organizations_url": "https://api.github.com/users/vincentlg/orgs",
      "repos_url": "https://api.github.com/users/vincentlg/repos",
      "events_url": "https://api.github.com/users/vincentlg/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vincentlg/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-04-17T12:22:06Z",
    "updated_at": "2020-04-17T12:24:15Z",
    "author_association": "NONE",
    "body": "Thank you for this initiative üëè \r\nAll this work is absolutely necessary to standardize the way of relaying meta-transactions.\r\nWe are thinking about using it for our relay, it meets 90% of our needs. We already have some feedback / questions.\r\n\r\n**About innerMessageHash**\r\nI understand the benefits of delegating the logic of refund to the Dapp but this has some drawbacks in my opinion.\r\nAt first glance, this mechanism is not easy to understand. Fortunately the example of implementation in EIP1776 allowed us to see how to use the innerMessageHash for gas refund. It is a very flexible mechanism but we can consider that this challenge may be resolved by the relay. Can you give other use cases for innerMessageHash (other than gas refund) ? Are there any other benefits to innerMessageHash than avoiding having two messages, one for the forwarder and one for metaTx mechanism ?\r\n\r\n**About the replay protection**\r\nThe use of batchId and batchNonce to explain the multidimensional nonce was little confusing. The term batch may suggest something with an end, with a limited number of transactions.\r\nBut in this case, it‚Äôs more like a channel or a slot that you can use to send concurrent transactions.\r\nFurthermore, Batch is also used for batch execution via a transaction array. Are these two notions linked? ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/615214250/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/628385620",
    "html_url": "https://github.com/ethereum/EIPs/issues/2585#issuecomment-628385620",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/2585",
    "id": 628385620,
    "node_id": "MDEyOklzc3VlQ29tbWVudDYyODM4NTYyMA==",
    "user": {
      "login": "Nipol",
      "id": 693461,
      "node_id": "MDQ6VXNlcjY5MzQ2MQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/693461?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Nipol",
      "html_url": "https://github.com/Nipol",
      "followers_url": "https://api.github.com/users/Nipol/followers",
      "following_url": "https://api.github.com/users/Nipol/following{/other_user}",
      "gists_url": "https://api.github.com/users/Nipol/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Nipol/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Nipol/subscriptions",
      "organizations_url": "https://api.github.com/users/Nipol/orgs",
      "repos_url": "https://api.github.com/users/Nipol/repos",
      "events_url": "https://api.github.com/users/Nipol/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Nipol/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-05-14T04:53:42Z",
    "updated_at": "2020-05-14T04:53:42Z",
    "author_association": "NONE",
    "body": "I'm not sure if `SignatureType` is a good way to distinguish EIP-1271(#1271) and EIP-1654(#1654), or if EIP-165(#165) is the right way to check the interface.\r\nI think this simply distinguishes which interface to use.\r\nHowever, Wallet service providers such as `Gnosis Safe`, `Argent`, and `Authereum` do not implement EIP-165. üò¢\r\n\r\nExample-implemented, `SignatureType` is subtly out of the question for this EIP.\r\nRelayer must deduce `SignatureType` in Off-chain. I think these specifications should be fully validated in on-chain.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/628385620/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/644419523",
    "html_url": "https://github.com/ethereum/EIPs/issues/2585#issuecomment-644419523",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/2585",
    "id": 644419523,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY0NDQxOTUyMw==",
    "user": {
      "login": "wighawag",
      "id": 790580,
      "node_id": "MDQ6VXNlcjc5MDU4MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/790580?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/wighawag",
      "html_url": "https://github.com/wighawag",
      "followers_url": "https://api.github.com/users/wighawag/followers",
      "following_url": "https://api.github.com/users/wighawag/following{/other_user}",
      "gists_url": "https://api.github.com/users/wighawag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/wighawag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/wighawag/subscriptions",
      "organizations_url": "https://api.github.com/users/wighawag/orgs",
      "repos_url": "https://api.github.com/users/wighawag/repos",
      "events_url": "https://api.github.com/users/wighawag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/wighawag/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-06-15T22:20:04Z",
    "updated_at": "2020-06-15T22:20:04Z",
    "author_association": "CONTRIBUTOR",
    "body": "Hi @vincentlg and @Nipol thanks for your comments and sorry for the delay\r\n\r\n@vincentlg I agree that batchId and BatchNonce are misleading\r\nre innerMessageHash, this gives flexibility to the forwarder that can support its own EIP-712 format\r\n\r\nBut I have actually started to think of a different way to achieve full forwarder flexibility. I show cased it in my latest ETHGlobal hackathon : https://github.com/wighawag/gsn-playground/blob/master/contracts/src/MetaTransaction/ForwarderRegistry.sol\r\n\r\nThis uses a  permission-less registry and forwarder can thus use any signature scheme they want, not necessarely EIP-712. Plus if we come up with a minimal metatx standard for forwarder, the registrry use is up to the receiver.\r\n\r\n\r\n@Nipol I think the signature type can be safely guessed off-chain. What would be the benefit of figuring it out on-chain ? This could also be part of the EIP-712 message parameters so the relayer would be forced to pass the intended value\r\n\r\n\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/644419523/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/703513085",
    "html_url": "https://github.com/ethereum/EIPs/issues/2585#issuecomment-703513085",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/2585",
    "id": 703513085,
    "node_id": "MDEyOklzc3VlQ29tbWVudDcwMzUxMzA4NQ==",
    "user": {
      "login": "yashnaman",
      "id": 35137891,
      "node_id": "MDQ6VXNlcjM1MTM3ODkx",
      "avatar_url": "https://avatars.githubusercontent.com/u/35137891?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/yashnaman",
      "html_url": "https://github.com/yashnaman",
      "followers_url": "https://api.github.com/users/yashnaman/followers",
      "following_url": "https://api.github.com/users/yashnaman/following{/other_user}",
      "gists_url": "https://api.github.com/users/yashnaman/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/yashnaman/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/yashnaman/subscriptions",
      "organizations_url": "https://api.github.com/users/yashnaman/orgs",
      "repos_url": "https://api.github.com/users/yashnaman/repos",
      "events_url": "https://api.github.com/users/yashnaman/events{/privacy}",
      "received_events_url": "https://api.github.com/users/yashnaman/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-10-05T09:23:43Z",
    "updated_at": "2020-10-05T09:23:43Z",
    "author_association": "NONE",
    "body": "Is this forwarder on mainnet?\r\nIf not is there similar forwarder that uses different standard and is already on mainnet?\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/703513085/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/703542523",
    "html_url": "https://github.com/ethereum/EIPs/issues/2585#issuecomment-703542523",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/2585",
    "id": 703542523,
    "node_id": "MDEyOklzc3VlQ29tbWVudDcwMzU0MjUyMw==",
    "user": {
      "login": "wighawag",
      "id": 790580,
      "node_id": "MDQ6VXNlcjc5MDU4MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/790580?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/wighawag",
      "html_url": "https://github.com/wighawag",
      "followers_url": "https://api.github.com/users/wighawag/followers",
      "following_url": "https://api.github.com/users/wighawag/following{/other_user}",
      "gists_url": "https://api.github.com/users/wighawag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/wighawag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/wighawag/subscriptions",
      "organizations_url": "https://api.github.com/users/wighawag/orgs",
      "repos_url": "https://api.github.com/users/wighawag/repos",
      "events_url": "https://api.github.com/users/wighawag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/wighawag/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-10-05T10:24:08Z",
    "updated_at": "2020-10-05T10:24:08Z",
    "author_association": "CONTRIBUTOR",
    "body": "@yashnaman as far as I know there is no deployment of this standard yet.\r\nIt is also worth noting that the contract code published there is still work in progress\r\n\r\nAs for other standards\r\n\r\nthere is a minimal standard (compatible with EIP-2585) here : https://eips.ethereum.org/EIPS/eip-2771\r\n\r\nIf your receiver contract support it, it will be compatible with EIP-2585 or other standard, like GSN v2: https://github.com/ethereum/EIPs/pull/2770\r\n\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/703542523/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/962544733",
    "html_url": "https://github.com/ethereum/EIPs/issues/2585#issuecomment-962544733",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/2585",
    "id": 962544733,
    "node_id": "IC_kwDOAq426M45X0Rd",
    "user": {
      "login": "github-actions[bot]",
      "id": 41898282,
      "node_id": "MDM6Qm90NDE4OTgyODI=",
      "avatar_url": "https://avatars.githubusercontent.com/in/15368?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/github-actions%5Bbot%5D",
      "html_url": "https://github.com/apps/github-actions",
      "followers_url": "https://api.github.com/users/github-actions%5Bbot%5D/followers",
      "following_url": "https://api.github.com/users/github-actions%5Bbot%5D/following{/other_user}",
      "gists_url": "https://api.github.com/users/github-actions%5Bbot%5D/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/github-actions%5Bbot%5D/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/github-actions%5Bbot%5D/subscriptions",
      "organizations_url": "https://api.github.com/users/github-actions%5Bbot%5D/orgs",
      "repos_url": "https://api.github.com/users/github-actions%5Bbot%5D/repos",
      "events_url": "https://api.github.com/users/github-actions%5Bbot%5D/events{/privacy}",
      "received_events_url": "https://api.github.com/users/github-actions%5Bbot%5D/received_events",
      "type": "Bot",
      "site_admin": false
    },
    "created_at": "2021-11-07T03:11:14Z",
    "updated_at": "2021-11-07T03:11:14Z",
    "author_association": "NONE",
    "body": "There has been no activity on this issue for two months. It will be closed in a week if no further activity occurs. If you would like to move this EIP forward, please respond to any outstanding feedback or add a comment indicating that you have addressed all required feedback and are ready for a review.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/962544733/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/974747960",
    "html_url": "https://github.com/ethereum/EIPs/issues/2585#issuecomment-974747960",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/2585",
    "id": 974747960,
    "node_id": "IC_kwDOAq426M46GXk4",
    "user": {
      "login": "github-actions[bot]",
      "id": 41898282,
      "node_id": "MDM6Qm90NDE4OTgyODI=",
      "avatar_url": "https://avatars.githubusercontent.com/in/15368?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/github-actions%5Bbot%5D",
      "html_url": "https://github.com/apps/github-actions",
      "followers_url": "https://api.github.com/users/github-actions%5Bbot%5D/followers",
      "following_url": "https://api.github.com/users/github-actions%5Bbot%5D/following{/other_user}",
      "gists_url": "https://api.github.com/users/github-actions%5Bbot%5D/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/github-actions%5Bbot%5D/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/github-actions%5Bbot%5D/subscriptions",
      "organizations_url": "https://api.github.com/users/github-actions%5Bbot%5D/orgs",
      "repos_url": "https://api.github.com/users/github-actions%5Bbot%5D/repos",
      "events_url": "https://api.github.com/users/github-actions%5Bbot%5D/events{/privacy}",
      "received_events_url": "https://api.github.com/users/github-actions%5Bbot%5D/received_events",
      "type": "Bot",
      "site_admin": false
    },
    "created_at": "2021-11-21T03:11:29Z",
    "updated_at": "2021-11-21T03:11:29Z",
    "author_association": "NONE",
    "body": "This issue was closed due to inactivity. If you are still pursuing it, feel free to reopen it and respond to any feedback or request a review in a comment.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/974747960/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
