{
  "url": "https://api.github.com/repos/ethereum/EIPs/issues/662",
  "repository_url": "https://api.github.com/repos/ethereum/EIPs",
  "labels_url": "https://api.github.com/repos/ethereum/EIPs/issues/662/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/EIPs/issues/662/comments",
  "events_url": "https://api.github.com/repos/ethereum/EIPs/issues/662/events",
  "html_url": "https://github.com/ethereum/EIPs/issues/662",
  "id": 240206811,
  "node_id": "MDU6SXNzdWUyNDAyMDY4MTE=",
  "number": 662,
  "title": "Standard Functions for Preauthorized Actions",
  "user": {
    "login": "alex-miller-0",
    "id": 7378490,
    "node_id": "MDQ6VXNlcjczNzg0OTA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/7378490?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/alex-miller-0",
    "html_url": "https://github.com/alex-miller-0",
    "followers_url": "https://api.github.com/users/alex-miller-0/followers",
    "following_url": "https://api.github.com/users/alex-miller-0/following{/other_user}",
    "gists_url": "https://api.github.com/users/alex-miller-0/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/alex-miller-0/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/alex-miller-0/subscriptions",
    "organizations_url": "https://api.github.com/users/alex-miller-0/orgs",
    "repos_url": "https://api.github.com/users/alex-miller-0/repos",
    "events_url": "https://api.github.com/users/alex-miller-0/events{/privacy}",
    "received_events_url": "https://api.github.com/users/alex-miller-0/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 2328627851,
      "node_id": "MDU6TGFiZWwyMzI4NjI3ODUx",
      "url": "https://api.github.com/repos/ethereum/EIPs/labels/stale",
      "name": "stale",
      "color": "000000",
      "default": false,
      "description": ""
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 48,
  "created_at": "2017-07-03T15:33:16Z",
  "updated_at": "2022-01-16T00:44:06Z",
  "closed_at": "2022-01-16T00:44:06Z",
  "author_association": "NONE",
  "active_lock_reason": null,
  "body": "### Title\r\n\r\n    EIP: 662\r\n    Title: Standard Functions for Preauthorized Actions\r\n    Author: Alex Miller\r\n    Created: 2017-07-01\r\n    Version: 5\r\n\r\n### Specification\r\n\r\n[EIP661](https://github.com/ethereum/EIPs/issues/661#issuecomment-312654905) is abstracted to include any stateful function.\r\n\r\nA function is defined name `provable_X`, where `X` can be any state-updating function.\r\n\r\n*Note: The underscore is used to retain casing of the original function name.*\r\n\r\nThis function may be executed by any actor with the correct parameters on the owner's behalf. It returns `true` if the state was successfully updated and `false` otherwise. The function may also be called locally to ensure a valid signature was passed or called.\r\n\r\n**Using provable functions**\r\n\r\nA hashed message is formed according to the following:\r\n\r\n\r\n    proof = sha3(sha3(...params), word, contract_address)\r\n\r\n\r\nWhere `sha3` is the keccak-256 sha3 hash, `...params` are the tightly packed parameters of the *original* function, `word` is the ABI definition of the *provable* function, and `contract_address` is the address of the contract where both the original and provable functions reside.\r\n\r\nThis message is signed by a user's private key and that signature can be passed by any Ethereum actor to the provable function as the first parameter.\r\n\r\n**Example**\r\n\r\nAn example for ERC20's `transfer` function is as follows:\r\n\r\n    function provable_transfer(bytes32[3] sig, address to, uint value) returns (bool) {\r\n      // First 4 bytes of keccak-256 hash of \"transfer(bytes32[3],address,uint256)\"\r\n      bytes4 word = 0x5a43675c;\r\n      bytes32 msg = sha3(sha3(address(to), uint(value)), bytes4(word), address(this), uint(nonce));\r\n      address signer = ecrecover(msg, uint8(data[2]), data[0], data[1]); \r\n      uint nonce = nonces[signer];\r\n   \r\n      if (played[signer][msg] == true) { return false; }\r\n\r\n      // Execute the original transfer function\r\n      balances[signer] = safeSub(balances[signer], value);\r\n      balances[to] = safeAdd(balances[to], value);\r\n      Transfer(signer, to, value );\r\n\r\n      // Update state variables\r\n      played[signer][msg] = true;\r\n      nonces[signer] += 1;\r\n      \r\n      return true;\r\n    }\r\n\r\nThe first parameter is an array where the following is true:\r\n\r\n    sig[1]    r of signature\r\n    sig[2]    s of signature\r\n    sig[3]    v of signature\r\n\r\nReplay protection is added by checking the proof against an archived mapping and using nonces, which increment automatically for each signer:\r\n  \r\n    mapping(address => mapping(bytes32 => bool)) played;\r\n    mapping(address => uint) nonces;\r\n\r\n\r\n### Rationale\r\n\r\nThese provable functions may be useful for applications that wish to call functions on the user's behalf without the user having to make a transaction. This would pass the gas cost on to the application.\r\n\r\nThe proposed methodology might be especially useful for 3rd-party token transfers, as this requires two transactions (the user must first `approve` some contract to move tokens and then that contract must be called to move the tokens). \r\n\r\nHowever, this can be further extended to many non-token use cases. The proposed `provable_X` may be included with any function that the application wishes to be outsourced.\r\n",
  "closed_by": {
    "login": "github-actions[bot]",
    "id": 41898282,
    "node_id": "MDM6Qm90NDE4OTgyODI=",
    "avatar_url": "https://avatars.githubusercontent.com/in/15368?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/github-actions%5Bbot%5D",
    "html_url": "https://github.com/apps/github-actions",
    "followers_url": "https://api.github.com/users/github-actions%5Bbot%5D/followers",
    "following_url": "https://api.github.com/users/github-actions%5Bbot%5D/following{/other_user}",
    "gists_url": "https://api.github.com/users/github-actions%5Bbot%5D/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/github-actions%5Bbot%5D/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/github-actions%5Bbot%5D/subscriptions",
    "organizations_url": "https://api.github.com/users/github-actions%5Bbot%5D/orgs",
    "repos_url": "https://api.github.com/users/github-actions%5Bbot%5D/repos",
    "events_url": "https://api.github.com/users/github-actions%5Bbot%5D/events{/privacy}",
    "received_events_url": "https://api.github.com/users/github-actions%5Bbot%5D/received_events",
    "type": "Bot",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/662/reactions",
    "total_count": 13,
    "+1": 13,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/EIPs/issues/662/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/312691048",
    "html_url": "https://github.com/ethereum/EIPs/issues/662#issuecomment-312691048",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/662",
    "id": 312691048,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxMjY5MTA0OA==",
    "user": {
      "login": "emansipater",
      "id": 4242428,
      "node_id": "MDQ6VXNlcjQyNDI0Mjg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4242428?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/emansipater",
      "html_url": "https://github.com/emansipater",
      "followers_url": "https://api.github.com/users/emansipater/followers",
      "following_url": "https://api.github.com/users/emansipater/following{/other_user}",
      "gists_url": "https://api.github.com/users/emansipater/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/emansipater/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/emansipater/subscriptions",
      "organizations_url": "https://api.github.com/users/emansipater/orgs",
      "repos_url": "https://api.github.com/users/emansipater/repos",
      "events_url": "https://api.github.com/users/emansipater/events{/privacy}",
      "received_events_url": "https://api.github.com/users/emansipater/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-07-03T16:41:42Z",
    "updated_at": "2017-07-03T16:41:42Z",
    "author_association": "NONE",
    "body": "There are a lot more contracts than just ERC20 that will want to make use of this approach (multisig is an obvious example).  Perhaps this should be made more general?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/312691048/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/312693065",
    "html_url": "https://github.com/ethereum/EIPs/issues/662#issuecomment-312693065",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/662",
    "id": 312693065,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxMjY5MzA2NQ==",
    "user": {
      "login": "alex-miller-0",
      "id": 7378490,
      "node_id": "MDQ6VXNlcjczNzg0OTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7378490?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alex-miller-0",
      "html_url": "https://github.com/alex-miller-0",
      "followers_url": "https://api.github.com/users/alex-miller-0/followers",
      "following_url": "https://api.github.com/users/alex-miller-0/following{/other_user}",
      "gists_url": "https://api.github.com/users/alex-miller-0/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alex-miller-0/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alex-miller-0/subscriptions",
      "organizations_url": "https://api.github.com/users/alex-miller-0/orgs",
      "repos_url": "https://api.github.com/users/alex-miller-0/repos",
      "events_url": "https://api.github.com/users/alex-miller-0/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alex-miller-0/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-07-03T16:52:37Z",
    "updated_at": "2017-07-03T16:52:37Z",
    "author_association": "NONE",
    "body": "Updated the EIP. I agree, it could be generalized beyond ERC20. Any stateful function could be outsourced with this standard.\r\n\r\nAlso updated naming convention. I imagine a 2nd layer application could look up whether a stateful function is extended by searching for `isProvable_X`, retaining the case of the original function.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/312693065/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/312709604",
    "html_url": "https://github.com/ethereum/EIPs/issues/662#issuecomment-312709604",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/662",
    "id": 312709604,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxMjcwOTYwNA==",
    "user": {
      "login": "alexvandesande",
      "id": 112898,
      "node_id": "MDQ6VXNlcjExMjg5OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/112898?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alexvandesande",
      "html_url": "https://github.com/alexvandesande",
      "followers_url": "https://api.github.com/users/alexvandesande/followers",
      "following_url": "https://api.github.com/users/alexvandesande/following{/other_user}",
      "gists_url": "https://api.github.com/users/alexvandesande/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alexvandesande/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alexvandesande/subscriptions",
      "organizations_url": "https://api.github.com/users/alexvandesande/orgs",
      "repos_url": "https://api.github.com/users/alexvandesande/repos",
      "events_url": "https://api.github.com/users/alexvandesande/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alexvandesande/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-07-03T18:27:59Z",
    "updated_at": "2017-07-03T18:29:26Z",
    "author_association": "NONE",
    "body": "I'm not sure about the term \"provable\". I think \"offline signed\" or \"off chain signed\" transactions would be a better description?\r\n\r\nIn the particular token transfer case (which I think it's a great way to start the debate), I'd argue for a refactor, because now we have three functions that transfer tokens: `transfer`, `transferFrom` and this one. Then maybe it would be better that there should be an internal function to do the transfers and all the other functions would just be checking permissions.\r\n\r\nAlso I'd suggest adding a `fee` function to the proof: this would allow the original signer to post it to a public pool of transactions and then multiple services could compete to be the firsts to pick up and send the transaction and be paid in the tokens themselves.\r\n\r\n*Finally*, what prevents proofs to be submitted multiple times? Maybe the contract should keep a record of submitted transactions to make sure they are not submitted over and over.\r\n\r\n\r\n```\r\n// Execute the original transfer function\r\nfunction internal transfer(_from, _to, _value) {\r\n  balances[_from] = safeSub(balances[_from], _value);\r\n  balances[_to] = safeAdd(balances[_to], _value);\r\n  Transfer(owner, to, value );\r\n}\r\n\r\n// Checks if the owner has a balance and then transfers\r\nfunction transfer(_to, _value) {\r\n    require(balanceOf[_from] > _value)\r\n    transfer(msg.sender, _to, _value)\r\n}\r\n\r\n// Checks if the owner has authorization and then transfers\r\nfunction transferFrom(_from, _to, _value) {\r\n    require(allowance[msg,sender][_from] > _value);\r\n    require(balanceOf[_from] > _value);\r\n    transfer(msg.sender, _to, _value)\r\n}\r\n// Checks if the signed proof then transfers\r\nfunction signedTransfer(address sender, bytes32[3] data, uint8 v, address to, uint value, uint fee) constant returns (bool) {\r\n   // do all the proof checking here and remember this proof as submitted\r\n   proofSubmitted[proof] = true;\r\n    // If correct transfer value\r\n    transfer(sender, _to, _value);\r\n   // Pay fee in this currency to sender of this transaction\r\n    transfer(sender, msg.owner, fee);\r\n}\r\n\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/312709604/reactions",
      "total_count": 8,
      "+1": 6,
      "-1": 0,
      "laugh": 0,
      "hooray": 2,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/312725602",
    "html_url": "https://github.com/ethereum/EIPs/issues/662#issuecomment-312725602",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/662",
    "id": 312725602,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxMjcyNTYwMg==",
    "user": {
      "login": "christianlundkvist",
      "id": 6892901,
      "node_id": "MDQ6VXNlcjY4OTI5MDE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6892901?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/christianlundkvist",
      "html_url": "https://github.com/christianlundkvist",
      "followers_url": "https://api.github.com/users/christianlundkvist/followers",
      "following_url": "https://api.github.com/users/christianlundkvist/following{/other_user}",
      "gists_url": "https://api.github.com/users/christianlundkvist/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/christianlundkvist/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/christianlundkvist/subscriptions",
      "organizations_url": "https://api.github.com/users/christianlundkvist/orgs",
      "repos_url": "https://api.github.com/users/christianlundkvist/repos",
      "events_url": "https://api.github.com/users/christianlundkvist/events{/privacy}",
      "received_events_url": "https://api.github.com/users/christianlundkvist/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-07-03T20:11:53Z",
    "updated_at": "2017-07-03T20:11:53Z",
    "author_association": "NONE",
    "body": "Cool stuff @alex-miller-0!\r\n\r\nIt's very close to what we've been working on at uPort - basically a service that can pay gas on behalf of the user and execute any Ethereum transaction through a user-controlled Proxy contract.\r\n\r\nMain idea is to separate the paying of gas from access control:\r\n\r\nhttps://github.com/uport-project/uport-identity/pull/38",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/312725602/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/312732117",
    "html_url": "https://github.com/ethereum/EIPs/issues/662#issuecomment-312732117",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/662",
    "id": 312732117,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxMjczMjExNw==",
    "user": {
      "login": "alex-miller-0",
      "id": 7378490,
      "node_id": "MDQ6VXNlcjczNzg0OTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7378490?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alex-miller-0",
      "html_url": "https://github.com/alex-miller-0",
      "followers_url": "https://api.github.com/users/alex-miller-0/followers",
      "following_url": "https://api.github.com/users/alex-miller-0/following{/other_user}",
      "gists_url": "https://api.github.com/users/alex-miller-0/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alex-miller-0/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alex-miller-0/subscriptions",
      "organizations_url": "https://api.github.com/users/alex-miller-0/orgs",
      "repos_url": "https://api.github.com/users/alex-miller-0/repos",
      "events_url": "https://api.github.com/users/alex-miller-0/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alex-miller-0/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-07-03T20:55:09Z",
    "updated_at": "2017-07-03T20:55:09Z",
    "author_association": "NONE",
    "body": "> an internal function to do the transfers and all the other functions would just be checking permissions.\r\n\r\nAgreed. I like your implementation.\r\n\r\n> Also I'd suggest adding a fee function to the proof\r\n\r\nThis limits the spec to token transfers though, since you wouldn't be able to pay ether for outsourced transaction calls.\r\n\r\n> what prevents proofs to be submitted multiple times\r\n\r\nYeah, forgot to include replay protection. What about something like the following:\r\n\r\n    function provable_transfer(address owner, bytes32[3] data, uint8 v, uint expiration, address to, uint value) returns (bool) {\r\n      // First 4 bytes of keccak-256 hash of \"transfer\"\r\n      bytes4 word = 0xb483afd3;\r\n\r\n      address signer = ecrecover(data[0], v, data[1], data[2]);\r\n      if (signer != owner) { return false; }\r\n\r\n      // Hash of the word, address of this contract, and all params of original function\r\n      bytes32 proof = sha3(word, address(this), expiration, to, value);\r\n      if (proof != data[0]) { return false; }\r\n      else if (expiration < now) { return false; }\r\n      else if (played[proof] == true) { return false; }\r\n\r\n      // Execute the original transfer function\r\n      balances[owner] = safeSub(balances[owner], value);\r\n      balances[to] = safeAdd(balances[to], value);\r\n      Transfer(owner, to, value );\r\n      played[proof] = true;\r\n\r\n      return true;\r\n    }\r\n\r\nIt would limit the spec to only functions with <4 parameters - not sure how useful that is.\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/312732117/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/312732518",
    "html_url": "https://github.com/ethereum/EIPs/issues/662#issuecomment-312732518",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/662",
    "id": 312732518,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxMjczMjUxOA==",
    "user": {
      "login": "alex-miller-0",
      "id": 7378490,
      "node_id": "MDQ6VXNlcjczNzg0OTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7378490?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alex-miller-0",
      "html_url": "https://github.com/alex-miller-0",
      "followers_url": "https://api.github.com/users/alex-miller-0/followers",
      "following_url": "https://api.github.com/users/alex-miller-0/following{/other_user}",
      "gists_url": "https://api.github.com/users/alex-miller-0/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alex-miller-0/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alex-miller-0/subscriptions",
      "organizations_url": "https://api.github.com/users/alex-miller-0/orgs",
      "repos_url": "https://api.github.com/users/alex-miller-0/repos",
      "events_url": "https://api.github.com/users/alex-miller-0/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alex-miller-0/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-07-03T20:57:55Z",
    "updated_at": "2017-07-03T20:57:55Z",
    "author_association": "NONE",
    "body": "Aragon has a [function](https://github.com/aragon/aragon-core/blob/master/contracts/kernel/Kernel.sol#L52) that does what this spec is proposing. Note the arbitrarily sized `bytes` array.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/312732518/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/312736213",
    "html_url": "https://github.com/ethereum/EIPs/issues/662#issuecomment-312736213",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/662",
    "id": 312736213,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxMjczNjIxMw==",
    "user": {
      "login": "alexvandesande",
      "id": 112898,
      "node_id": "MDQ6VXNlcjExMjg5OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/112898?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alexvandesande",
      "html_url": "https://github.com/alexvandesande",
      "followers_url": "https://api.github.com/users/alexvandesande/followers",
      "following_url": "https://api.github.com/users/alexvandesande/following{/other_user}",
      "gists_url": "https://api.github.com/users/alexvandesande/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alexvandesande/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alexvandesande/subscriptions",
      "organizations_url": "https://api.github.com/users/alexvandesande/orgs",
      "repos_url": "https://api.github.com/users/alexvandesande/repos",
      "events_url": "https://api.github.com/users/alexvandesande/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alexvandesande/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-07-03T21:24:33Z",
    "updated_at": "2017-07-03T21:24:33Z",
    "author_association": "NONE",
    "body": "@alex-miller-0 \r\n\r\nAragon does it in an interesting way. The problem with making arbitrary data calls is that the msg.sender will always be the transaction sender, not the message signer.\r\n\r\n> This limits the spec to token transfers though, since you wouldn't be able to pay ether for outsourced transaction calls.\r\n\r\nThat's true. But in any way you build it you'd need to have custom functions for it. We could have a generic token function that would send X tokens to msg.sender but then it would only make sense in this context. Other option is for the contract itself to calculate the fee on other factors (adjust fees to target a delay no longer than X minutes)\r\n\r\nI think this shows that many projects are implementing basically the same ideas in different ways, and while it's encouraging to see different approaches, it means that some standardization would be very useful here. So the suggested pattern would be:\r\n\r\n1) Contract separates core functions (token transfers) from access functions (who and how can someone initiate a token transfer)\r\n\r\n2) Contract implements basic access controls (send token from msg.sender) and pre-auth access control (send token on behalf of signer)\r\n\r\n3) User signs message\r\n\r\n4) User shares message on whisper (or some other service)\r\n\r\n5) Transaction relayers compete to post messages to chain\r\n\r\n6) Optionally, contract rewards them for it somehow, either with ether directly or if a token contract, with tokens",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/312736213/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/312747278",
    "html_url": "https://github.com/ethereum/EIPs/issues/662#issuecomment-312747278",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/662",
    "id": 312747278,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxMjc0NzI3OA==",
    "user": {
      "login": "AlexeyAkhunov",
      "id": 13686139,
      "node_id": "MDQ6VXNlcjEzNjg2MTM5",
      "avatar_url": "https://avatars.githubusercontent.com/u/13686139?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/AlexeyAkhunov",
      "html_url": "https://github.com/AlexeyAkhunov",
      "followers_url": "https://api.github.com/users/AlexeyAkhunov/followers",
      "following_url": "https://api.github.com/users/AlexeyAkhunov/following{/other_user}",
      "gists_url": "https://api.github.com/users/AlexeyAkhunov/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/AlexeyAkhunov/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/AlexeyAkhunov/subscriptions",
      "organizations_url": "https://api.github.com/users/AlexeyAkhunov/orgs",
      "repos_url": "https://api.github.com/users/AlexeyAkhunov/repos",
      "events_url": "https://api.github.com/users/AlexeyAkhunov/events{/privacy}",
      "received_events_url": "https://api.github.com/users/AlexeyAkhunov/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-07-03T23:04:31Z",
    "updated_at": "2017-07-03T23:04:31Z",
    "author_association": "CONTRIBUTOR",
    "body": "You need to also include some kind of nonce-mechanism to prevent using the same signed transfer multiple times. I am not sure what the mechanism should be, but I guess this is where it becomes tricky",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/312747278/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/312809915",
    "html_url": "https://github.com/ethereum/EIPs/issues/662#issuecomment-312809915",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/662",
    "id": 312809915,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxMjgwOTkxNQ==",
    "user": {
      "login": "izqui",
      "id": 447328,
      "node_id": "MDQ6VXNlcjQ0NzMyOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/447328?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/izqui",
      "html_url": "https://github.com/izqui",
      "followers_url": "https://api.github.com/users/izqui/followers",
      "following_url": "https://api.github.com/users/izqui/following{/other_user}",
      "gists_url": "https://api.github.com/users/izqui/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/izqui/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/izqui/subscriptions",
      "organizations_url": "https://api.github.com/users/izqui/orgs",
      "repos_url": "https://api.github.com/users/izqui/repos",
      "events_url": "https://api.github.com/users/izqui/events{/privacy}",
      "received_events_url": "https://api.github.com/users/izqui/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-07-04T08:05:57Z",
    "updated_at": "2017-07-04T08:05:57Z",
    "author_association": "CONTRIBUTOR",
    "body": "AFAIK the `address owner` parameter is redundant as you can always recover it from the signature, in the same way ETH transaction payloads don't have the `from` address.\r\n\r\nAlso something that could be interesting to think about is adding a `fee` parameter, that would go to the `msg.sender` of the transaction. This way we incentivize this party to send the token transfer because he is getting back some tokens in return for the ETH fee he had to pay.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/312809915/reactions",
      "total_count": 3,
      "+1": 3,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/312897507",
    "html_url": "https://github.com/ethereum/EIPs/issues/662#issuecomment-312897507",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/662",
    "id": 312897507,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxMjg5NzUwNw==",
    "user": {
      "login": "alex-miller-0",
      "id": 7378490,
      "node_id": "MDQ6VXNlcjczNzg0OTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7378490?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alex-miller-0",
      "html_url": "https://github.com/alex-miller-0",
      "followers_url": "https://api.github.com/users/alex-miller-0/followers",
      "following_url": "https://api.github.com/users/alex-miller-0/following{/other_user}",
      "gists_url": "https://api.github.com/users/alex-miller-0/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alex-miller-0/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alex-miller-0/subscriptions",
      "organizations_url": "https://api.github.com/users/alex-miller-0/orgs",
      "repos_url": "https://api.github.com/users/alex-miller-0/repos",
      "events_url": "https://api.github.com/users/alex-miller-0/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alex-miller-0/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-07-04T14:53:06Z",
    "updated_at": "2017-07-04T14:53:06Z",
    "author_association": "NONE",
    "body": "> AFAIK the address owner parameter is redundant as you can always recover it from the signature, in the same way ETH transaction payloads don't have the from address.\r\n\r\nGood point. Removed `owner` and also added replay protection with an archival mapping and expiration timestamp.\r\n\r\nI'm still not sold on the fee parameter. That feels like a separate EIP to me. All I wanted to do here was write a standard for outsourcing transactions. I think the token transfer fee can be its own EIP frankly. What are everyone's thoughts?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/312897507/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/312901210",
    "html_url": "https://github.com/ethereum/EIPs/issues/662#issuecomment-312901210",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/662",
    "id": 312901210,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxMjkwMTIxMA==",
    "user": {
      "login": "GNSPS",
      "id": 4008213,
      "node_id": "MDQ6VXNlcjQwMDgyMTM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4008213?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/GNSPS",
      "html_url": "https://github.com/GNSPS",
      "followers_url": "https://api.github.com/users/GNSPS/followers",
      "following_url": "https://api.github.com/users/GNSPS/following{/other_user}",
      "gists_url": "https://api.github.com/users/GNSPS/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/GNSPS/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/GNSPS/subscriptions",
      "organizations_url": "https://api.github.com/users/GNSPS/orgs",
      "repos_url": "https://api.github.com/users/GNSPS/repos",
      "events_url": "https://api.github.com/users/GNSPS/events{/privacy}",
      "received_events_url": "https://api.github.com/users/GNSPS/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-07-04T15:11:02Z",
    "updated_at": "2017-07-04T15:11:02Z",
    "author_association": "NONE",
    "body": "> I think the token transfer fee can be its own EIP frankly.\r\n\r\nYes, think so too. Mainly because as you put it before:\r\n> However, this can be further extended to many non-token use cases. The proposed provable_X and isProvable_X may be included with any function that the application wishes to be outsourced.\r\n\r\nWhich is way more generalist than what having a `fee` parameter implies.\r\n\r\nI feel `fee` should *either be dropped or the EIP renamed*.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/312901210/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/312903970",
    "html_url": "https://github.com/ethereum/EIPs/issues/662#issuecomment-312903970",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/662",
    "id": 312903970,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxMjkwMzk3MA==",
    "user": {
      "login": "emansipater",
      "id": 4242428,
      "node_id": "MDQ6VXNlcjQyNDI0Mjg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4242428?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/emansipater",
      "html_url": "https://github.com/emansipater",
      "followers_url": "https://api.github.com/users/emansipater/followers",
      "following_url": "https://api.github.com/users/emansipater/following{/other_user}",
      "gists_url": "https://api.github.com/users/emansipater/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/emansipater/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/emansipater/subscriptions",
      "organizations_url": "https://api.github.com/users/emansipater/orgs",
      "repos_url": "https://api.github.com/users/emansipater/repos",
      "events_url": "https://api.github.com/users/emansipater/events{/privacy}",
      "received_events_url": "https://api.github.com/users/emansipater/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-07-04T15:24:30Z",
    "updated_at": "2017-07-17T21:59:30Z",
    "author_association": "NONE",
    "body": "@alex-miller-0 @alexvandesande  last summer when I was putting together something like this for multisig we did replay protection just like Aragon does it, except instead of combining the data itself with a nonce we just used a hash.  So the part actually signed is:\r\n\r\n`hash(authed_hash, receivingContractAddress, nonce)`\r\n\r\nand that's what gets marked as spent on a per-address basis.  Then the authed_hash is simply marked as having been authorised by the ecrecovered address, and after that point anyone is allowed to call a generic `doAction(function,args[],authorisingAccount)` command which just hashes the first two fields and checks if the hash has been authorised by the third, performing it with that authority if so.  Performed actions are of course marked as no longer authorised.  This has the advantage that you can have a second function `expandActions(hashes[],authorisingAccount)` which just hashes a whole list of hashes and checks if the root hash is authorised, so you can merkle together an entire series of actions and then just sign it once to authorise all of them.\r\n\r\nTo me that approach feels very simple and general.  We could formalise it in an EIP and then just have an index of specific functions for that EIP that ERC20 tokens must support.  If you want things like paying a fee to the publisher of the transaction (or any other complicated feature) it is simple:  add an action that does that to your merkle tree.\r\n\r\n@christianlundkvist I'm not surprised that uport is also doing something like this. Haven't had a chance to read through your approach but would the above make sense in your context as well?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/312903970/reactions",
      "total_count": 3,
      "+1": 3,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/312905208",
    "html_url": "https://github.com/ethereum/EIPs/issues/662#issuecomment-312905208",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/662",
    "id": 312905208,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxMjkwNTIwOA==",
    "user": {
      "login": "alexvandesande",
      "id": 112898,
      "node_id": "MDQ6VXNlcjExMjg5OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/112898?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alexvandesande",
      "html_url": "https://github.com/alexvandesande",
      "followers_url": "https://api.github.com/users/alexvandesande/followers",
      "following_url": "https://api.github.com/users/alexvandesande/following{/other_user}",
      "gists_url": "https://api.github.com/users/alexvandesande/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alexvandesande/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alexvandesande/subscriptions",
      "organizations_url": "https://api.github.com/users/alexvandesande/orgs",
      "repos_url": "https://api.github.com/users/alexvandesande/repos",
      "events_url": "https://api.github.com/users/alexvandesande/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alexvandesande/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-07-04T15:30:54Z",
    "updated_at": "2017-07-04T15:30:54Z",
    "author_association": "NONE",
    "body": "I would argue that fee is not specific to token transfers but could be a general purpose field for any incentivization. In token transfers it could be a token quantity, in other contracts it could sign how much the contract will pay back in ether (from the contract account, which would use its own accounting) or even a general purpose signal of priority (0-10)\n\nEvery contract would interpret it differently, but it makes sense to add it in a general signed execution like that \n\n> On 4 Jul 2017, at 12:24, Jeff Coleman <notifications@github.com> wrote:\n> \n> @alex-miller-0 @alexvandesande last summer when I was putting together something like this for multisig we did replay protection just like Aragon does it, except instead of combining the data itself with a nonce we just used a hash. So the part actually signed is:\n> \n> hash(authed_hash + nonce)\n> \n> and that's what gets marked as spent on a per-address basis. Then the authed_hash is simply marked as having been authorised by the ecrecovered address, and after that point anyone is allowed to call a generic doAction(function,args[],authorisingAccount) command which just hashes the first two fields and checks if the hash has been authorised by the third, performing it with that authority if so. Performed actions are of course marked as no longer authorised. This has the advantage that you can have a second function expandActions(hashes[],authorisingAccount) which just hashes a whole list of hashes and checks if the root hash is authorised, so you can merkle together an entire series of actions and then just sign it once to authorise all of them.\n> \n> To me that approach feels very simple and general. We could formalise it in an EIP and then just have an index of specific functions for that EIP that ERC20 tokens must support. If you want things like paying a fee to the publisher of the transaction (or any other complicated feature) it is simple: add an action that does that to your merkle tree.\n> \n> @christianlundkvist I'm not surprised that uport is also doing something like this. Haven't had a chance to read through your approach but would the above make sense in your context as well?\n> \n> â€”\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub, or mute the thread.\n> \n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/312905208/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/312908092",
    "html_url": "https://github.com/ethereum/EIPs/issues/662#issuecomment-312908092",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/662",
    "id": 312908092,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxMjkwODA5Mg==",
    "user": {
      "login": "emansipater",
      "id": 4242428,
      "node_id": "MDQ6VXNlcjQyNDI0Mjg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4242428?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/emansipater",
      "html_url": "https://github.com/emansipater",
      "followers_url": "https://api.github.com/users/emansipater/followers",
      "following_url": "https://api.github.com/users/emansipater/following{/other_user}",
      "gists_url": "https://api.github.com/users/emansipater/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/emansipater/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/emansipater/subscriptions",
      "organizations_url": "https://api.github.com/users/emansipater/orgs",
      "repos_url": "https://api.github.com/users/emansipater/repos",
      "events_url": "https://api.github.com/users/emansipater/events{/privacy}",
      "received_events_url": "https://api.github.com/users/emansipater/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-07-04T15:44:57Z",
    "updated_at": "2017-07-04T15:44:57Z",
    "author_association": "NONE",
    "body": "Oops, left out a parameter.  It's actually supposed to be:\r\n\r\n`hash(authed_hash, receivingContractAdress, nonce)`\r\n\r\nbecause you want the actions to only be valid for one particular destination contract (in this example, one particular token contract). ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/312908092/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/312914634",
    "html_url": "https://github.com/ethereum/EIPs/issues/662#issuecomment-312914634",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/662",
    "id": 312914634,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxMjkxNDYzNA==",
    "user": {
      "login": "christianlundkvist",
      "id": 6892901,
      "node_id": "MDQ6VXNlcjY4OTI5MDE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6892901?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/christianlundkvist",
      "html_url": "https://github.com/christianlundkvist",
      "followers_url": "https://api.github.com/users/christianlundkvist/followers",
      "following_url": "https://api.github.com/users/christianlundkvist/following{/other_user}",
      "gists_url": "https://api.github.com/users/christianlundkvist/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/christianlundkvist/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/christianlundkvist/subscriptions",
      "organizations_url": "https://api.github.com/users/christianlundkvist/orgs",
      "repos_url": "https://api.github.com/users/christianlundkvist/repos",
      "events_url": "https://api.github.com/users/christianlundkvist/events{/privacy}",
      "received_events_url": "https://api.github.com/users/christianlundkvist/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-07-04T16:23:20Z",
    "updated_at": "2017-07-04T16:23:20Z",
    "author_association": "NONE",
    "body": "@emansipater I really like the idea of having several transactions hashed/merkled together and doing one sig over all of them, very elegant! ðŸ˜ƒ \r\n\r\nThe method that uPort uses involves Proxy contracts, as in https://github.com/ethereum/EIPs/issues/121. \r\n\r\nHere is a brief high-level overview of how uPort does this:\r\n\r\nThe user has a Proxy contract through which all transactions are routed. Another contract (Controller, or IdentityManager) is authorized to tell the Proxy to forward an arbitrary transaction (defined by a tuple `(destination, value, data)`). \r\n\r\nThe IdentityManager has a list of addresses that are authorized to forward transactions. There is a function something like `forwardTx(sigV, sigR, sigS, destination, value, data)` where the signature is over a data set like\r\n\r\n```\r\n(this, nonce, destination, value, data)\r\n```\r\n\r\n(see also here for similar thoughts: https://github.com/ethereum/EIPs/issues/191)\r\n\r\nwhere nonce is a nonce for replay protection. If the signature is by one of the authorized addresses, then the \"metatransaction\" `(destination, value, data)` is forwarded and sent out from the Proxy. The receiving smart contract with address `destination` will see the Proxy address as `msg.sender`, but anyone is able to send the actual ETH transaction and pay for the gas.\r\n\r\nThere are some subtleties here also in that if the function throws, then the `nonce` is not updated. This might lead to narrow cases of replay attacks where an attacker can replay a transaction that previously failed.\r\n\r\n@emansipater In general it seems there are two ways of handling this kind of delegation: either use a proxy contract and have the target smart contract do access control based on `msg.sender`, or have standardized functions in the target smart contract that knows how to interpret these kinds of \"detached signatures\" (as @alex-miller-0 is doing here). \r\n\r\nuPort went with the former (proxy contracts) because it requires less buy-in from smart contract developers - they can just keep using msg.sender as they are used to, and any complex logic can be taken care of by the Proxy/IdentityManager combo. We also have other logic here also like key recovery by using a recovery network etc.\r\n\r\nHaving logic on the smart contract side works as well and I have done a little bit of thinking around that too, but it might take a while to reach a consensus on best practices around this.\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/312914634/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/312916084",
    "html_url": "https://github.com/ethereum/EIPs/issues/662#issuecomment-312916084",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/662",
    "id": 312916084,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxMjkxNjA4NA==",
    "user": {
      "login": "alexvandesande",
      "id": 112898,
      "node_id": "MDQ6VXNlcjExMjg5OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/112898?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alexvandesande",
      "html_url": "https://github.com/alexvandesande",
      "followers_url": "https://api.github.com/users/alexvandesande/followers",
      "following_url": "https://api.github.com/users/alexvandesande/following{/other_user}",
      "gists_url": "https://api.github.com/users/alexvandesande/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alexvandesande/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alexvandesande/subscriptions",
      "organizations_url": "https://api.github.com/users/alexvandesande/orgs",
      "repos_url": "https://api.github.com/users/alexvandesande/repos",
      "events_url": "https://api.github.com/users/alexvandesande/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alexvandesande/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-07-04T16:33:16Z",
    "updated_at": "2017-07-04T16:33:16Z",
    "author_association": "NONE",
    "body": "@emansipater I really like the approach you mention because it can really help scalability and makes transactions cheaper. I would support any approach that makes it more generic like that",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/312916084/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/312917772",
    "html_url": "https://github.com/ethereum/EIPs/issues/662#issuecomment-312917772",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/662",
    "id": 312917772,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxMjkxNzc3Mg==",
    "user": {
      "login": "emansipater",
      "id": 4242428,
      "node_id": "MDQ6VXNlcjQyNDI0Mjg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4242428?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/emansipater",
      "html_url": "https://github.com/emansipater",
      "followers_url": "https://api.github.com/users/emansipater/followers",
      "following_url": "https://api.github.com/users/emansipater/following{/other_user}",
      "gists_url": "https://api.github.com/users/emansipater/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/emansipater/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/emansipater/subscriptions",
      "organizations_url": "https://api.github.com/users/emansipater/orgs",
      "repos_url": "https://api.github.com/users/emansipater/repos",
      "events_url": "https://api.github.com/users/emansipater/events{/privacy}",
      "received_events_url": "https://api.github.com/users/emansipater/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-07-04T16:45:15Z",
    "updated_at": "2017-07-04T16:45:15Z",
    "author_association": "NONE",
    "body": "@alexvandesande yes, this was developed in the context of state channels where each bit of gas has a substantial effect on the final throughput multiplier so that was our aim.\r\n\r\n@christianlundkvist I see the optimal compromise as having this standard and then making the forwarding contracts compliant with it.  That way either approach is possible, depending on whether the destination contract supports it directly or not.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/312917772/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/312933815",
    "html_url": "https://github.com/ethereum/EIPs/issues/662#issuecomment-312933815",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/662",
    "id": 312933815,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxMjkzMzgxNQ==",
    "user": {
      "login": "alex-miller-0",
      "id": 7378490,
      "node_id": "MDQ6VXNlcjczNzg0OTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7378490?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alex-miller-0",
      "html_url": "https://github.com/alex-miller-0",
      "followers_url": "https://api.github.com/users/alex-miller-0/followers",
      "following_url": "https://api.github.com/users/alex-miller-0/following{/other_user}",
      "gists_url": "https://api.github.com/users/alex-miller-0/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alex-miller-0/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alex-miller-0/subscriptions",
      "organizations_url": "https://api.github.com/users/alex-miller-0/orgs",
      "repos_url": "https://api.github.com/users/alex-miller-0/repos",
      "events_url": "https://api.github.com/users/alex-miller-0/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alex-miller-0/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-07-04T18:44:43Z",
    "updated_at": "2017-07-04T18:45:55Z",
    "author_association": "NONE",
    "body": "@emansipater Are you suggesting something like this?\r\n\r\n```\r\nmapping(bytes32 => bool) played;\r\nmapping(address => nonce) nonce;\r\n\r\nfunction provable_transfer(bytes32[3] data, uint8 v, address to, uint value) returns (bool) {\r\n  \r\n  // First 4 bytes of keccak-256 hash of \"transfer\"\r\n  bytes4 word = 0xb483afd3;\r\n\r\n  address signer = ecrecover(data[0], v, data[1], data[2]);\r\n  nonce[signer] += 1;\r\n\r\n  bytes32 proof = sha3(sha3(to, value), word, address(this), nonce[signer]);\r\n  if (proof != data[0]) { return false; }\r\n  else if (played[proof] == true) { return false; }\r\n  played[proof] = true;\r\n\r\n  // Execute the original transfer function\r\n  balances[signer] = safeSub(balances[signer], value);\r\n  balances[to] = safeAdd(balances[to], value);\r\n  Transfer(signer, to, value );\r\n\r\n  return true;\r\n}",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/312933815/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/312955124",
    "html_url": "https://github.com/ethereum/EIPs/issues/662#issuecomment-312955124",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/662",
    "id": 312955124,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxMjk1NTEyNA==",
    "user": {
      "login": "emansipater",
      "id": 4242428,
      "node_id": "MDQ6VXNlcjQyNDI0Mjg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4242428?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/emansipater",
      "html_url": "https://github.com/emansipater",
      "followers_url": "https://api.github.com/users/emansipater/followers",
      "following_url": "https://api.github.com/users/emansipater/following{/other_user}",
      "gists_url": "https://api.github.com/users/emansipater/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/emansipater/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/emansipater/subscriptions",
      "organizations_url": "https://api.github.com/users/emansipater/orgs",
      "repos_url": "https://api.github.com/users/emansipater/repos",
      "events_url": "https://api.github.com/users/emansipater/events{/privacy}",
      "received_events_url": "https://api.github.com/users/emansipater/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-07-04T21:11:25Z",
    "updated_at": "2017-07-12T02:54:24Z",
    "author_association": "NONE",
    "body": "@alex-miller-0  No, more like\r\n\r\n    mapping(bytes32 => bool) played;\r\n    mapping(bytes32 => mapping(address => bool)) authorised;\r\n    \r\n    function submitPreauthorisation(bytes32 authed_hash, bytes32 nonce, uint8 v, bytes32 r, bytes32 s) returns (bool) {\r\n      \r\n      address receivingAddress = address(this);\r\n      bytes32 signedRoot = keccak256(authed_hash, receivingAddress, nonce);\r\n      \r\n      if (played[signedRoot]) {return false;}\r\n      \r\n      address signer = ecrecover(signedRoot, v, r, s);\r\n      if (authorised[authed_hash][signer]) {return false;}\r\n      \r\n      authorised[authed_hash][signer] = true;\r\n      played[signedRoot] = true;\r\n      \r\n      return true;\r\n    }\r\n    \r\n    function doAsAuthorised(bytes function, bytes args[], address authorisedBy) returns (bool) {\r\n      \r\n      bytes32 actionSig = keccak256(function,args[]);\r\n      \r\n      if(authorised[actionSig][authorisedBy] ) {\r\n        doAction(function, args[], authorisedBy);\r\n        timesAuthorised[actionSig][authorisedBy] = false;\r\n        return true;\r\n      }\r\n      \r\n      return false;\r\n      \r\n    }\r\n    \r\n    function expandAuthorisation(bytes32[] hashList, address authorisedBy) returns bool {\r\n      \r\n      if(authorised[keccak256(hashList)][authorisedBy]) {\r\n      \r\n        for(uint i = 0; i < hashList.length, i++) {\r\n          require(authorised[hashList[i]][authorisedBy] != true);\r\n          authorised[hashList[i]][authorisedBy] = true;\r\n        }\r\n      \r\n      authorised[keccak256(hashList)][authorisedBy] = false;\r\n      return true;\r\n      \r\n      }\r\n      \r\n      return false;\r\n      \r\n    }\r\n\r\nif you'll forgive the hastily scribbled frankencode",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/312955124/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/312957878",
    "html_url": "https://github.com/ethereum/EIPs/issues/662#issuecomment-312957878",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/662",
    "id": 312957878,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxMjk1Nzg3OA==",
    "user": {
      "login": "christianlundkvist",
      "id": 6892901,
      "node_id": "MDQ6VXNlcjY4OTI5MDE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6892901?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/christianlundkvist",
      "html_url": "https://github.com/christianlundkvist",
      "followers_url": "https://api.github.com/users/christianlundkvist/followers",
      "following_url": "https://api.github.com/users/christianlundkvist/following{/other_user}",
      "gists_url": "https://api.github.com/users/christianlundkvist/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/christianlundkvist/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/christianlundkvist/subscriptions",
      "organizations_url": "https://api.github.com/users/christianlundkvist/orgs",
      "repos_url": "https://api.github.com/users/christianlundkvist/repos",
      "events_url": "https://api.github.com/users/christianlundkvist/events{/privacy}",
      "received_events_url": "https://api.github.com/users/christianlundkvist/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-07-04T21:31:38Z",
    "updated_at": "2017-07-04T21:31:38Z",
    "author_association": "NONE",
    "body": "@emansipater\r\n\r\n> I see the optimal compromise as having this standard and then making the forwarding contracts compliant with it. That way either approach is possible, depending on whether the destination contract supports it directly or not.\r\n\r\nYep this sounds like the best way :) ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/312957878/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/314128156",
    "html_url": "https://github.com/ethereum/EIPs/issues/662#issuecomment-314128156",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/662",
    "id": 314128156,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxNDEyODE1Ng==",
    "user": {
      "login": "Arachnid",
      "id": 17865,
      "node_id": "MDQ6VXNlcjE3ODY1",
      "avatar_url": "https://avatars.githubusercontent.com/u/17865?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Arachnid",
      "html_url": "https://github.com/Arachnid",
      "followers_url": "https://api.github.com/users/Arachnid/followers",
      "following_url": "https://api.github.com/users/Arachnid/following{/other_user}",
      "gists_url": "https://api.github.com/users/Arachnid/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Arachnid/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Arachnid/subscriptions",
      "organizations_url": "https://api.github.com/users/Arachnid/orgs",
      "repos_url": "https://api.github.com/users/Arachnid/repos",
      "events_url": "https://api.github.com/users/Arachnid/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Arachnid/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-07-10T14:45:25Z",
    "updated_at": "2017-07-10T14:45:25Z",
    "author_association": "MEMBER",
    "body": "> A new stateful function named provable_X, where X can be any state-updating function\r\n> A constant function named isProvable_X, where X can be any state-updating function\r\n\r\nWhat's the purpose of `isProvable_X`? Why not just run the function as a local call to validate it?\r\n\r\n> Note that the first 4 bytes of a word are used to distinguish this stateful function. These are the first 4 bytes of the original function's name, this is importantly not the ABI definition.\r\n\r\nWhy not? That would make a lot more sense. \r\n\r\n> Also note the order of parameters. The first parameter is an array of hashes where the following is true:\r\n> \r\n> h[0]    Hash of tightly packed params\r\n\r\nIt's not necessary to include this, since you can calculate it from the inputs.\r\n\r\n> h[1]    r of signature\r\n> h[2]    s of signature\r\n> The second parameter is the v value of the signature.\r\n\r\nYou could easily make v a third element of the array without increase in ABI encoding length - or make them all individual parameters. The choice to put two in an array and the third separately seems odd.\r\n\r\n> Replay protection is added by checking the proof against an archived mapping:\r\n> \r\n> mapping(bytes32 => bool) played;\r\n\r\nThis requires storage proportional to the number of past executions, which isn't ideal. What about a simple nonce scheme, instead?\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/314128156/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/314131088",
    "html_url": "https://github.com/ethereum/EIPs/issues/662#issuecomment-314131088",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/662",
    "id": 314131088,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxNDEzMTA4OA==",
    "user": {
      "login": "alex-miller-0",
      "id": 7378490,
      "node_id": "MDQ6VXNlcjczNzg0OTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7378490?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alex-miller-0",
      "html_url": "https://github.com/alex-miller-0",
      "followers_url": "https://api.github.com/users/alex-miller-0/followers",
      "following_url": "https://api.github.com/users/alex-miller-0/following{/other_user}",
      "gists_url": "https://api.github.com/users/alex-miller-0/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alex-miller-0/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alex-miller-0/subscriptions",
      "organizations_url": "https://api.github.com/users/alex-miller-0/orgs",
      "repos_url": "https://api.github.com/users/alex-miller-0/repos",
      "events_url": "https://api.github.com/users/alex-miller-0/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alex-miller-0/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-07-10T14:54:34Z",
    "updated_at": "2017-07-10T15:40:23Z",
    "author_association": "NONE",
    "body": "@Arachnid Great comments - thanks.\r\n\r\n> Why not? That would make a lot more sense.\r\n\r\n> Why not just run the function as a local call to validate it?\r\n\r\nAgreed on both. I will change these on the next update.\r\n\r\n> You could easily make v a third element of the array\r\n\r\nCan you show an example? I don't understand how this would work if arrays have to be typed. Unless you just mean a `bytes[]` array?\r\n\r\nEDIT: I actually think you meant something like this:\r\n\r\n```\r\nbytes[3] sig\r\nuint8 v = uint8(sig[2])\r\n```\r\n\r\nIs that correct?\r\n\r\n> This requires storage proportional to the number of past executions, which isn't ideal. What about a simple nonce scheme, instead?\r\n\r\nI agree with the statement, but can't visualize what you are suggesting - will you provide an example?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/314131088/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/314161117",
    "html_url": "https://github.com/ethereum/EIPs/issues/662#issuecomment-314161117",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/662",
    "id": 314161117,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxNDE2MTExNw==",
    "user": {
      "login": "alex-miller-0",
      "id": 7378490,
      "node_id": "MDQ6VXNlcjczNzg0OTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7378490?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alex-miller-0",
      "html_url": "https://github.com/alex-miller-0",
      "followers_url": "https://api.github.com/users/alex-miller-0/followers",
      "following_url": "https://api.github.com/users/alex-miller-0/following{/other_user}",
      "gists_url": "https://api.github.com/users/alex-miller-0/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alex-miller-0/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alex-miller-0/subscriptions",
      "organizations_url": "https://api.github.com/users/alex-miller-0/orgs",
      "repos_url": "https://api.github.com/users/alex-miller-0/repos",
      "events_url": "https://api.github.com/users/alex-miller-0/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alex-miller-0/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-07-10T16:32:54Z",
    "updated_at": "2017-07-10T16:32:54Z",
    "author_association": "NONE",
    "body": "Updated the proposal with some of @Arachnid 's suggestions.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/314161117/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/314170827",
    "html_url": "https://github.com/ethereum/EIPs/issues/662#issuecomment-314170827",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/662",
    "id": 314170827,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxNDE3MDgyNw==",
    "user": {
      "login": "Arachnid",
      "id": 17865,
      "node_id": "MDQ6VXNlcjE3ODY1",
      "avatar_url": "https://avatars.githubusercontent.com/u/17865?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Arachnid",
      "html_url": "https://github.com/Arachnid",
      "followers_url": "https://api.github.com/users/Arachnid/followers",
      "following_url": "https://api.github.com/users/Arachnid/following{/other_user}",
      "gists_url": "https://api.github.com/users/Arachnid/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Arachnid/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Arachnid/subscriptions",
      "organizations_url": "https://api.github.com/users/Arachnid/orgs",
      "repos_url": "https://api.github.com/users/Arachnid/repos",
      "events_url": "https://api.github.com/users/Arachnid/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Arachnid/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-07-10T17:06:02Z",
    "updated_at": "2017-07-10T17:06:02Z",
    "author_association": "MEMBER",
    "body": "> Is that correct?\r\n\r\nYes, that's what I had in mind - though I think that three individual args would work just as well.\r\n\r\n> I agree with the statement, but can't visualize what you are suggesting - will you provide an example?\r\n\r\nIt looks like you already updated the contract to use nonces.\r\n\r\nAs I mentioned earlier, though - you can remove the first element of the data, and simply calculate it. If it's incorrect it will return an invalid sender address, and so will be rejected.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/314170827/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/314180206",
    "html_url": "https://github.com/ethereum/EIPs/issues/662#issuecomment-314180206",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/662",
    "id": 314180206,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxNDE4MDIwNg==",
    "user": {
      "login": "alex-miller-0",
      "id": 7378490,
      "node_id": "MDQ6VXNlcjczNzg0OTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7378490?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alex-miller-0",
      "html_url": "https://github.com/alex-miller-0",
      "followers_url": "https://api.github.com/users/alex-miller-0/followers",
      "following_url": "https://api.github.com/users/alex-miller-0/following{/other_user}",
      "gists_url": "https://api.github.com/users/alex-miller-0/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alex-miller-0/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alex-miller-0/subscriptions",
      "organizations_url": "https://api.github.com/users/alex-miller-0/orgs",
      "repos_url": "https://api.github.com/users/alex-miller-0/repos",
      "events_url": "https://api.github.com/users/alex-miller-0/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alex-miller-0/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-07-10T17:40:54Z",
    "updated_at": "2017-07-10T17:40:54Z",
    "author_association": "NONE",
    "body": "> you can remove the first element of the data, and simply calculate it. If it's incorrect it will return an invalid sender address, and so will be rejected.\r\n\r\nI tried to work this into the example function, but I can't figure out what you mean. Can you provide an example?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/314180206/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/314319819",
    "html_url": "https://github.com/ethereum/EIPs/issues/662#issuecomment-314319819",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/662",
    "id": 314319819,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxNDMxOTgxOQ==",
    "user": {
      "login": "emansipater",
      "id": 4242428,
      "node_id": "MDQ6VXNlcjQyNDI0Mjg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4242428?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/emansipater",
      "html_url": "https://github.com/emansipater",
      "followers_url": "https://api.github.com/users/emansipater/followers",
      "following_url": "https://api.github.com/users/emansipater/following{/other_user}",
      "gists_url": "https://api.github.com/users/emansipater/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/emansipater/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/emansipater/subscriptions",
      "organizations_url": "https://api.github.com/users/emansipater/orgs",
      "repos_url": "https://api.github.com/users/emansipater/repos",
      "events_url": "https://api.github.com/users/emansipater/events{/privacy}",
      "received_events_url": "https://api.github.com/users/emansipater/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-07-11T04:29:55Z",
    "updated_at": "2017-07-11T04:29:55Z",
    "author_association": "NONE",
    "body": "> This requires storage proportional to the number of past executions, which isn't ideal. What about a simple nonce scheme, instead?\r\n\r\nThere's actually a really really good reason **not** to use a nonce scheme, which is that it allows for revoking of previously signed but not yet published messages.  In state channels this is a security exploit, not a feature.  I'll try to think if there's a simple approach that still preserves nonrevocability but doesn't waste so much space on replay prevention--it seems solvable.\r\n\r\nA different, though somewhat related issue is the need for a) atomicity control and b) sequence/dependency control.  In my opinion both of these are well worth including in this EIP.  The first can be solved by just allowing arrays of actions in the doPreauthedAction() and then reverting if any one action fails (whole array is hashed to check whether authorised).  Slightly complicates the parameter array portion but not too bad I think.  It might not be obvious at first glance, but this also solves the second requirement, provided that we provide universal support for an action type which can make assertions about the state of PreauthedActions.  That seems sensical anyways, so these two don't bloat the proposal much at all.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/314319819/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/314322462",
    "html_url": "https://github.com/ethereum/EIPs/issues/662#issuecomment-314322462",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/662",
    "id": 314322462,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxNDMyMjQ2Mg==",
    "user": {
      "login": "emansipater",
      "id": 4242428,
      "node_id": "MDQ6VXNlcjQyNDI0Mjg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4242428?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/emansipater",
      "html_url": "https://github.com/emansipater",
      "followers_url": "https://api.github.com/users/emansipater/followers",
      "following_url": "https://api.github.com/users/emansipater/following{/other_user}",
      "gists_url": "https://api.github.com/users/emansipater/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/emansipater/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/emansipater/subscriptions",
      "organizations_url": "https://api.github.com/users/emansipater/orgs",
      "repos_url": "https://api.github.com/users/emansipater/repos",
      "events_url": "https://api.github.com/users/emansipater/events{/privacy}",
      "received_events_url": "https://api.github.com/users/emansipater/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-07-11T04:52:31Z",
    "updated_at": "2017-07-11T04:52:31Z",
    "author_association": "NONE",
    "body": ">>A new stateful function named provable_X, where X can be any state-updating function\r\n>>A constant function named isProvable_X, where X can be any state-updating function\r\n\r\n>What's the purpose of isProvable_X? Why not just run the function as a local call to validate it?\r\n\r\n>>Note that the first 4 bytes of a word are used to distinguish this stateful function. These are the first 4 bytes of the original function's name, this is importantly not the ABI definition.\r\n\r\n>Why not? That would make a lot more sense.\r\n\r\nHighly agree with both (though I would clarify that this should be for whitelisted local calls only, obviously not arbitrary local calls).  Also @alex-miller-0 can we update the EIP name to \"Standard Functions for Preauthorized Actions\" or something similar?  The current name really is not appropriate--that term provable made sense for your other EIP but not for this one.  I might also add that once this proposal is complete that other EIP proposal can be radically simplified by removing the signature checking etc. that this one will already do and just specifying a standard \"destroyTokens\" function which preauthorisations under this EIP can call.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/314322462/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/314323410",
    "html_url": "https://github.com/ethereum/EIPs/issues/662#issuecomment-314323410",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/662",
    "id": 314323410,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxNDMyMzQxMA==",
    "user": {
      "login": "emansipater",
      "id": 4242428,
      "node_id": "MDQ6VXNlcjQyNDI0Mjg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4242428?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/emansipater",
      "html_url": "https://github.com/emansipater",
      "followers_url": "https://api.github.com/users/emansipater/followers",
      "following_url": "https://api.github.com/users/emansipater/following{/other_user}",
      "gists_url": "https://api.github.com/users/emansipater/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/emansipater/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/emansipater/subscriptions",
      "organizations_url": "https://api.github.com/users/emansipater/orgs",
      "repos_url": "https://api.github.com/users/emansipater/repos",
      "events_url": "https://api.github.com/users/emansipater/events{/privacy}",
      "received_events_url": "https://api.github.com/users/emansipater/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-07-11T05:00:13Z",
    "updated_at": "2017-07-11T05:00:13Z",
    "author_association": "NONE",
    "body": ">I tried to work this into the example function, but I can't figure out what you mean. Can you provide an example?\r\n\r\nHe means that since you are passing the parameters anyways, you don't need to also pass the hash of them.  You can just hash them to recover the hash. If the parameters are altered in any way and you get a different hash than the one which was actually signed, ecrecover will just return a different random sender.  Since that sender will not have authorised anything, the operation will be rejected.  So this is perfectly safe to do--it doesn't introduce any security issues.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/314323410/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/314483530",
    "html_url": "https://github.com/ethereum/EIPs/issues/662#issuecomment-314483530",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/662",
    "id": 314483530,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxNDQ4MzUzMA==",
    "user": {
      "login": "alex-miller-0",
      "id": 7378490,
      "node_id": "MDQ6VXNlcjczNzg0OTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7378490?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alex-miller-0",
      "html_url": "https://github.com/alex-miller-0",
      "followers_url": "https://api.github.com/users/alex-miller-0/followers",
      "following_url": "https://api.github.com/users/alex-miller-0/following{/other_user}",
      "gists_url": "https://api.github.com/users/alex-miller-0/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alex-miller-0/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alex-miller-0/subscriptions",
      "organizations_url": "https://api.github.com/users/alex-miller-0/orgs",
      "repos_url": "https://api.github.com/users/alex-miller-0/repos",
      "events_url": "https://api.github.com/users/alex-miller-0/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alex-miller-0/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-07-11T15:35:19Z",
    "updated_at": "2017-07-11T15:35:19Z",
    "author_association": "NONE",
    "body": "> can we update the EIP name to \"Standard Functions for Preauthorized Actions\" or something similar\r\n\r\nYes. I will rename.\r\n\r\n> He means that...\r\n\r\nThanks - that helps. I will update my tests and update the EIP in a bit.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/314483530/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/314610830",
    "html_url": "https://github.com/ethereum/EIPs/issues/662#issuecomment-314610830",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/662",
    "id": 314610830,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxNDYxMDgzMA==",
    "user": {
      "login": "alex-miller-0",
      "id": 7378490,
      "node_id": "MDQ6VXNlcjczNzg0OTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7378490?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alex-miller-0",
      "html_url": "https://github.com/alex-miller-0",
      "followers_url": "https://api.github.com/users/alex-miller-0/followers",
      "following_url": "https://api.github.com/users/alex-miller-0/following{/other_user}",
      "gists_url": "https://api.github.com/users/alex-miller-0/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alex-miller-0/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alex-miller-0/subscriptions",
      "organizations_url": "https://api.github.com/users/alex-miller-0/orgs",
      "repos_url": "https://api.github.com/users/alex-miller-0/repos",
      "events_url": "https://api.github.com/users/alex-miller-0/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alex-miller-0/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-07-12T00:37:03Z",
    "updated_at": "2017-07-12T00:37:03Z",
    "author_association": "NONE",
    "body": "Proposal has been updated to include only `v, r, s` as input params.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/314610830/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
