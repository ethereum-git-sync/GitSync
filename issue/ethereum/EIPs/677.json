{
  "url": "https://api.github.com/repos/ethereum/EIPs/issues/677",
  "repository_url": "https://api.github.com/repos/ethereum/EIPs",
  "labels_url": "https://api.github.com/repos/ethereum/EIPs/issues/677/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/EIPs/issues/677/comments",
  "events_url": "https://api.github.com/repos/ethereum/EIPs/issues/677/events",
  "html_url": "https://github.com/ethereum/EIPs/issues/677",
  "id": 244131817,
  "node_id": "MDU6SXNzdWUyNDQxMzE4MTc=",
  "number": 677,
  "title": "ERC: transferAndCall Token Standard",
  "user": {
    "login": "se3000",
    "id": 573827,
    "node_id": "MDQ6VXNlcjU3MzgyNw==",
    "avatar_url": "https://avatars.githubusercontent.com/u/573827?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/se3000",
    "html_url": "https://github.com/se3000",
    "followers_url": "https://api.github.com/users/se3000/followers",
    "following_url": "https://api.github.com/users/se3000/following{/other_user}",
    "gists_url": "https://api.github.com/users/se3000/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/se3000/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/se3000/subscriptions",
    "organizations_url": "https://api.github.com/users/se3000/orgs",
    "repos_url": "https://api.github.com/users/se3000/repos",
    "events_url": "https://api.github.com/users/se3000/events{/privacy}",
    "received_events_url": "https://api.github.com/users/se3000/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [

  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 79,
  "created_at": "2017-07-19T18:27:18Z",
  "updated_at": "2022-07-25T23:26:39Z",
  "closed_at": "2022-05-28T04:59:54Z",
  "author_association": "NONE",
  "active_lock_reason": null,
  "body": "## Preamble\r\n\r\n     ERC: 677\r\n     Title: transferAndCall Token Standard\r\n     Type: Informational\r\n     Category: ERC\r\n     Status: Draft\r\n     Created: 2017-07-17\r\n     Requires: ERC20\r\n\r\n## Simple Summary\r\n\r\nAllow tokens to be transferred to contracts and have the contract trigger logic for how to respond to receiving the tokens within a single transaction.\r\n\r\n## Abstract\r\n\r\nThis adds a new function to [ERC20](https://github.com/ethereum/EIPs/issues/20) token contracts, `transferAndCall` which can be called to transfer tokens to a contract and then call the contract with the additional data provided. Once the token is transferred, the token contract calls the receiving contract's function `onTokenTransfer(address,uint256,bytes)` and triggers an event `Transfer(address,address,uint,bytes)`, following the convention set in [ERC223](https://github.com/ethereum/EIPs/issues/223).\r\n\r\n## Motivation\r\n\r\nERC20 requires a multistep process for tokens to be transferred to a contract. First `approve` must be called on the token contract, enabling the contract to withdraw the tokens. Next, the contract needs to be informed that it has been approved to withdraw tokens. Finally, the contract has to actually withdraw the tokens, and run any code related to receiving tokens. This process typically takes two to three steps, which is inefficient and a poor user experience.\r\n\r\nWhile ERC223 solves the described problem with its `transfer(address,uint256,bytes)` function, it opens other problems. ERC223 changes the behavior of ERC20's `transfer(address,uint256)`, specifying that it should throw if transferring to a contract that does not implement `onTokenTransfer`. This is problematic because there are deployed contracts in use that assume they can safely call `transfer(address,uint256)` to move tokens to their recipient. If one of these deployed contracts were to transfer an ERC223 token to a contract(e.g. a multisig wallet) the tokens would effectively become stuck in the transferring contract.\r\n\r\nThis ERC aims to provide the helpful functionality of ERC223 without colliding with it. By giving contracts a reason to implement `onTokenTransfer` before ERC223 becomes widely implemented, a smooth transition is provided until a larger part of the Ethereum ecosystem is informed about and capable of handling ERC223 tokens. `transferAndCall` behaves similarly to `transfer(address,uint256,bytes)`, but allows implementers to gain the functionality without the risk of inadvertently locking up tokens in non-ERC223 compatible contracts. It is distinct from ERC223's `transfer(address,uint256,bytes)` only in name, but this distinction allows for easy distinguishability between tokens that are ERC223 and tokens that are simply ERC20 + ERC667.\r\n\r\n## Specification\r\n\r\n### Token\r\n#### transferAndCall\r\n```javascript\r\nfunction transferAndCall(address receiver, uint amount, bytes data) returns (bool success)\r\n```\r\nTransfers tokens to `receiver`, via ERC20's `transfer(address,uint256)` function. It then logs an event `Transfer(address,address,uint256,bytes)`. Once the transfer has succeeded and the event is logged, the token calls `onTokenTransfer(address,uint256,bytes)` on the `receiver` with the sender, the amount approved, and additional bytes data as parameters.\r\n\r\n### Receiving Contract\r\n#### onTokenTransfer\r\n```javascript\r\nfunction onTokenTransfer(address from, uint256 amount, bytes data) returns (bool success)\r\n```\r\nThe function is added to contracts enabling them to react to receiving tokens within a single transaction. The `from` parameter is the account which just trasfered `amount` from the `token` contract. `data` is available to pass additional parameters, i.e. to indicate what the intention of the transfer is if a contract allows transfers for multiple reasons.\r\n\r\n## Backwards Compatibility\r\nThis proposal is backwards compatible for all ERC20 tokens and contracts. New tokens and contracts moving forward can implement the `transferAndCall` functionality, but also still fallback to the original `approve`-`transferFrom` workflow when dealing with legacy contracts. It does not require any changes or additional steps from already deployed contracts, but enables future contracts to gain this functionality.\r\n\r\n## Implementation\r\n[Example implementation.](https://github.com/smartcontractkit/LinkToken/blob/master/contracts/v0.4/ERC677Token.sol)",
  "closed_by": {
    "login": "MicahZoltu",
    "id": 886059,
    "node_id": "MDQ6VXNlcjg4NjA1OQ==",
    "avatar_url": "https://avatars.githubusercontent.com/u/886059?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/MicahZoltu",
    "html_url": "https://github.com/MicahZoltu",
    "followers_url": "https://api.github.com/users/MicahZoltu/followers",
    "following_url": "https://api.github.com/users/MicahZoltu/following{/other_user}",
    "gists_url": "https://api.github.com/users/MicahZoltu/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/MicahZoltu/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/MicahZoltu/subscriptions",
    "organizations_url": "https://api.github.com/users/MicahZoltu/orgs",
    "repos_url": "https://api.github.com/users/MicahZoltu/repos",
    "events_url": "https://api.github.com/users/MicahZoltu/events{/privacy}",
    "received_events_url": "https://api.github.com/users/MicahZoltu/received_events",
    "type": "User",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/677/reactions",
    "total_count": 32,
    "+1": 32,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/EIPs/issues/677/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/316743985",
    "html_url": "https://github.com/ethereum/EIPs/issues/677#issuecomment-316743985",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/677",
    "id": 316743985,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxNjc0Mzk4NQ==",
    "user": {
      "login": "Arachnid",
      "id": 17865,
      "node_id": "MDQ6VXNlcjE3ODY1",
      "avatar_url": "https://avatars.githubusercontent.com/u/17865?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Arachnid",
      "html_url": "https://github.com/Arachnid",
      "followers_url": "https://api.github.com/users/Arachnid/followers",
      "following_url": "https://api.github.com/users/Arachnid/following{/other_user}",
      "gists_url": "https://api.github.com/users/Arachnid/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Arachnid/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Arachnid/subscriptions",
      "organizations_url": "https://api.github.com/users/Arachnid/orgs",
      "repos_url": "https://api.github.com/users/Arachnid/repos",
      "events_url": "https://api.github.com/users/Arachnid/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Arachnid/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-07-20T15:42:02Z",
    "updated_at": "2017-07-20T15:42:02Z",
    "author_association": "MEMBER",
    "body": "What calls `receiveApproval`, and in what circumstances?\r\n\r\nI see the point of structuring `approveAndCall` like this for backwards-compatibility reasons, but wouldn't a `transferAndCall` be a better option going forward? With this, you only need a single storage update, instead of two.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/316743985/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/317118992",
    "html_url": "https://github.com/ethereum/EIPs/issues/677#issuecomment-317118992",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/677",
    "id": 317118992,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxNzExODk5Mg==",
    "user": {
      "login": "se3000",
      "id": 573827,
      "node_id": "MDQ6VXNlcjU3MzgyNw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/573827?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/se3000",
      "html_url": "https://github.com/se3000",
      "followers_url": "https://api.github.com/users/se3000/followers",
      "following_url": "https://api.github.com/users/se3000/following{/other_user}",
      "gists_url": "https://api.github.com/users/se3000/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/se3000/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/se3000/subscriptions",
      "organizations_url": "https://api.github.com/users/se3000/orgs",
      "repos_url": "https://api.github.com/users/se3000/repos",
      "events_url": "https://api.github.com/users/se3000/events{/privacy}",
      "received_events_url": "https://api.github.com/users/se3000/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-07-21T21:41:39Z",
    "updated_at": "2017-07-21T21:41:39Z",
    "author_association": "NONE",
    "body": "`receiveApproval` is called by the token contract, from within the `approveAndCall` function after the receiving contract has been approved to withdraw.\r\n\r\nThe reason for not using `transferAndCall` is that it would make it difficult, and often impossible, for the receiving contract to actually verify that tokens had been transferred to it(verifying would either require someone to check logs off chain, or a new API to be introduced). Since this function has to be public in order for tokens to call it, it would be very easy to maliciously call it and tell it that tokens were transferred without actually ever transferring tokens. By making the contract withdraw the tokens itself, the contract ensures that the transfer happens/succeeds.\r\n\r\nAnother reason which is less critical, but a nice feature, is that `approveAndCall` allows the contract some flexibility to withdraw tokens. If a price paid in tokens is dynamically calculated, you can list how much you're willing to pay, call the contract which then calculates how much is needed and withdraws only the required amount. Slightly more flexible.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/317118992/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/317120679",
    "html_url": "https://github.com/ethereum/EIPs/issues/677#issuecomment-317120679",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/677",
    "id": 317120679,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxNzEyMDY3OQ==",
    "user": {
      "login": "MicahZoltu",
      "id": 886059,
      "node_id": "MDQ6VXNlcjg4NjA1OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886059?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MicahZoltu",
      "html_url": "https://github.com/MicahZoltu",
      "followers_url": "https://api.github.com/users/MicahZoltu/followers",
      "following_url": "https://api.github.com/users/MicahZoltu/following{/other_user}",
      "gists_url": "https://api.github.com/users/MicahZoltu/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MicahZoltu/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MicahZoltu/subscriptions",
      "organizations_url": "https://api.github.com/users/MicahZoltu/orgs",
      "repos_url": "https://api.github.com/users/MicahZoltu/repos",
      "events_url": "https://api.github.com/users/MicahZoltu/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MicahZoltu/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-07-21T21:51:01Z",
    "updated_at": "2017-07-21T21:51:01Z",
    "author_association": "MEMBER",
    "body": "I would rather see an addition to tokens that allows _anyone_ to call `transfer` with an additional parameter that is a signature of the token holder.  This way, dApps can simply ask the token holder (off-chain) for a signed allowance and then pass that to the transfer call when they need it.  A bit more thought needs to be put into exactly how to protect against replay attacks, but I think this would result in a much simpler and more intuitive interface than the user having to interact with the dApp via the token (which is an awkward API).",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/317120679/reactions",
      "total_count": 5,
      "+1": 5,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/317630365",
    "html_url": "https://github.com/ethereum/EIPs/issues/677#issuecomment-317630365",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/677",
    "id": 317630365,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxNzYzMDM2NQ==",
    "user": {
      "login": "vbuterin",
      "id": 2230894,
      "node_id": "MDQ6VXNlcjIyMzA4OTQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2230894?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vbuterin",
      "html_url": "https://github.com/vbuterin",
      "followers_url": "https://api.github.com/users/vbuterin/followers",
      "following_url": "https://api.github.com/users/vbuterin/following{/other_user}",
      "gists_url": "https://api.github.com/users/vbuterin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vbuterin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vbuterin/subscriptions",
      "organizations_url": "https://api.github.com/users/vbuterin/orgs",
      "repos_url": "https://api.github.com/users/vbuterin/repos",
      "events_url": "https://api.github.com/users/vbuterin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vbuterin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-07-25T05:04:44Z",
    "updated_at": "2017-07-25T05:04:44Z",
    "author_association": "MEMBER",
    "body": "> The reason for not using transferAndCall is that it would make it difficult, and often impossible, for the receiving contract to actually verify that tokens had been transferred to it(verifying would either require someone to check logs off chain, or a new API to be introduced).\r\n\r\nHow so? User A calls transferAndCall of contract C, contract C then calls receiveTransfer of contract B. Contract B sees that msg.sender = C, and so it's a legit transfer of tokens.\r\n\r\nThe reason why transferAndCall is superior is as @Arachnid says, it allows you to get rid of any expensive superfluous storage updates whatsoever - all that happens is tokens get transferred and the recipient gets notified.\r\n\r\n> If a price paid in tokens is dynamically calculated, you can list how much you're willing to pay, call the contract which then calculates how much is needed and withdraws only the required amount. Slightly more flexible.\r\n\r\nThis is also doable with transferAndCall: you would first call some constant function getHowMuchINeedToPay of the recipient, then send a transferAndCall with that precise amount.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/317630365/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/317836314",
    "html_url": "https://github.com/ethereum/EIPs/issues/677#issuecomment-317836314",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/677",
    "id": 317836314,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxNzgzNjMxNA==",
    "user": {
      "login": "se3000",
      "id": 573827,
      "node_id": "MDQ6VXNlcjU3MzgyNw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/573827?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/se3000",
      "html_url": "https://github.com/se3000",
      "followers_url": "https://api.github.com/users/se3000/followers",
      "following_url": "https://api.github.com/users/se3000/following{/other_user}",
      "gists_url": "https://api.github.com/users/se3000/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/se3000/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/se3000/subscriptions",
      "organizations_url": "https://api.github.com/users/se3000/orgs",
      "repos_url": "https://api.github.com/users/se3000/repos",
      "events_url": "https://api.github.com/users/se3000/events{/privacy}",
      "received_events_url": "https://api.github.com/users/se3000/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-07-25T18:53:43Z",
    "updated_at": "2017-07-25T18:53:43Z",
    "author_association": "NONE",
    "body": "The worst case I was imagining is something like a decentralized exchange dealing with lots of tokens they can't evaluate, but just enable people to use them. In this case people could introduce malicious tokens, but as I think more about it, a malicious token contract could also sabotage the `approveAndCall` functionality.\r\n\r\nThe `getHowMuchINeedToPay` pattern would work, but the dynamic gas pattern wouldn't be available with as a standardized behavior.\r\n\r\nI'm open to `transferAndCall`, but leaning towards including both. Is the `address token` parameter necessary? It seems like it wouldn't be for `transferAndCall` but maybe still allows some flexibility with `approveAndCall`. What is enabled by taking the parameter and comparing to `msg.sender`, as opposed to just using `msg.sender` as the token parameter? The main benefit I see is fitting the existing pattern that some tokens have used.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/317836314/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/318822846",
    "html_url": "https://github.com/ethereum/EIPs/issues/677#issuecomment-318822846",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/677",
    "id": 318822846,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxODgyMjg0Ng==",
    "user": {
      "login": "Dexaran",
      "id": 26142412,
      "node_id": "MDQ6VXNlcjI2MTQyNDEy",
      "avatar_url": "https://avatars.githubusercontent.com/u/26142412?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Dexaran",
      "html_url": "https://github.com/Dexaran",
      "followers_url": "https://api.github.com/users/Dexaran/followers",
      "following_url": "https://api.github.com/users/Dexaran/following{/other_user}",
      "gists_url": "https://api.github.com/users/Dexaran/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Dexaran/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Dexaran/subscriptions",
      "organizations_url": "https://api.github.com/users/Dexaran/orgs",
      "repos_url": "https://api.github.com/users/Dexaran/repos",
      "events_url": "https://api.github.com/users/Dexaran/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Dexaran/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-07-29T11:18:54Z",
    "updated_at": "2017-07-29T11:18:54Z",
    "author_association": "NONE",
    "body": "Can someone explain me what is the reason of having approves in standard tokens?\r\nThey are needed for nothing since the common pattern is just to handle an incoming transaction.\r\nETH transfers works as above and are handled by payable functions (fallback in most cases).\r\n\r\nAs I've supposed earlier that the only purpose of `approval` mechanism was to prevent stack depth attack. \r\nhttps://github.com/ethereum/EIPs/issues/223#issuecomment-317979258\r\n\r\nSo the only reason of `approves` is backwards compatibility with ERC20?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/318822846/reactions",
      "total_count": 4,
      "+1": 4,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/319515224",
    "html_url": "https://github.com/ethereum/EIPs/issues/677#issuecomment-319515224",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/677",
    "id": 319515224,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxOTUxNTIyNA==",
    "user": {
      "login": "se3000",
      "id": 573827,
      "node_id": "MDQ6VXNlcjU3MzgyNw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/573827?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/se3000",
      "html_url": "https://github.com/se3000",
      "followers_url": "https://api.github.com/users/se3000/followers",
      "following_url": "https://api.github.com/users/se3000/following{/other_user}",
      "gists_url": "https://api.github.com/users/se3000/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/se3000/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/se3000/subscriptions",
      "organizations_url": "https://api.github.com/users/se3000/orgs",
      "repos_url": "https://api.github.com/users/se3000/repos",
      "events_url": "https://api.github.com/users/se3000/events{/privacy}",
      "received_events_url": "https://api.github.com/users/se3000/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-08-01T22:29:01Z",
    "updated_at": "2017-08-01T22:29:01Z",
    "author_association": "NONE",
    "body": "@Dexaran backwards compatibility seems like the most important reason to me. Beyond that, approved withdrawal caps are a pretty standard pattern that have unique workflows that would be more difficult without the `approve` method.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/319515224/reactions",
      "total_count": 4,
      "+1": 1,
      "-1": 3,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/319518401",
    "html_url": "https://github.com/ethereum/EIPs/issues/677#issuecomment-319518401",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/677",
    "id": 319518401,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxOTUxODQwMQ==",
    "user": {
      "login": "se3000",
      "id": 573827,
      "node_id": "MDQ6VXNlcjU3MzgyNw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/573827?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/se3000",
      "html_url": "https://github.com/se3000",
      "followers_url": "https://api.github.com/users/se3000/followers",
      "following_url": "https://api.github.com/users/se3000/following{/other_user}",
      "gists_url": "https://api.github.com/users/se3000/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/se3000/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/se3000/subscriptions",
      "organizations_url": "https://api.github.com/users/se3000/orgs",
      "repos_url": "https://api.github.com/users/se3000/repos",
      "events_url": "https://api.github.com/users/se3000/events{/privacy}",
      "received_events_url": "https://api.github.com/users/se3000/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-08-01T22:46:46Z",
    "updated_at": "2017-08-01T22:46:46Z",
    "author_association": "NONE",
    "body": "@MicahZoltu Interesting proposal, it looks as if it would fit the pattern proposed by [EIP662](https://github.com/ethereum/EIPs/issues/662). It seems like a broad pattern which may be orthogonal and complimentary to token transfer standards.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/319518401/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/319575277",
    "html_url": "https://github.com/ethereum/EIPs/issues/677#issuecomment-319575277",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/677",
    "id": 319575277,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxOTU3NTI3Nw==",
    "user": {
      "login": "Dexaran",
      "id": 26142412,
      "node_id": "MDQ6VXNlcjI2MTQyNDEy",
      "avatar_url": "https://avatars.githubusercontent.com/u/26142412?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Dexaran",
      "html_url": "https://github.com/Dexaran",
      "followers_url": "https://api.github.com/users/Dexaran/followers",
      "following_url": "https://api.github.com/users/Dexaran/following{/other_user}",
      "gists_url": "https://api.github.com/users/Dexaran/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Dexaran/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Dexaran/subscriptions",
      "organizations_url": "https://api.github.com/users/Dexaran/orgs",
      "repos_url": "https://api.github.com/users/Dexaran/repos",
      "events_url": "https://api.github.com/users/Dexaran/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Dexaran/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-08-02T05:56:12Z",
    "updated_at": "2017-08-02T05:56:12Z",
    "author_association": "NONE",
    "body": ">approved withdrawal caps are a pretty standard pattern that have unique workflows that would be more difficult without the approve method.\r\n\r\n@se3000\r\nWhat unique workflows are you talking about? I ask for an example over the past three months, but I have never received any real answer. Only answers such as \"a useful functional that you must believe exists, but no one has seen it.\"\r\n\r\nBy the way Ether dosn't have any approves and everything is OK with it.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/319575277/reactions",
      "total_count": 3,
      "+1": 3,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/319735535",
    "html_url": "https://github.com/ethereum/EIPs/issues/677#issuecomment-319735535",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/677",
    "id": 319735535,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxOTczNTUzNQ==",
    "user": {
      "login": "MicahZoltu",
      "id": 886059,
      "node_id": "MDQ6VXNlcjg4NjA1OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886059?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MicahZoltu",
      "html_url": "https://github.com/MicahZoltu",
      "followers_url": "https://api.github.com/users/MicahZoltu/followers",
      "following_url": "https://api.github.com/users/MicahZoltu/following{/other_user}",
      "gists_url": "https://api.github.com/users/MicahZoltu/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MicahZoltu/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MicahZoltu/subscriptions",
      "organizations_url": "https://api.github.com/users/MicahZoltu/orgs",
      "repos_url": "https://api.github.com/users/MicahZoltu/repos",
      "events_url": "https://api.github.com/users/MicahZoltu/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MicahZoltu/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-08-02T17:04:39Z",
    "updated_at": "2017-08-02T17:04:39Z",
    "author_association": "MEMBER",
    "body": "@Dexaran I'm with you on wanting to remove approvals entirely.  However, the workflow that is meaningful to me is the one where you have some complicated system (such as Augur) that has need to move user tokens around internally.  Having the user _start_ the interaction with a token transfer works, but it complicates the interface because it means the entrypoint for Augur is always through a token, rather than through a contract call.  Since the details of the interaction are coming through via the data parameter, this means that the receiving contract needs to decode those bytes (in-contract) and then make decisions based on the data.  Not only are these bytes opaque to any user looking at the transaction (which includes tools designed to show transaction details using the ABI), decoding them into something useful on-chain is hard.\r\n\r\nFor the most naive case, the data could just be a number (effectively part of an enum), and this isn't _too_ bad.  However, this won't work for all cases such as an exchange where you need to send quite a few details along with the token transfer like counterparty address, token being traded for, price, etc.  All of this needs to be encoded into a byte array that is totally opaque to any reader.\r\n\r\nNote: The above aren't insurmountable problems, and I'm not sure approve is really any better of a solution because it requires multiple signatures from the user (something a UI can't hide), but I do think it is something worth considering.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/319735535/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/319862841",
    "html_url": "https://github.com/ethereum/EIPs/issues/677#issuecomment-319862841",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/677",
    "id": 319862841,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxOTg2Mjg0MQ==",
    "user": {
      "login": "vbuterin",
      "id": 2230894,
      "node_id": "MDQ6VXNlcjIyMzA4OTQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2230894?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vbuterin",
      "html_url": "https://github.com/vbuterin",
      "followers_url": "https://api.github.com/users/vbuterin/followers",
      "following_url": "https://api.github.com/users/vbuterin/following{/other_user}",
      "gists_url": "https://api.github.com/users/vbuterin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vbuterin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vbuterin/subscriptions",
      "organizations_url": "https://api.github.com/users/vbuterin/orgs",
      "repos_url": "https://api.github.com/users/vbuterin/repos",
      "events_url": "https://api.github.com/users/vbuterin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vbuterin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-08-03T04:12:11Z",
    "updated_at": "2017-08-03T04:12:11Z",
    "author_association": "MEMBER",
    "body": "Approvals have one other problem: using approvals creates a workflow where the contract that uses the approval needs to do something like: (i) call transferFrom, THEN (ii) do something else. This is an external call followed by a state change, which is generally considered a no-no because of re-entrancy issues.\r\n\r\nI now increasingly support transferAndCall as defined in #223, as the execution path is very clean - first go into the token contract, edit balances there, then go into the destination account.\r\n\r\nI previously had the objection that it complicates implementation since you would need to be able to do \"ABI inside ABI\", but I have since softened on this since realizing that multisig contracts and other forwarding contracts require this already.\r\n\r\nAlso, stack depth attacks are irrelevant since the Tangerine Whistle hard fork (that's last October).",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/319862841/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/328425583",
    "html_url": "https://github.com/ethereum/EIPs/issues/677#issuecomment-328425583",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/677",
    "id": 328425583,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyODQyNTU4Mw==",
    "user": {
      "login": "se3000",
      "id": 573827,
      "node_id": "MDQ6VXNlcjU3MzgyNw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/573827?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/se3000",
      "html_url": "https://github.com/se3000",
      "followers_url": "https://api.github.com/users/se3000/followers",
      "following_url": "https://api.github.com/users/se3000/following{/other_user}",
      "gists_url": "https://api.github.com/users/se3000/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/se3000/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/se3000/subscriptions",
      "organizations_url": "https://api.github.com/users/se3000/orgs",
      "repos_url": "https://api.github.com/users/se3000/repos",
      "events_url": "https://api.github.com/users/se3000/events{/privacy}",
      "received_events_url": "https://api.github.com/users/se3000/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-09-11T06:07:16Z",
    "updated_at": "2017-09-11T06:07:16Z",
    "author_association": "NONE",
    "body": "Ok, thanks for the feedback so far. Based on the helpful feedback, I've switched this to `transferAndCall` and updated the spec at the top.\r\n\r\nAt first I thought that [ERC223](https://github.com/ethereum/EIPs/issues/223) was sufficient to offer the transfer and call functionality. Based on further consideration it seems like not every token will want to be ERC223 compatible, as some contracts using ERC20 today do not allow for an `approve - transferFrom` withdrawal process. Such contracts would end up unintentionally holding ERC223 tokens and not allowing them to be withdrawn by contracts, because `transfer(address,uint256)` throws an error when sending to a contract; a common use case being a multisig wallet receiving tokens from another contract.\r\n\r\n`transferAndCall(address,uint256,bytes)` as currently proposed is effectively the same as ERC223's `transfer(address,uint256,bytes)`, calling the same `tokenFallback(address,uint256,bytes)` function on the receiver, and triggering the same `Transfer(address,address,uint256,bytes)` event. This allows contracts set up to receive tokens via ERC667 to be compatible with ERC223 transfers in the future and vice versa. By providing a step that allows for ERC20 tokens to call `tokenFallback`, it provides a transition path, until more contracts are prepared to handle receiving ERC223 tokens.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/328425583/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/328426996",
    "html_url": "https://github.com/ethereum/EIPs/issues/677#issuecomment-328426996",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/677",
    "id": 328426996,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyODQyNjk5Ng==",
    "user": {
      "login": "MicahZoltu",
      "id": 886059,
      "node_id": "MDQ6VXNlcjg4NjA1OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886059?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MicahZoltu",
      "html_url": "https://github.com/MicahZoltu",
      "followers_url": "https://api.github.com/users/MicahZoltu/followers",
      "following_url": "https://api.github.com/users/MicahZoltu/following{/other_user}",
      "gists_url": "https://api.github.com/users/MicahZoltu/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MicahZoltu/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MicahZoltu/subscriptions",
      "organizations_url": "https://api.github.com/users/MicahZoltu/orgs",
      "repos_url": "https://api.github.com/users/MicahZoltu/repos",
      "events_url": "https://api.github.com/users/MicahZoltu/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MicahZoltu/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-09-11T06:15:15Z",
    "updated_at": "2017-09-11T06:15:15Z",
    "author_association": "MEMBER",
    "body": "Feedback is basically the same as I provided to ERC223.  `onTokenTransfer` rather than `tokenFallback` and I'm still a fan of `transferAndCall` taking in a string name of the function to call (with `onTokenTransfer` being default).  I also recommend using the method name `transfer` rather than `transferAndCall` since Solidity supports function overloads and IMO having several functions named `transfer` with different parameters is more pithy than having several functions all with different names _and_ different parameters.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/328426996/reactions",
      "total_count": 4,
      "+1": 4,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/328563139",
    "html_url": "https://github.com/ethereum/EIPs/issues/677#issuecomment-328563139",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/677",
    "id": 328563139,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyODU2MzEzOQ==",
    "user": {
      "login": "Arachnid",
      "id": 17865,
      "node_id": "MDQ6VXNlcjE3ODY1",
      "avatar_url": "https://avatars.githubusercontent.com/u/17865?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Arachnid",
      "html_url": "https://github.com/Arachnid",
      "followers_url": "https://api.github.com/users/Arachnid/followers",
      "following_url": "https://api.github.com/users/Arachnid/following{/other_user}",
      "gists_url": "https://api.github.com/users/Arachnid/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Arachnid/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Arachnid/subscriptions",
      "organizations_url": "https://api.github.com/users/Arachnid/orgs",
      "repos_url": "https://api.github.com/users/Arachnid/repos",
      "events_url": "https://api.github.com/users/Arachnid/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Arachnid/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-09-11T15:19:40Z",
    "updated_at": "2017-09-11T15:19:40Z",
    "author_association": "MEMBER",
    "body": "Why specify a fixed function at all? It seems to me it would make a lot more sense to pass in a `bytes` argument and call the target contract with that as a raw payload.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/328563139/reactions",
      "total_count": 1,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 1,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/328591124",
    "html_url": "https://github.com/ethereum/EIPs/issues/677#issuecomment-328591124",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/677",
    "id": 328591124,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyODU5MTEyNA==",
    "user": {
      "login": "MicahZoltu",
      "id": 886059,
      "node_id": "MDQ6VXNlcjg4NjA1OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886059?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MicahZoltu",
      "html_url": "https://github.com/MicahZoltu",
      "followers_url": "https://api.github.com/users/MicahZoltu/followers",
      "following_url": "https://api.github.com/users/MicahZoltu/following{/other_user}",
      "gists_url": "https://api.github.com/users/MicahZoltu/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MicahZoltu/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MicahZoltu/subscriptions",
      "organizations_url": "https://api.github.com/users/MicahZoltu/orgs",
      "repos_url": "https://api.github.com/users/MicahZoltu/repos",
      "events_url": "https://api.github.com/users/MicahZoltu/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MicahZoltu/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-09-11T16:55:21Z",
    "updated_at": "2017-09-11T16:55:21Z",
    "author_association": "MEMBER",
    "body": "@Arachnid Similar argument to that over in the URI EIP.  Human readability, which leads to increased security by way of allowing users to make an informed decision.  When prompted to sign, if I see `transfer(0xdeadbeef, 100, 0xabcdef0123456789)` all I know is that I'm transferring 100 tokens to the `0xdeadbeef` contract but I don't know anything about how those tokens will be used.  For something like Augur (a large project), there are _many_ ways in which a token transfer can be used.  On the other hand, if I see: `transfer(0xdeadbeef, 100, \"buyShare\", 0xabcdef0123456789)`  I at least know that the tokens will be used to buy a share.  I haven't figured out an easy way to have the function parameters decoded (which would be even better) but this is at least a step in the right direction.  Ideally the call would look something like `transfer(0xdeadbeef, 100, \"buyShare\", \"LONG\", 200)` to indicate that I want to buy 200 long shares for the price of 100 tokens.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/328591124/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/328592342",
    "html_url": "https://github.com/ethereum/EIPs/issues/677#issuecomment-328592342",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/677",
    "id": 328592342,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyODU5MjM0Mg==",
    "user": {
      "login": "Arachnid",
      "id": 17865,
      "node_id": "MDQ6VXNlcjE3ODY1",
      "avatar_url": "https://avatars.githubusercontent.com/u/17865?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Arachnid",
      "html_url": "https://github.com/Arachnid",
      "followers_url": "https://api.github.com/users/Arachnid/followers",
      "following_url": "https://api.github.com/users/Arachnid/following{/other_user}",
      "gists_url": "https://api.github.com/users/Arachnid/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Arachnid/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Arachnid/subscriptions",
      "organizations_url": "https://api.github.com/users/Arachnid/orgs",
      "repos_url": "https://api.github.com/users/Arachnid/repos",
      "events_url": "https://api.github.com/users/Arachnid/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Arachnid/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-09-11T16:59:22Z",
    "updated_at": "2017-09-11T16:59:53Z",
    "author_association": "MEMBER",
    "body": "> Similar argument to that over in the URI EIP. Human readability, which leads to increased security by way of allowing users to make an informed decision.\r\n\r\nThis is a standard for an ABI, though - human readability shouldn't come into it, and certainly not as an overriding consideration. Further, with `onTokenTransfer` being the only fallback function, you won't get any useful information for the user anyway.\r\n\r\nInsofar as you can decode the outer call's ABI encoding to show something to the user, too, you could also decode the inner encoding in the same fashion.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/328592342/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/328601944",
    "html_url": "https://github.com/ethereum/EIPs/issues/677#issuecomment-328601944",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/677",
    "id": 328601944,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyODYwMTk0NA==",
    "user": {
      "login": "se3000",
      "id": 573827,
      "node_id": "MDQ6VXNlcjU3MzgyNw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/573827?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/se3000",
      "html_url": "https://github.com/se3000",
      "followers_url": "https://api.github.com/users/se3000/followers",
      "following_url": "https://api.github.com/users/se3000/following{/other_user}",
      "gists_url": "https://api.github.com/users/se3000/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/se3000/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/se3000/subscriptions",
      "organizations_url": "https://api.github.com/users/se3000/orgs",
      "repos_url": "https://api.github.com/users/se3000/repos",
      "events_url": "https://api.github.com/users/se3000/events{/privacy}",
      "received_events_url": "https://api.github.com/users/se3000/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-09-11T17:34:34Z",
    "updated_at": "2017-09-11T17:34:34Z",
    "author_association": "NONE",
    "body": "> Why specify a fixed function at all? It seems to me it would make a lot more sense to pass in a bytes argument and call the target contract with that as a raw payload.\r\n\r\nThe receiving contract should know who sent the tokens and the amount sent. If that is specified in the `bytes` then the transferrer could lie and say they sent more than they did. Making the token contract report ensures the correct parameters are passed. Or, is there a way I'm missing to make sure the `bytes` accurately represent the transfer?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/328601944/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/328610300",
    "html_url": "https://github.com/ethereum/EIPs/issues/677#issuecomment-328610300",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/677",
    "id": 328610300,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyODYxMDMwMA==",
    "user": {
      "login": "Arachnid",
      "id": 17865,
      "node_id": "MDQ6VXNlcjE3ODY1",
      "avatar_url": "https://avatars.githubusercontent.com/u/17865?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Arachnid",
      "html_url": "https://github.com/Arachnid",
      "followers_url": "https://api.github.com/users/Arachnid/followers",
      "following_url": "https://api.github.com/users/Arachnid/following{/other_user}",
      "gists_url": "https://api.github.com/users/Arachnid/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Arachnid/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Arachnid/subscriptions",
      "organizations_url": "https://api.github.com/users/Arachnid/orgs",
      "repos_url": "https://api.github.com/users/Arachnid/repos",
      "events_url": "https://api.github.com/users/Arachnid/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Arachnid/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-09-11T18:04:56Z",
    "updated_at": "2017-09-11T18:04:56Z",
    "author_association": "MEMBER",
    "body": "> The receiving contract should know who sent the tokens and the amount sent. If that is specified in the bytes then the transferrer could lie and say they sent more than they did. Making the token contract report ensures the correct parameters are passed. Or, is there a way I'm missing to make sure the bytes accurately represent the transfer?\r\n\r\nInformation about the transfer does not need to be contained in the message payload; the contract can identify the caller and check its balance there.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/328610300/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/328618736",
    "html_url": "https://github.com/ethereum/EIPs/issues/677#issuecomment-328618736",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/677",
    "id": 328618736,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyODYxODczNg==",
    "user": {
      "login": "MicahZoltu",
      "id": 886059,
      "node_id": "MDQ6VXNlcjg4NjA1OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886059?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MicahZoltu",
      "html_url": "https://github.com/MicahZoltu",
      "followers_url": "https://api.github.com/users/MicahZoltu/followers",
      "following_url": "https://api.github.com/users/MicahZoltu/following{/other_user}",
      "gists_url": "https://api.github.com/users/MicahZoltu/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MicahZoltu/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MicahZoltu/subscriptions",
      "organizations_url": "https://api.github.com/users/MicahZoltu/orgs",
      "repos_url": "https://api.github.com/users/MicahZoltu/repos",
      "events_url": "https://api.github.com/users/MicahZoltu/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MicahZoltu/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-09-11T18:34:27Z",
    "updated_at": "2017-09-11T18:34:48Z",
    "author_association": "MEMBER",
    "body": "> Information about the transfer does not need to be contained in the message payload; the contract can identify the caller and check its balance there.\r\n\r\nCurrent balance is very different from amount received.  In order for current balance to work/be useful, the contract would need to track \"last known balance\" for every token it receives and update it on every token receipt which means at least 5k additional gas for the state update.  This also assumes that the contract isn't receiving tokens via some other means (e.g., traditional ERC20 token transfers).",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/328618736/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/328620461",
    "html_url": "https://github.com/ethereum/EIPs/issues/677#issuecomment-328620461",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/677",
    "id": 328620461,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyODYyMDQ2MQ==",
    "user": {
      "login": "MicahZoltu",
      "id": 886059,
      "node_id": "MDQ6VXNlcjg4NjA1OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886059?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MicahZoltu",
      "html_url": "https://github.com/MicahZoltu",
      "followers_url": "https://api.github.com/users/MicahZoltu/followers",
      "following_url": "https://api.github.com/users/MicahZoltu/following{/other_user}",
      "gists_url": "https://api.github.com/users/MicahZoltu/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MicahZoltu/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MicahZoltu/subscriptions",
      "organizations_url": "https://api.github.com/users/MicahZoltu/orgs",
      "repos_url": "https://api.github.com/users/MicahZoltu/repos",
      "events_url": "https://api.github.com/users/MicahZoltu/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MicahZoltu/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-09-11T18:40:36Z",
    "updated_at": "2017-09-11T18:42:32Z",
    "author_association": "MEMBER",
    "body": "> Insofar as you can decode the outer call's ABI encoding to show something to the user, too, you could also decode the inner encoding in the same fashion.\r\n\r\nThis would require tooling to directly implement support for tokens implementing this.  Using the scheme I described above, the tooling only needs to be able to decode/display top level contract calls (which some tools like Parity already do).\r\n\r\n@Arachnid Is your assumption that all tools will _directly_ support this spec and understand what the `bytes` parameter represents, and decode it to display to users in the same way they decode top-level method parameters?  I'm not sure where the appropriate place to have this discussion is, but you and I seem to be approaching several EIPs from different angles.  I believe we both recognize the value in signing tools being able to provide users with enough details so the user can make an informed signing decision, but in each of the EIPs you seem to be favoring low-level bytearrays while I am favoring higher level APIs.  I'm curious what your vision is for the ecosystem that allows for low-level byte array APIs while still providing users the information at signing time to make informed signing decisions.\r\n\r\nAt a high level, byte arrays are a lossy interface (method name and types cannot be recovered from method hash) which is what I'm arguing against.  I think the data that is lost is very important for informed signing decisions.  How do you propose allowing users to re-acquire this lost information so they can make an informed signing decision?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/328620461/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/328633833",
    "html_url": "https://github.com/ethereum/EIPs/issues/677#issuecomment-328633833",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/677",
    "id": 328633833,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyODYzMzgzMw==",
    "user": {
      "login": "se3000",
      "id": 573827,
      "node_id": "MDQ6VXNlcjU3MzgyNw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/573827?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/se3000",
      "html_url": "https://github.com/se3000",
      "followers_url": "https://api.github.com/users/se3000/followers",
      "following_url": "https://api.github.com/users/se3000/following{/other_user}",
      "gists_url": "https://api.github.com/users/se3000/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/se3000/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/se3000/subscriptions",
      "organizations_url": "https://api.github.com/users/se3000/orgs",
      "repos_url": "https://api.github.com/users/se3000/repos",
      "events_url": "https://api.github.com/users/se3000/events{/privacy}",
      "received_events_url": "https://api.github.com/users/se3000/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-09-11T19:28:59Z",
    "updated_at": "2017-09-11T23:55:39Z",
    "author_association": "NONE",
    "body": "The current balance approach is interesting. As Micah pointed out it's expensive and not guaranteed to work if tokens are received in other ways. That is probably solvable, but would increase the complexity of writing any contract that receives tokens.\r\n\r\nSimilarly, how would you determine who sent the tokens? Assuming not `tx.origin`, that would also have to be specified in the bytes data and could then be faked. Attributing a transfer to someone else doesn't sound malicious, but it could be problematic. Also, attributing a transfer to someone else is still possible for the receiving contract to implement with `transferAndCall`.\r\n\r\nStepping back a bit, I'm currently of the mind that token transfers would ideally behave as much like Ether transfers as possible. For that to remain, you should always be able to tell who sent you a token, like an equivalent to `msg.sender`.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/328633833/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/328696800",
    "html_url": "https://github.com/ethereum/EIPs/issues/677#issuecomment-328696800",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/677",
    "id": 328696800,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyODY5NjgwMA==",
    "user": {
      "login": "iam-peekay",
      "id": 5421194,
      "node_id": "MDQ6VXNlcjU0MjExOTQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5421194?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/iam-peekay",
      "html_url": "https://github.com/iam-peekay",
      "followers_url": "https://api.github.com/users/iam-peekay/followers",
      "following_url": "https://api.github.com/users/iam-peekay/following{/other_user}",
      "gists_url": "https://api.github.com/users/iam-peekay/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/iam-peekay/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/iam-peekay/subscriptions",
      "organizations_url": "https://api.github.com/users/iam-peekay/orgs",
      "repos_url": "https://api.github.com/users/iam-peekay/repos",
      "events_url": "https://api.github.com/users/iam-peekay/events{/privacy}",
      "received_events_url": "https://api.github.com/users/iam-peekay/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-09-12T00:34:41Z",
    "updated_at": "2017-09-12T00:34:41Z",
    "author_association": "NONE",
    "body": "@se3000 do you have an example implementation yet? I assume the receiving contract will be the same as this implementation of the ERC223 token: https://github.com/Dexaran/ERC223-token-standard/blob/Recommended/Receiver_Interface.sol \r\n\r\nAs a token contract author with an upcoming token sale in the coming weeks, I'm torn on whether to stick to the ERC20 standard, use this standard with `transferAndCall`, or use the ERC223 standard.  ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/328696800/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/328697000",
    "html_url": "https://github.com/ethereum/EIPs/issues/677#issuecomment-328697000",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/677",
    "id": 328697000,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyODY5NzAwMA==",
    "user": {
      "login": "MicahZoltu",
      "id": 886059,
      "node_id": "MDQ6VXNlcjg4NjA1OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886059?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MicahZoltu",
      "html_url": "https://github.com/MicahZoltu",
      "followers_url": "https://api.github.com/users/MicahZoltu/followers",
      "following_url": "https://api.github.com/users/MicahZoltu/following{/other_user}",
      "gists_url": "https://api.github.com/users/MicahZoltu/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MicahZoltu/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MicahZoltu/subscriptions",
      "organizations_url": "https://api.github.com/users/MicahZoltu/orgs",
      "repos_url": "https://api.github.com/users/MicahZoltu/repos",
      "events_url": "https://api.github.com/users/MicahZoltu/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MicahZoltu/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-09-12T00:36:00Z",
    "updated_at": "2017-09-12T00:36:00Z",
    "author_association": "MEMBER",
    "body": "@iam-peekay I recommend going with ERC20 for now.  You can always release a new token and have users migrate once ERC223 or this is finalized.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/328697000/reactions",
      "total_count": 5,
      "+1": 2,
      "-1": 3,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/328797030",
    "html_url": "https://github.com/ethereum/EIPs/issues/677#issuecomment-328797030",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/677",
    "id": 328797030,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyODc5NzAzMA==",
    "user": {
      "login": "Arachnid",
      "id": 17865,
      "node_id": "MDQ6VXNlcjE3ODY1",
      "avatar_url": "https://avatars.githubusercontent.com/u/17865?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Arachnid",
      "html_url": "https://github.com/Arachnid",
      "followers_url": "https://api.github.com/users/Arachnid/followers",
      "following_url": "https://api.github.com/users/Arachnid/following{/other_user}",
      "gists_url": "https://api.github.com/users/Arachnid/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Arachnid/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Arachnid/subscriptions",
      "organizations_url": "https://api.github.com/users/Arachnid/orgs",
      "repos_url": "https://api.github.com/users/Arachnid/repos",
      "events_url": "https://api.github.com/users/Arachnid/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Arachnid/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-09-12T09:28:50Z",
    "updated_at": "2017-09-12T15:39:37Z",
    "author_association": "MEMBER",
    "body": "@MicahZoltu @se3000 Good points; being able to determine the ultimate sender and the amount they sent are critical pieces of information that have to be supplied in a trusted fashion. I withdraw my suggestion.\r\n\r\n> I'm not sure where the appropriate place to have this discussion is, but you and I seem to be approaching several EIPs from different angles. I believe we both recognize the value in signing tools being able to provide users with enough details so the user can make an informed signing decision, but in each of the EIPs you seem to be favoring low-level bytearrays while I am favoring higher level APIs. I'm curious what your vision is for the ecosystem that allows for low-level byte array APIs while still providing users the information at signing time to make informed signing decisions.\r\n\r\nUltimately, I'm a fan of representing things in the form most suited to the layer in which they reside, and of minimising unnecessary overhead inside the EVM. That means user-friendly standards for URIs, but machine-level specifications for ABIs.\r\n\r\nUser insight can be provided by using a higher level encoding to determine what to display to the user, then deriving the ABI level encoding from that, rather than trying to reverse-engineer ABI encoding or embed extra metadata in it.\r\n\r\nShowing function calls to a user is a horrible user experience anyway, and for anyone other than a programmer, only marginally more meaningful than just showing them the raw ABI encoded hex data.\r\n\r\nEdit: Another alternative to consider is `approveAndCall`; this has the significant advantage that it Just Works with existing contracts that consume tokens, and doesn't require passing any trusted data to the callee.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/328797030/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/328821075",
    "html_url": "https://github.com/ethereum/EIPs/issues/677#issuecomment-328821075",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/677",
    "id": 328821075,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyODgyMTA3NQ==",
    "user": {
      "login": "sgitt-vassky",
      "id": 30172932,
      "node_id": "MDQ6VXNlcjMwMTcyOTMy",
      "avatar_url": "https://avatars.githubusercontent.com/u/30172932?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sgitt-vassky",
      "html_url": "https://github.com/sgitt-vassky",
      "followers_url": "https://api.github.com/users/sgitt-vassky/followers",
      "following_url": "https://api.github.com/users/sgitt-vassky/following{/other_user}",
      "gists_url": "https://api.github.com/users/sgitt-vassky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sgitt-vassky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sgitt-vassky/subscriptions",
      "organizations_url": "https://api.github.com/users/sgitt-vassky/orgs",
      "repos_url": "https://api.github.com/users/sgitt-vassky/repos",
      "events_url": "https://api.github.com/users/sgitt-vassky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sgitt-vassky/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-09-12T11:12:18Z",
    "updated_at": "2017-09-12T11:12:50Z",
    "author_association": "NONE",
    "body": "@iam-peekay @MicahZoltu \r\n\r\nAdvising people \"i recommend going with ERC20 for now\" is exactly the same as saying \"your users will guaranteed lose money because of vulnerability of this standard but I will still recommend to use it. It's just someone else's money, you don't need to care about it.\"\r\nHere is a short demonstration about how people will suffer loss of funds if you will go with ERC20:\r\nI will recommend to carefully read this comment:\r\nhttps://github.com/ethereum/EIPs/issues/223#issuecomment-325635082\r\n\r\nYou guys cast a bad shadow on the whole cryptocurrency industry, developing tokens so that people lose money and advising other developers to do the same just because you don't think that it is serious that someone will suffer because of your inattentiveness.\r\n\r\nhttps://medium.com/@dexaran820/erc20-token-standard-critical-problems-3c10fd48657b\r\n\r\nhttps://www.reddit.com/r/ethereum/comments/6h17og/critical_problem_of_erc20_tokens_effect_appeal_to/?st=j7hhqkxe&sh=cfc5ae37",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/328821075/reactions",
      "total_count": 6,
      "+1": 0,
      "-1": 4,
      "laugh": 0,
      "hooray": 0,
      "confused": 2,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/328892247",
    "html_url": "https://github.com/ethereum/EIPs/issues/677#issuecomment-328892247",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/677",
    "id": 328892247,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyODg5MjI0Nw==",
    "user": {
      "login": "Arachnid",
      "id": 17865,
      "node_id": "MDQ6VXNlcjE3ODY1",
      "avatar_url": "https://avatars.githubusercontent.com/u/17865?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Arachnid",
      "html_url": "https://github.com/Arachnid",
      "followers_url": "https://api.github.com/users/Arachnid/followers",
      "following_url": "https://api.github.com/users/Arachnid/following{/other_user}",
      "gists_url": "https://api.github.com/users/Arachnid/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Arachnid/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Arachnid/subscriptions",
      "organizations_url": "https://api.github.com/users/Arachnid/orgs",
      "repos_url": "https://api.github.com/users/Arachnid/repos",
      "events_url": "https://api.github.com/users/Arachnid/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Arachnid/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-09-12T15:38:53Z",
    "updated_at": "2017-09-12T15:38:53Z",
    "author_association": "MEMBER",
    "body": "> Advising people \"i recommend going with ERC20 for now\" is exactly the same as saying \"your users will guaranteed lose money because of vulnerability of this standard but I will still recommend to use it. It's just someone else's money, you don't need to care about it.\"\r\n\r\nNo, it's not. ERC223 is in a state of flux, and it's far from clear that it won't lead to its own causes of lost or locked funds. Recommending people implement a standard that isn't even close to being locked down is a recipe for chaos.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/328892247/reactions",
      "total_count": 1,
      "+1": 0,
      "-1": 1,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/328914575",
    "html_url": "https://github.com/ethereum/EIPs/issues/677#issuecomment-328914575",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/677",
    "id": 328914575,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyODkxNDU3NQ==",
    "user": {
      "login": "sgitt-vassky",
      "id": 30172932,
      "node_id": "MDQ6VXNlcjMwMTcyOTMy",
      "avatar_url": "https://avatars.githubusercontent.com/u/30172932?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sgitt-vassky",
      "html_url": "https://github.com/sgitt-vassky",
      "followers_url": "https://api.github.com/users/sgitt-vassky/followers",
      "following_url": "https://api.github.com/users/sgitt-vassky/following{/other_user}",
      "gists_url": "https://api.github.com/users/sgitt-vassky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sgitt-vassky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sgitt-vassky/subscriptions",
      "organizations_url": "https://api.github.com/users/sgitt-vassky/orgs",
      "repos_url": "https://api.github.com/users/sgitt-vassky/repos",
      "events_url": "https://api.github.com/users/sgitt-vassky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sgitt-vassky/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-09-12T16:50:55Z",
    "updated_at": "2017-09-12T16:50:55Z",
    "author_association": "NONE",
    "body": "If you implement ERC20 then your users will lose money.\r\nIf you implement ERC223 then it depends on how you will implement it.\r\n\r\nI prefer not to do what is guaranteed to be a mistake and result in loss of money for users.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/328914575/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/328937709",
    "html_url": "https://github.com/ethereum/EIPs/issues/677#issuecomment-328937709",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/677",
    "id": 328937709,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyODkzNzcwOQ==",
    "user": {
      "login": "MicahZoltu",
      "id": 886059,
      "node_id": "MDQ6VXNlcjg4NjA1OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886059?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MicahZoltu",
      "html_url": "https://github.com/MicahZoltu",
      "followers_url": "https://api.github.com/users/MicahZoltu/followers",
      "following_url": "https://api.github.com/users/MicahZoltu/following{/other_user}",
      "gists_url": "https://api.github.com/users/MicahZoltu/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MicahZoltu/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MicahZoltu/subscriptions",
      "organizations_url": "https://api.github.com/users/MicahZoltu/orgs",
      "repos_url": "https://api.github.com/users/MicahZoltu/repos",
      "events_url": "https://api.github.com/users/MicahZoltu/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MicahZoltu/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-09-12T18:14:54Z",
    "updated_at": "2017-09-12T18:14:54Z",
    "author_association": "MEMBER",
    "body": "Implementing ERC223 right now is equivalent of not implementing any standard.  You are welcome to create a non-standard token, it has been done before.  If you want your token to be interoperable though, you have to pick a standard and right now there is only one (ERC20).",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/328937709/reactions",
      "total_count": 8,
      "+1": 8,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/329080736",
    "html_url": "https://github.com/ethereum/EIPs/issues/677#issuecomment-329080736",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/677",
    "id": 329080736,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyOTA4MDczNg==",
    "user": {
      "login": "Arachnid",
      "id": 17865,
      "node_id": "MDQ6VXNlcjE3ODY1",
      "avatar_url": "https://avatars.githubusercontent.com/u/17865?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Arachnid",
      "html_url": "https://github.com/Arachnid",
      "followers_url": "https://api.github.com/users/Arachnid/followers",
      "following_url": "https://api.github.com/users/Arachnid/following{/other_user}",
      "gists_url": "https://api.github.com/users/Arachnid/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Arachnid/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Arachnid/subscriptions",
      "organizations_url": "https://api.github.com/users/Arachnid/orgs",
      "repos_url": "https://api.github.com/users/Arachnid/repos",
      "events_url": "https://api.github.com/users/Arachnid/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Arachnid/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-09-13T07:17:37Z",
    "updated_at": "2017-09-13T07:17:37Z",
    "author_association": "MEMBER",
    "body": "> If you implement ERC20 then your users will lose money.\r\n\r\n> If you implement ERC223 then it depends on how you will implement it.\r\n\r\n> I prefer not to do what is guaranteed to be a mistake and result in loss of money for users.\r\n\r\nTo phrase it another way: Would you prefer a small but well-known risk of loss, or a completely unknown risk of loss that could be much smaller or much larger?\r\n\r\nThe precautionary principle errs in favor of the former.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/329080736/reactions",
      "total_count": 1,
      "+1": 0,
      "-1": 1,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/329098619",
    "html_url": "https://github.com/ethereum/EIPs/issues/677#issuecomment-329098619",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/677",
    "id": 329098619,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyOTA5ODYxOQ==",
    "user": {
      "login": "se3000",
      "id": 573827,
      "node_id": "MDQ6VXNlcjU3MzgyNw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/573827?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/se3000",
      "html_url": "https://github.com/se3000",
      "followers_url": "https://api.github.com/users/se3000/followers",
      "following_url": "https://api.github.com/users/se3000/following{/other_user}",
      "gists_url": "https://api.github.com/users/se3000/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/se3000/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/se3000/subscriptions",
      "organizations_url": "https://api.github.com/users/se3000/orgs",
      "repos_url": "https://api.github.com/users/se3000/repos",
      "events_url": "https://api.github.com/users/se3000/events{/privacy}",
      "received_events_url": "https://api.github.com/users/se3000/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-09-13T08:37:36Z",
    "updated_at": "2017-09-13T08:37:36Z",
    "author_association": "NONE",
    "body": "@iam-peekay I'll post an example soon. The receiving contract's interface will be the same as the example you posted.\r\n\r\nI think ERC223 is too risky at the moment, with the possible accidental lock-in mentioned in the Motivation section of the spec. In the meantime, you can prevent many accidental token burns by [throwing for transfers to 0x0 or the token itself](https://github.com/Giveth/minime/blob/master/contracts/MiniMeToken.sol#L214), I believe those are the two most common burns.\r\n\r\nYou could implement something like ERC677 now and get the \"1 transaction transfer to contract\" functionality. The standard may evolve, but you will at least have the functionality available to your token.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/329098619/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
