{
  "url": "https://api.github.com/repos/ethereum/EIPs/issues/719",
  "repository_url": "https://api.github.com/repos/ethereum/EIPs",
  "labels_url": "https://api.github.com/repos/ethereum/EIPs/issues/719/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/EIPs/issues/719/comments",
  "events_url": "https://api.github.com/repos/ethereum/EIPs/issues/719/events",
  "html_url": "https://github.com/ethereum/EIPs/issues/719",
  "id": 259698709,
  "node_id": "MDU6SXNzdWUyNTk2OTg3MDk=",
  "number": 719,
  "title": "Trustless Signing UI Protocol",
  "user": {
    "login": "MicahZoltu",
    "id": 886059,
    "node_id": "MDQ6VXNlcjg4NjA1OQ==",
    "avatar_url": "https://avatars.githubusercontent.com/u/886059?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/MicahZoltu",
    "html_url": "https://github.com/MicahZoltu",
    "followers_url": "https://api.github.com/users/MicahZoltu/followers",
    "following_url": "https://api.github.com/users/MicahZoltu/following{/other_user}",
    "gists_url": "https://api.github.com/users/MicahZoltu/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/MicahZoltu/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/MicahZoltu/subscriptions",
    "organizations_url": "https://api.github.com/users/MicahZoltu/orgs",
    "repos_url": "https://api.github.com/users/MicahZoltu/repos",
    "events_url": "https://api.github.com/users/MicahZoltu/events{/privacy}",
    "received_events_url": "https://api.github.com/users/MicahZoltu/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 2328627851,
      "node_id": "MDU6TGFiZWwyMzI4NjI3ODUx",
      "url": "https://api.github.com/repos/ethereum/EIPs/labels/stale",
      "name": "stale",
      "color": "000000",
      "default": false,
      "description": ""
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 42,
  "created_at": "2017-09-22T04:18:34Z",
  "updated_at": "2022-01-16T00:43:47Z",
  "closed_at": "2022-01-16T00:43:47Z",
  "author_association": "MEMBER",
  "active_lock_reason": null,
  "body": "A lot of debate has been happening around how we can make signing a more secure process for end users.  One of the common arguments is that while all of the proposed solutions may resolve the problem for advanced users (developers, tech savvy users, professionals, etc.) it doesn't address the problem of naive users not understanding what they are signing.  They can often be thought of as the legalese presented to people in contracts: it is better than signing a blank sheet of paper, but to the average person its mostly gibberish.\r\n\r\nAn idea that @Arachnid and I started batting around in an attempt to come up with a long-term solution to this problem is to provide a mechanism by which things can be signed (ideally transactions and arbitrary messages) such that signer can present the user with informed consent without having to trust the UI.\r\n\r\nThe general premise is that the actor wanting a signature presents the signing tool with the data they want signed as well as a DSL that describes how the data should be presented to the user.  The signer would then ask the target contract if the DSL is valid, and only prompt the user to sign if the contract asserts that the DSL is in fact valid.\r\n\r\nThis is quite similar to #712, though it strives to take things a step further than just function name and parameters.\r\n\r\nAs far as the DSL itself goes, one option would be a text-only DSL that allows for replacement variables.  An example DSL may be something like\r\n```\r\nI would like to create an order offering ${data[0,64] as number} ${(data[64,64] as contract).name()} tokens in exchange for ${data[128,64] as number} ${(data[192,64] as contract).name()} tokens.\r\n```\r\nAn untrusted dApp would send that DSL (exactly) to the signer along with the transaction they want signed.  The signer would then ask the `transaction.to` contract whether the hash of the DSL is an approved DSL.  If it is, then the signer would extract data from the `transaction.data` and do an `eth_call` to fetch the `name()` of the two contracts (tokens in this example) and finally generate the string to present to the user.  This solution is very simple and allows for devices with small screens that can only present text (e.g., Ledger) to be able to reasonably present the user with information that the contract author has deemed as enough for informed consent.\r\n\r\nAnother more feature rich solution (in the extreme) would be to allow the DSL to be some form of constrained layout engine markup (e.g., HTML).  The idea here would be that the signer could verify the DSL was approved just like with the text DSL, but would be able to use a basic UI to present the data to the user like the 0x OTC dApp: \r\n![image](https://user-images.githubusercontent.com/886059/30728433-077329da-9f0d-11e7-80f4-e201230bfd44.png)\r\n\r\nFor complex contracts, a full UI is much more understandable to an end user than a paragraph or two of madlibs text, and it gives the dApp developer the ability to create a generally better user experience.\r\n\r\nThe obvious disadvantage to the full GUI DSL is that it can't reasonably be rendered on a text-only display like a watch or hardware key.  With the way this is proposed, a contract could support multiple DSLs so a well written contract may support both text only DSL (for small screens and screen readers) and also a GUI DSL for a better user experience for most users.  This would allow dApp developers to provide high quality signing experiences to users on devices that support it with graceful degradation on devices that don't.  It also allows signers to implement the presumably easier-to-implement madlibs spec fist, then expand towards the full GUI support implementation later.\r\n\r\nOpen Questions:\r\n* What is does the madlibs DSL look like?\r\n* What does the GUI DSL look like?\r\n* Are the benefits of a GUI DSL over a madlibs DSL worth the additional implementation costs on signing tools?\r\n* Are there existing DSLs that would give us broad support out of the box (e.g., HTML)?\r\n* What datatypes should the signing UI DSL support?\r\n  * timestamp: could present users with a date/time picker on click\r\n  * counter: could have an up-down clicker\r\n  * range: could have a range slider with tick DSL defined tick size\r\n  * others?",
  "closed_by": {
    "login": "github-actions[bot]",
    "id": 41898282,
    "node_id": "MDM6Qm90NDE4OTgyODI=",
    "avatar_url": "https://avatars.githubusercontent.com/in/15368?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/github-actions%5Bbot%5D",
    "html_url": "https://github.com/apps/github-actions",
    "followers_url": "https://api.github.com/users/github-actions%5Bbot%5D/followers",
    "following_url": "https://api.github.com/users/github-actions%5Bbot%5D/following{/other_user}",
    "gists_url": "https://api.github.com/users/github-actions%5Bbot%5D/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/github-actions%5Bbot%5D/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/github-actions%5Bbot%5D/subscriptions",
    "organizations_url": "https://api.github.com/users/github-actions%5Bbot%5D/orgs",
    "repos_url": "https://api.github.com/users/github-actions%5Bbot%5D/repos",
    "events_url": "https://api.github.com/users/github-actions%5Bbot%5D/events{/privacy}",
    "received_events_url": "https://api.github.com/users/github-actions%5Bbot%5D/received_events",
    "type": "Bot",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/719/reactions",
    "total_count": 12,
    "+1": 12,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/EIPs/issues/719/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/331417733",
    "html_url": "https://github.com/ethereum/EIPs/issues/719#issuecomment-331417733",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/719",
    "id": 331417733,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMTQxNzczMw==",
    "user": {
      "login": "onbjerg",
      "id": 8862627,
      "node_id": "MDQ6VXNlcjg4NjI2Mjc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/8862627?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/onbjerg",
      "html_url": "https://github.com/onbjerg",
      "followers_url": "https://api.github.com/users/onbjerg/followers",
      "following_url": "https://api.github.com/users/onbjerg/following{/other_user}",
      "gists_url": "https://api.github.com/users/onbjerg/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/onbjerg/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/onbjerg/subscriptions",
      "organizations_url": "https://api.github.com/users/onbjerg/orgs",
      "repos_url": "https://api.github.com/users/onbjerg/repos",
      "events_url": "https://api.github.com/users/onbjerg/events{/privacy}",
      "received_events_url": "https://api.github.com/users/onbjerg/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-09-22T11:02:26Z",
    "updated_at": "2017-09-22T11:05:36Z",
    "author_association": "NONE",
    "body": "One thing I would like of the DSL is that it is not like natspec, in that natspec is parsed using JavaScript's `eval`, which is pretty unsafe for ÃApps.\n\nThe DSL should be a lot more constrained, almost down to only variable substitution, or at most with a specific set of built-in functions and arithmetic (e.g. to render units of ether or similar).",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/331417733/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/331446918",
    "html_url": "https://github.com/ethereum/EIPs/issues/719#issuecomment-331446918",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/719",
    "id": 331446918,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMTQ0NjkxOA==",
    "user": {
      "login": "shrugs",
      "id": 1535001,
      "node_id": "MDQ6VXNlcjE1MzUwMDE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1535001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/shrugs",
      "html_url": "https://github.com/shrugs",
      "followers_url": "https://api.github.com/users/shrugs/followers",
      "following_url": "https://api.github.com/users/shrugs/following{/other_user}",
      "gists_url": "https://api.github.com/users/shrugs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/shrugs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/shrugs/subscriptions",
      "organizations_url": "https://api.github.com/users/shrugs/orgs",
      "repos_url": "https://api.github.com/users/shrugs/repos",
      "events_url": "https://api.github.com/users/shrugs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/shrugs/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-09-22T13:29:55Z",
    "updated_at": "2017-09-22T13:32:15Z",
    "author_association": "NONE",
    "body": "I'm not sure any amount of the display should be configured by the requester. For example, now the requester needs to know the user's language and construct the DSL dependent on that information. There's also no way to validate that the english text accurately describes the data that's being signed.\r\n\r\nI expect a structure-only approach to be a bit more flexible. Something along the lines of how [Open Graph tags](http://ogp.me/) work.\r\n\r\n```\r\ntype: 0xOrder\r\ntokenA: 0xabcde\r\ntokenB: 0xabcde\r\n... etc ... (ala https://0xproject.com/docs/0xjs#Order )\r\n```\r\n\r\nThen the signing interface can represent that however they'd want.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/331446918/reactions",
      "total_count": 2,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 1
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/331496114",
    "html_url": "https://github.com/ethereum/EIPs/issues/719#issuecomment-331496114",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/719",
    "id": 331496114,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMTQ5NjExNA==",
    "user": {
      "login": "MicahZoltu",
      "id": 886059,
      "node_id": "MDQ6VXNlcjg4NjA1OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886059?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MicahZoltu",
      "html_url": "https://github.com/MicahZoltu",
      "followers_url": "https://api.github.com/users/MicahZoltu/followers",
      "following_url": "https://api.github.com/users/MicahZoltu/following{/other_user}",
      "gists_url": "https://api.github.com/users/MicahZoltu/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MicahZoltu/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MicahZoltu/subscriptions",
      "organizations_url": "https://api.github.com/users/MicahZoltu/orgs",
      "repos_url": "https://api.github.com/users/MicahZoltu/repos",
      "events_url": "https://api.github.com/users/MicahZoltu/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MicahZoltu/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-09-22T16:31:42Z",
    "updated_at": "2017-09-22T16:31:42Z",
    "author_association": "MEMBER",
    "body": "@onbjerg Good thought on ensuring that whatever DSL we use is easily sandboxed by the implementing signer UI.  Having something like freeform HTML+JS is probably too hard to sandbox effectively and therefore not worth the benefits it may provide.\r\n\r\n@Shrugs You bring up a very good point about localization.  I hadn't considered that, and it does introduce quite a few problems.  The naive solution would be to make it so the contract can support a number of different DSL hashes (this is pretty easy) and then they can provide localized versions of the UI.  When someone audits the UI, they will need to _also_ audit all of the localized UIs though which means you need a multi-lingual group of auditers.  Also, localization is often done after launch and any changes to the UI DSL (or introducing new ones) would require a new contract deployment, which is unfortunate.\r\n\r\nI'm curious if anyone has thoughts on how to _securely_ do localization (other than the above)?\r\n\r\n@Shrugs The problem with just providing objects is that then the signers need to fully understand every dApp out there.  This would be like expecting your browser to know how to render every page on the internet natively, and websites just provide the browser with an object graph of data.  The 0x Order you linked is actually a really good example of the problem with this:\r\n```\r\n\texchangeContractAddress: string,\r\n\texpirationUnixTimestampSec: BigNumber,\r\n\tfeeRecipient: string,\r\n\tmaker: string,\r\n\tmakerFee: BigNumber,\r\n\tmakerTokenAddress: string,\r\n\tmakerTokenAmount: BigNumber,\r\n\tsalt: BigNumber,\r\n\ttaker: string,\r\n\ttakerFee: BigNumber,\r\n\ttakerTokenAddress: string,\r\n\ttakerTokenAmount: BigNumber,\r\n```\r\nGetting a brick of those options is _way_ too hard for an end-user to use.  They need someone to turn it into plain English (or whatever language) for them or layout the items in a way that makes it more clear what it all means.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/331496114/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/331500871",
    "html_url": "https://github.com/ethereum/EIPs/issues/719#issuecomment-331500871",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/719",
    "id": 331500871,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMTUwMDg3MQ==",
    "user": {
      "login": "danfinlay",
      "id": 542863,
      "node_id": "MDQ6VXNlcjU0Mjg2Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/542863?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/danfinlay",
      "html_url": "https://github.com/danfinlay",
      "followers_url": "https://api.github.com/users/danfinlay/followers",
      "following_url": "https://api.github.com/users/danfinlay/following{/other_user}",
      "gists_url": "https://api.github.com/users/danfinlay/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/danfinlay/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/danfinlay/subscriptions",
      "organizations_url": "https://api.github.com/users/danfinlay/orgs",
      "repos_url": "https://api.github.com/users/danfinlay/repos",
      "events_url": "https://api.github.com/users/danfinlay/events{/privacy}",
      "received_events_url": "https://api.github.com/users/danfinlay/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-09-22T16:51:24Z",
    "updated_at": "2017-09-22T16:51:24Z",
    "author_association": "CONTRIBUTOR",
    "body": "I like the general thrust of this proposal.\r\n\r\nLocalization is an interesting problem, and yet it actually seems perfect that it would be impossible to change the displayed terms of a contract, so now a UI template proposal is a big deal, requiring careful thought of developers who hope to use it, although they can always add a new signature type they accept.\r\n\r\nRather than choosing between multiple render types, I liked an idea by Gavin Wood a few signing discussions ago where we follow email's lead, and allow a series of signing UIs to be defined, in an order where the signer falls back to the richest view it supports.\r\n\r\nI think this could all be described as a new type for signTypedData, where the value links to a static hash (swarm or ipfs) of a config file that includes links to the different provided template types, and then their available languages.  A simple text template could be a first type, then maybe markdown or something with limited styles + substitutions, and eventually maybe even richer things still.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/331500871/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/331519186",
    "html_url": "https://github.com/ethereum/EIPs/issues/719#issuecomment-331519186",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/719",
    "id": 331519186,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMTUxOTE4Ng==",
    "user": {
      "login": "MicahZoltu",
      "id": 886059,
      "node_id": "MDQ6VXNlcjg4NjA1OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886059?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MicahZoltu",
      "html_url": "https://github.com/MicahZoltu",
      "followers_url": "https://api.github.com/users/MicahZoltu/followers",
      "following_url": "https://api.github.com/users/MicahZoltu/following{/other_user}",
      "gists_url": "https://api.github.com/users/MicahZoltu/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MicahZoltu/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MicahZoltu/subscriptions",
      "organizations_url": "https://api.github.com/users/MicahZoltu/orgs",
      "repos_url": "https://api.github.com/users/MicahZoltu/repos",
      "events_url": "https://api.github.com/users/MicahZoltu/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MicahZoltu/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-09-22T18:01:54Z",
    "updated_at": "2017-09-22T18:01:54Z",
    "author_association": "MEMBER",
    "body": "In my head, the contract would provide a public method like, `validateDslHash(bytes32) returns (bool)`.  This would allow the signer to ask the contract, \"is this a valid DSL?\" before presenting it to the user.  This would also allow for trustless signing of transactions (contract calls) with an enhanced UI, as long as the signer has access to a blockchain (sorry Ledger and offline MEW).  For off-chain signatures the hash can be embedded in the signed data so the contract could verify it when it goes to execute, which would allow Ledger/Offline-MEW to sign these things without direct access to a chain (assuming the DSL doesn't require any lookups to render).\r\n\r\nAs far as how the signer _receives_ the un-hashed DSL, I tentatively feel like that is a separate discussion.  It could be that the JSON-RPC methods take in a DSL as a parameter, leaving it up to the UI that wants something signed to provide the DSL to the signer.  Alternatively, it could be done via a specific method on the contract that returns a a number of hashes of the data for lookup in external systems (e.g., IPFS hash, Swarm hash, Storj hash, MaidSafe hash, S3 address, etc.).\r\n\r\nAt the moment, without compelling counterargument, I would like to leave the \"how does the signer get the DSL\" for a separate EIP that we can discuss after we have settled on what the DSL looks like and how it is used.  I can forsee there being several different EIPs for DSL acquisition and I don't want one to hold up the others.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/331519186/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/331519800",
    "html_url": "https://github.com/ethereum/EIPs/issues/719#issuecomment-331519800",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/719",
    "id": 331519800,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMTUxOTgwMA==",
    "user": {
      "login": "MicahZoltu",
      "id": 886059,
      "node_id": "MDQ6VXNlcjg4NjA1OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886059?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MicahZoltu",
      "html_url": "https://github.com/MicahZoltu",
      "followers_url": "https://api.github.com/users/MicahZoltu/followers",
      "following_url": "https://api.github.com/users/MicahZoltu/following{/other_user}",
      "gists_url": "https://api.github.com/users/MicahZoltu/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MicahZoltu/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MicahZoltu/subscriptions",
      "organizations_url": "https://api.github.com/users/MicahZoltu/orgs",
      "repos_url": "https://api.github.com/users/MicahZoltu/repos",
      "events_url": "https://api.github.com/users/MicahZoltu/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MicahZoltu/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-09-22T18:04:17Z",
    "updated_at": "2017-09-22T18:04:17Z",
    "author_association": "MEMBER",
    "body": "Forgot to actually respond to your direct comment.  I think the concept of \"ordering DSLs\" would be up to whatever the mechanism for acquiring DSLs is.  If the UI sends the DSL as part of an RPC call, then that RPC call would perhaps take an ordered list of DSLs.  If the signer fetches the DSL from a URI that the contract returns, then the contract could return an ordered array of addresses.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/331519800/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/331616166",
    "html_url": "https://github.com/ethereum/EIPs/issues/719#issuecomment-331616166",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/719",
    "id": 331616166,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMTYxNjE2Ng==",
    "user": {
      "login": "Arachnid",
      "id": 17865,
      "node_id": "MDQ6VXNlcjE3ODY1",
      "avatar_url": "https://avatars.githubusercontent.com/u/17865?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Arachnid",
      "html_url": "https://github.com/Arachnid",
      "followers_url": "https://api.github.com/users/Arachnid/followers",
      "following_url": "https://api.github.com/users/Arachnid/following{/other_user}",
      "gists_url": "https://api.github.com/users/Arachnid/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Arachnid/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Arachnid/subscriptions",
      "organizations_url": "https://api.github.com/users/Arachnid/orgs",
      "repos_url": "https://api.github.com/users/Arachnid/repos",
      "events_url": "https://api.github.com/users/Arachnid/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Arachnid/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-09-23T07:07:59Z",
    "updated_at": "2017-09-23T07:07:59Z",
    "author_association": "MEMBER",
    "body": "I like the idea of using the hash of the DSL to allow the contract to verify the user was presented with the correct description; it neatly cuts the gordian knot of where to store the DSL data.\r\n\r\nWe really need `validateDSLHash` as a primitive, though, or else this is only usable for message signing, not transaction signing.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/331616166/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/338408810",
    "html_url": "https://github.com/ethereum/EIPs/issues/719#issuecomment-338408810",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/719",
    "id": 338408810,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzODQwODgxMA==",
    "user": {
      "login": "VictorTaelin",
      "id": 13090166,
      "node_id": "MDQ6VXNlcjEzMDkwMTY2",
      "avatar_url": "https://avatars.githubusercontent.com/u/13090166?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/VictorTaelin",
      "html_url": "https://github.com/VictorTaelin",
      "followers_url": "https://api.github.com/users/VictorTaelin/followers",
      "following_url": "https://api.github.com/users/VictorTaelin/following{/other_user}",
      "gists_url": "https://api.github.com/users/VictorTaelin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/VictorTaelin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/VictorTaelin/subscriptions",
      "organizations_url": "https://api.github.com/users/VictorTaelin/orgs",
      "repos_url": "https://api.github.com/users/VictorTaelin/repos",
      "events_url": "https://api.github.com/users/VictorTaelin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/VictorTaelin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-21T15:04:56Z",
    "updated_at": "2017-10-21T15:04:56Z",
    "author_association": "MEMBER",
    "body": "What you describe sounds exactly what Moon-Lang is, a very simple UI description DSL I'll be presenting at devcon. It allows you to specify interfaces as a tree of nested boxes. Each box can render pixels to screen, manage an internal state and talk to Ethereum. You can copy/paste someone else's component on your own DApp safely, making the whole web very forkable. Moon's AST has very few constructors, a compact binary format and you could write a full interpreter in any language in about 150Â LOCs.\r\n\r\nFeel free to try it:\r\n\r\nhttps://gateway.ipfs.io/ipfs/QmSCvGcufJ38g7ELYoUHdGmjyUekgB85No4xBeDWMRMEis/\r\n\r\nClick the fork button above and change something to see how forking works. Then click the moon button to see a simple wallet demo. Also click the links on the code to enter sub-components, which can also be safely forked by copying their hashes.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/338408810/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/338414028",
    "html_url": "https://github.com/ethereum/EIPs/issues/719#issuecomment-338414028",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/719",
    "id": 338414028,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzODQxNDAyOA==",
    "user": {
      "login": "shrugs",
      "id": 1535001,
      "node_id": "MDQ6VXNlcjE1MzUwMDE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1535001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/shrugs",
      "html_url": "https://github.com/shrugs",
      "followers_url": "https://api.github.com/users/shrugs/followers",
      "following_url": "https://api.github.com/users/shrugs/following{/other_user}",
      "gists_url": "https://api.github.com/users/shrugs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/shrugs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/shrugs/subscriptions",
      "organizations_url": "https://api.github.com/users/shrugs/orgs",
      "repos_url": "https://api.github.com/users/shrugs/repos",
      "events_url": "https://api.github.com/users/shrugs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/shrugs/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-21T16:20:03Z",
    "updated_at": "2017-10-21T16:20:03Z",
    "author_association": "NONE",
    "body": "@MicahZoltu sorry it took me so long to get back to this, I think I missed the notification.\r\n\r\nIn the \"OpenGraph tags\" scenario, my transaction request would first conform to a type like `EthereumTransaction`, supporting fields like `contract`, `value`, `gasLimit`, etc, which all signing interfaces would be expected to support at the minimum.\r\n\r\nMy transaction request would also conform to `0xOrder`, supporting 0x-specific tags like mentioned above. There should be one format (the generic `EthereumTransaction`) that everyone knows how to render (basically the `title`, `image`, `url` of the web, and opting into more specific types (`article`, `video`, `music`, etc) is 1) optional for the transaction requester and 2) optional for the signing interface to implement. \r\n\r\nArbitrary tx types can be defined and optionally supported (`ERC20Transfer`, `EthereumFoundationDonation`, etc).\r\n\r\n---\r\n\r\nI see the need to validate the signing interface itself, though; if you delegate all display to the signing interface, there's absolutely no way for you to know for certain whether or not what you see is what's being signed (unless you look at the code or write it, blah blah). But going down the path of \"validating UIs\" seems like a real rabbit hole.\r\n\r\nThat said, the idea of signing both the message and \"this is how I presented this transaction\" is pretty clever, and definitely solves the main problem.\r\n\r\n---\r\n\r\nPerhaps the best move is a little of both worlds? Signing UIs present two displays, one above the other. One is a rich interface of their choosing, which we don't validate the presentation of. This could conform to the opengraph tag model. \r\n\r\nUnderneath this rich display is the pure-text DSL representing the same information. This DSL is either provided by the transaction requester or looked up in the store of DSLs (with all of the localizations provided). There can be different versions of this DSL beyond the `EthereumTransaction` type, just like the rich interface.\r\n\r\n```\r\nEthereumTransaction: \"this is a transaction to 0xabcde with data `AA BB` and value 0.5ETH with a gasPrice of 4Gwei\"\r\nERC20 Transfer: \"this is a transfer of 5 TKN from 0xabcde to 0xfghij\"\r\n0xOrder: \"This is an order trading 5 TKN for 10 WETH, expiring at {time}\"\r\n```\r\n\r\n---\r\n\r\nJust a note, I don't see a point in validating markdown; it'll be presented to the user as html, which defeats the purpose. Actually, now that I think about it, there's no guarantee that the signing ui will present the correct DSL to the user, regardless of what it is, but still sign the correct one. The only way to circumvent this would be to have the user copy/paste the text shown by the signing UI into the transaction requester's interface so that they can double check that that's what was shown. (unless I'm missing something). ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/338414028/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/338457018",
    "html_url": "https://github.com/ethereum/EIPs/issues/719#issuecomment-338457018",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/719",
    "id": 338457018,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzODQ1NzAxOA==",
    "user": {
      "login": "MicahZoltu",
      "id": 886059,
      "node_id": "MDQ6VXNlcjg4NjA1OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886059?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MicahZoltu",
      "html_url": "https://github.com/MicahZoltu",
      "followers_url": "https://api.github.com/users/MicahZoltu/followers",
      "following_url": "https://api.github.com/users/MicahZoltu/following{/other_user}",
      "gists_url": "https://api.github.com/users/MicahZoltu/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MicahZoltu/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MicahZoltu/subscriptions",
      "organizations_url": "https://api.github.com/users/MicahZoltu/orgs",
      "repos_url": "https://api.github.com/users/MicahZoltu/repos",
      "events_url": "https://api.github.com/users/MicahZoltu/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MicahZoltu/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-22T07:09:46Z",
    "updated_at": "2017-10-22T07:09:46Z",
    "author_association": "MEMBER",
    "body": "@MaiaVictor Can you provide some detail as to why you decided to author a new DSL/renderer rather than using an existing one like XHTML?  I looked at the moon-lang GitHub readme, it seems that you are trying to build a compile-to-javascript language (like Elm), or am I mistaken?\r\n\r\n----\r\n\r\n@Shrugs I'm not a fan of signing tools having baked in forms for things like ERC20 transfers or EthereumFoundationDonation because this doesn't scale at all.  That would be like Chrome/Edge/Firefox having the built-in ability to render very specific pages on the internet rather than being able to render any page on the internet.\r\n\r\nRegarding the trust issue, the user already has explicitly trusted the signing UI since the signing UI has full access to the user's private keys and password.  Because of this, we can assume that the UI is going to do its best to present the user with the most accurate information possible, and in this case that means presenting the user with a signing UI that is verifiably associated with the contract being interacted with.  The goal here is to make it so the user _only_ needs to trust their signing UI of choice and the contract they are interacting with, they do not _also_ need to fully trust the dapp UI.  A great example of this is EtherDelta, where the contracts are immutable and have been vetted by a number of parties.  The dapp UI on the other hand is a traditional centralized interface and should _not_ be trusted.  At the moment, when the user signs something on request from the dapp UI, the user doesn't have any good way of validating that what they are signing is what they intended.  They must trust that the UI isn't asking them to sign something malicious, and this is _not_ a great trust model.\r\n\r\nRegarding Open Graph tags, without a mechanism for validation I don't think adding them really helps the situation at all.  Either you trust the dapp UI, in which case we don't need anything more than \"dapp has requested a signature\" or you don't trust the dapp UI, in which case anything it provides without validation could be malicious.  The goal of this proposal is specifically scoped to solving the untrusted dapp UI + trusted contract problem.  A solution to this would allow someone to put a \"donate ABC tokens\" button on their blog (untrusted) and a user using an Ethereum enabled browser (Parity, MetaMask, Mist, etc.) would be able to click that button and send ABC token without having to trust the website author.  They only need to trust their browser and the ABC token contract.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/338457018/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/338471138",
    "html_url": "https://github.com/ethereum/EIPs/issues/719#issuecomment-338471138",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/719",
    "id": 338471138,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzODQ3MTEzOA==",
    "user": {
      "login": "shrugs",
      "id": 1535001,
      "node_id": "MDQ6VXNlcjE1MzUwMDE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1535001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/shrugs",
      "html_url": "https://github.com/shrugs",
      "followers_url": "https://api.github.com/users/shrugs/followers",
      "following_url": "https://api.github.com/users/shrugs/following{/other_user}",
      "gists_url": "https://api.github.com/users/shrugs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/shrugs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/shrugs/subscriptions",
      "organizations_url": "https://api.github.com/users/shrugs/orgs",
      "repos_url": "https://api.github.com/users/shrugs/repos",
      "events_url": "https://api.github.com/users/shrugs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/shrugs/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-22T11:44:41Z",
    "updated_at": "2017-10-22T11:44:41Z",
    "author_association": "NONE",
    "body": "I realized where my misunderstanding was: the proposal is to find a way for the _contract itself_ to verify that the user was informed correctly, in the name of consumer protection.\r\n\r\nI personally don't think that that's the domain of a contract, but I could see situations where it would be beneficial. At the same time, though, I expect the majority of \"uninformed user\" issues could be solved by a comprehensive signing UI that \"upgrades\" raw ethereum txs into a richer representation. The dapp gives the signing ui the `rawTx` (is this not what's currently happening?)\r\n\r\n```\r\n {\r\n  nonce: '0x00',\r\n  gasPrice: '0x09184e72a000', \r\n  gasLimit: '0x2710',\r\n  to: '0x0000000000000000000000000000000000000000', \r\n  value: '0x00', \r\n  data: '0x7f7465737432000000000000000000000000000000000000000000000000000000600057'\r\n}\r\n```\r\n\r\nand then the UI displays that information, upgrading the experience if it is able to. The dapp doesn't need to do any of the opengraph stuff because the signing ui can check to see if the `to` contract is a token contract and it can parse the data to determine function calls and arguments. It could even local test the transaction to estimate the state changes that would occur, to really inform the user about what will happen when they submit the transaction.\r\n\r\nIn this case the opengraph stuff isn't necessary, apologies for that tangent.\r\n\r\n---\r\n\r\nIf having the contract verify that the user was informed correctly is necessary, the signed raw-text DSL approach (with multiple localizations) is probably a good option?\r\n\r\nAlthough at this point the contract is still trusting the signing ui to actually display this DSL, and if we trust the signing UI we should also just trust the transaction that it signs, defeating this whole purpose. I suppose this approach would limit users to using signing uis that know how to request and sign the dsl, which is basically a quality gateway for \"signing ui that doesn't suck\".\r\n\r\n---\r\n\r\nI guess my opinion boils down to \"we need better signing uis\" rather than \"we need a trust relationship between signing uis and contracts to avoid trusting the dapp middlemen\".",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/338471138/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/338711818",
    "html_url": "https://github.com/ethereum/EIPs/issues/719#issuecomment-338711818",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/719",
    "id": 338711818,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzODcxMTgxOA==",
    "user": {
      "login": "MicahZoltu",
      "id": 886059,
      "node_id": "MDQ6VXNlcjg4NjA1OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886059?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MicahZoltu",
      "html_url": "https://github.com/MicahZoltu",
      "followers_url": "https://api.github.com/users/MicahZoltu/followers",
      "following_url": "https://api.github.com/users/MicahZoltu/following{/other_user}",
      "gists_url": "https://api.github.com/users/MicahZoltu/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MicahZoltu/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MicahZoltu/subscriptions",
      "organizations_url": "https://api.github.com/users/MicahZoltu/orgs",
      "repos_url": "https://api.github.com/users/MicahZoltu/repos",
      "events_url": "https://api.github.com/users/MicahZoltu/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MicahZoltu/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-23T16:12:01Z",
    "updated_at": "2017-10-23T16:12:01Z",
    "author_association": "MEMBER",
    "body": "> the signing ui can check to see if the to contract is a token contract and it can parse the data to determine function calls and arguments\r\n\r\n@Shrugs How would it detect the target contract is a token?  How would it get the function name and argument types from the call data?  How would it deal with non-token contracts (Ethereum smart contracts are far more than just \"a bunch of tokens\")?\r\n\r\n----\r\n\r\n> having the contract verify that the user was informed correctly\r\n\r\nThis proposal isn't about having the smart contract verify the user was informed correctly, it is about allowing the signing UI to present an informed consent signing UI to the user in a way that does not rely on trusting the dapp UI.  Dapp UIs should _not_ be trusted in most cases, dapp trust ends at the contract, so we need a mechanism that allows for the dapp to provide the signing UI to the signing tool without the dapp UI being trusted.\r\n\r\n----\r\n\r\n> I guess my opinion boils down to \"we need better signing uis\"\r\n\r\nThat is the point of this proposal.  ðŸ˜„ I suspect you are trying to solve the problem in the same way I was originally, which is to have the signing tool automatically present the user with transaction details, much like Parity does already.  The problem is that while this _may_ be useful to developers, it isn't useful to non-tech savvy end users because function names and parameters are not meaningful to them.  By allowing the dapp to specify how the information that needs to be signed is presented to the user, the dapp author can build a signing UI that makes sense for their transactions and is user friendly.  However, we need a way for the dapp to get the custom signing UI to the signing tool without having to trust the dapp UI, which is why the contract will have the ability to validate whether any particular UI DSL should be trusted.  This way, the dapp UI can give the signing tool the signing UI, and then the signing tool can validate that the provided signing UI can be trusted (by validating its hash against the target contract).",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/338711818/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/338719231",
    "html_url": "https://github.com/ethereum/EIPs/issues/719#issuecomment-338719231",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/719",
    "id": 338719231,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzODcxOTIzMQ==",
    "user": {
      "login": "shrugs",
      "id": 1535001,
      "node_id": "MDQ6VXNlcjE1MzUwMDE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1535001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/shrugs",
      "html_url": "https://github.com/shrugs",
      "followers_url": "https://api.github.com/users/shrugs/followers",
      "following_url": "https://api.github.com/users/shrugs/following{/other_user}",
      "gists_url": "https://api.github.com/users/shrugs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/shrugs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/shrugs/subscriptions",
      "organizations_url": "https://api.github.com/users/shrugs/orgs",
      "repos_url": "https://api.github.com/users/shrugs/repos",
      "events_url": "https://api.github.com/users/shrugs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/shrugs/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-23T16:36:41Z",
    "updated_at": "2017-10-23T16:36:41Z",
    "author_association": "NONE",
    "body": "Ah, I've got a better understanding of what we're trying to do now, thank you. I don't have much more to add, then ðŸ˜„ ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/338719231/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/342605599",
    "html_url": "https://github.com/ethereum/EIPs/issues/719#issuecomment-342605599",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/719",
    "id": 342605599,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0MjYwNTU5OQ==",
    "user": {
      "login": "danfinlay",
      "id": 542863,
      "node_id": "MDQ6VXNlcjU0Mjg2Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/542863?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/danfinlay",
      "html_url": "https://github.com/danfinlay",
      "followers_url": "https://api.github.com/users/danfinlay/followers",
      "following_url": "https://api.github.com/users/danfinlay/following{/other_user}",
      "gists_url": "https://api.github.com/users/danfinlay/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/danfinlay/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/danfinlay/subscriptions",
      "organizations_url": "https://api.github.com/users/danfinlay/orgs",
      "repos_url": "https://api.github.com/users/danfinlay/repos",
      "events_url": "https://api.github.com/users/danfinlay/events{/privacy}",
      "received_events_url": "https://api.github.com/users/danfinlay/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-11-07T20:06:04Z",
    "updated_at": "2017-11-07T20:06:04Z",
    "author_association": "CONTRIBUTOR",
    "body": "Iâ€™m concerned that trusting a smart contract for its own UI template could be dangerous, since a smart contract *could* be deployed to resemble some other smart contract, or to mis-represent what itâ€™s really doing.\r\n\r\nWhile this might be a nice way to represent signing operations in the meanwhile, I think the longer-term solution to good tx review will be something more like signers that know how to actually represent the likely effects of processing a transaction.\r\n\r\nDo people really want to trust arbitrary smart contracts to provide their own approval UIs? How is that much better than trusting malicious UIs in the first place? It may not be sustainable to make custom approval UIs for each kind of operation, but it seems more trustless to me than showing whatever a contract wants.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/342605599/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/342718334",
    "html_url": "https://github.com/ethereum/EIPs/issues/719#issuecomment-342718334",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/719",
    "id": 342718334,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0MjcxODMzNA==",
    "user": {
      "login": "Arachnid",
      "id": 17865,
      "node_id": "MDQ6VXNlcjE3ODY1",
      "avatar_url": "https://avatars.githubusercontent.com/u/17865?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Arachnid",
      "html_url": "https://github.com/Arachnid",
      "followers_url": "https://api.github.com/users/Arachnid/followers",
      "following_url": "https://api.github.com/users/Arachnid/following{/other_user}",
      "gists_url": "https://api.github.com/users/Arachnid/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Arachnid/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Arachnid/subscriptions",
      "organizations_url": "https://api.github.com/users/Arachnid/orgs",
      "repos_url": "https://api.github.com/users/Arachnid/repos",
      "events_url": "https://api.github.com/users/Arachnid/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Arachnid/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-11-08T05:54:26Z",
    "updated_at": "2017-11-08T05:54:26Z",
    "author_association": "MEMBER",
    "body": "> Iâ€™m concerned that trusting a smart contract for its own UI template could be dangerous, since a smart contract could be deployed to resemble some other smart contract, or to mis-represent what itâ€™s really doing.\r\n\r\nIs that a viable threat model, though? If you audit the code, you can determine what it does and how it presents it. If you don't, there are far easier ways that already exist for the contract to do nasty stuff - although in either case they're limited unless you're sending ether to it or authorising it to act on other contracts.\r\n\r\n> Do people really want to trust arbitrary smart contracts to provide their own approval UIs? \r\n\r\nAbsent a threat model that demonstrates why it's a bad idea, absolutely.\r\n\r\n> How is that much better than trusting malicious UIs in the first place?\r\n\r\nThe contract has a vested incentive to represent actions on itself clearly. The UI interacting with it may not, because it may be owned by another party.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/342718334/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/342719710",
    "html_url": "https://github.com/ethereum/EIPs/issues/719#issuecomment-342719710",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/719",
    "id": 342719710,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0MjcxOTcxMA==",
    "user": {
      "login": "MicahZoltu",
      "id": 886059,
      "node_id": "MDQ6VXNlcjg4NjA1OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886059?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MicahZoltu",
      "html_url": "https://github.com/MicahZoltu",
      "followers_url": "https://api.github.com/users/MicahZoltu/followers",
      "following_url": "https://api.github.com/users/MicahZoltu/following{/other_user}",
      "gists_url": "https://api.github.com/users/MicahZoltu/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MicahZoltu/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MicahZoltu/subscriptions",
      "organizations_url": "https://api.github.com/users/MicahZoltu/orgs",
      "repos_url": "https://api.github.com/users/MicahZoltu/repos",
      "events_url": "https://api.github.com/users/MicahZoltu/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MicahZoltu/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-11-08T06:04:03Z",
    "updated_at": "2017-11-08T06:04:03Z",
    "author_association": "MEMBER",
    "body": "@danfinlay Aside from the comments from @Arachnid, keep in mind that a contract can only show its _own_ signing UI.  A contract cannot define what you see when signing on behalf of a _different_ contract.  This means that if my dapp needs approval for a token, I'll get the token's approval UI and not whatever the dapp contracts would have wanted to show me.  As @Arachnid indicated, the risk is with sending ETH and there is an argument for having ETH values _always_ be part of the meta-UI so a dapp that chooses not to present the ETH being transferred can't transfer ETH on the sly.  For everything else, you are interacting with the contract so there isn't anything malicious a dapp could present to you to \"trick\" you into signing something you otherwise wouldn't.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/342719710/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/345076128",
    "html_url": "https://github.com/ethereum/EIPs/issues/719#issuecomment-345076128",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/719",
    "id": 345076128,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0NTA3NjEyOA==",
    "user": {
      "login": "danfinlay",
      "id": 542863,
      "node_id": "MDQ6VXNlcjU0Mjg2Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/542863?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/danfinlay",
      "html_url": "https://github.com/danfinlay",
      "followers_url": "https://api.github.com/users/danfinlay/followers",
      "following_url": "https://api.github.com/users/danfinlay/following{/other_user}",
      "gists_url": "https://api.github.com/users/danfinlay/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/danfinlay/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/danfinlay/subscriptions",
      "organizations_url": "https://api.github.com/users/danfinlay/orgs",
      "repos_url": "https://api.github.com/users/danfinlay/repos",
      "events_url": "https://api.github.com/users/danfinlay/events{/privacy}",
      "received_events_url": "https://api.github.com/users/danfinlay/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-11-16T21:58:50Z",
    "updated_at": "2017-11-16T21:58:50Z",
    "author_association": "CONTRIBUTOR",
    "body": "It took me a while, because it's a lot safer to be cautious than confident that there are no dangers, but I think I've come around. I can't see any serious issues with this anymore, I'm on board.\r\n\r\nAfter seeing MoonLang at DevCon, I can see why @MaiaVictor would suggest it here, it seems like a solution to the very \"untrusted DSL\" question that this opening issue was asking for, and so I'm interested in exploring it a bit more for this solution.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/345076128/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/348724068",
    "html_url": "https://github.com/ethereum/EIPs/issues/719#issuecomment-348724068",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/719",
    "id": 348724068,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0ODcyNDA2OA==",
    "user": {
      "login": "axic",
      "id": 20340,
      "node_id": "MDQ6VXNlcjIwMzQw",
      "avatar_url": "https://avatars.githubusercontent.com/u/20340?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/axic",
      "html_url": "https://github.com/axic",
      "followers_url": "https://api.github.com/users/axic/followers",
      "following_url": "https://api.github.com/users/axic/following{/other_user}",
      "gists_url": "https://api.github.com/users/axic/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/axic/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/axic/subscriptions",
      "organizations_url": "https://api.github.com/users/axic/orgs",
      "repos_url": "https://api.github.com/users/axic/repos",
      "events_url": "https://api.github.com/users/axic/events{/privacy}",
      "received_events_url": "https://api.github.com/users/axic/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-12-02T22:14:58Z",
    "updated_at": "2017-12-02T22:14:58Z",
    "author_association": "MEMBER",
    "body": "Wouldnâ€™t it make sense creating a format as a successor to natspec to incorporate all this? Natspecâ€™s aim was basically the same with the difference it operates on individial functions and cannot describe a process which involves mutliple calls.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/348724068/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/348727925",
    "html_url": "https://github.com/ethereum/EIPs/issues/719#issuecomment-348727925",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/719",
    "id": 348727925,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0ODcyNzkyNQ==",
    "user": {
      "login": "MicahZoltu",
      "id": 886059,
      "node_id": "MDQ6VXNlcjg4NjA1OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886059?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MicahZoltu",
      "html_url": "https://github.com/MicahZoltu",
      "followers_url": "https://api.github.com/users/MicahZoltu/followers",
      "following_url": "https://api.github.com/users/MicahZoltu/following{/other_user}",
      "gists_url": "https://api.github.com/users/MicahZoltu/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MicahZoltu/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MicahZoltu/subscriptions",
      "organizations_url": "https://api.github.com/users/MicahZoltu/orgs",
      "repos_url": "https://api.github.com/users/MicahZoltu/repos",
      "events_url": "https://api.github.com/users/MicahZoltu/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MicahZoltu/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-12-02T23:26:41Z",
    "updated_at": "2017-12-02T23:26:41Z",
    "author_association": "MEMBER",
    "body": "I think that whatever DSL we come up with can (and maybe should) be used both in NatSpec and in this.  This simplifies the number of DSLs the contract author needs to learn.  I am a little hesitant to assert an integration with NatSpec because that will change the set of stake holders involved in defining the spec, which will increase the chance of disagreement (different goals) as well as increase the time it takes to actually get things moving forward.  NatSpec is a compiler+signer feature, whereas this is a contract+signer feature.  Combining the two would mean compiler+contract+signer all need to agree on something reasonable.\r\n\r\nI'm thinking that maybe what we should do with this spec is first define the mechanisms by which we can store/transmit/validate/present DSLs, but don't actually define a DSL.  We can then have a _very_ simple DSL that just lets you have a template string with to/from/value/gas/gasprice replacement variables in it and nothing else as the v1 DSL.  We can then have separate discussions for future DSLs and as long as the system supports multiple DSLs then we can iterate on them at whatever speed we want, and iterate on them separately.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/348727925/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/348729288",
    "html_url": "https://github.com/ethereum/EIPs/issues/719#issuecomment-348729288",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/719",
    "id": 348729288,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0ODcyOTI4OA==",
    "user": {
      "login": "MicahZoltu",
      "id": 886059,
      "node_id": "MDQ6VXNlcjg4NjA1OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886059?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MicahZoltu",
      "html_url": "https://github.com/MicahZoltu",
      "followers_url": "https://api.github.com/users/MicahZoltu/followers",
      "following_url": "https://api.github.com/users/MicahZoltu/following{/other_user}",
      "gists_url": "https://api.github.com/users/MicahZoltu/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MicahZoltu/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MicahZoltu/subscriptions",
      "organizations_url": "https://api.github.com/users/MicahZoltu/orgs",
      "repos_url": "https://api.github.com/users/MicahZoltu/repos",
      "events_url": "https://api.github.com/users/MicahZoltu/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MicahZoltu/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-12-02T23:55:52Z",
    "updated_at": "2017-12-03T19:19:33Z",
    "author_association": "MEMBER",
    "body": "Just had a discussion in Gitter that had a result that I think is valuable to record as an example for posterity, and share with others.  The following is a concrete example of the whole process of a token transfer using a fairly simple example DSL that can do constant contract calls and reference transaction variables:\r\n\r\nThe token's transfer method would look something like:\r\n> ```\r\n> transfer(uint256 amount, address destination, bytes32 presentationHash) {\r\n>     require(acceptablePresentationHashes[presentationHash]);\r\n>     balances[msg.sender] -= amount;\r\n>     balances[destination] += amount;\r\n> }\r\n> ```\r\n\r\nThe UI would send the following data to the signer via a new `eth_signTransaction` RPC endpoint:\r\n> signature: transfer(uint256 amount, address destination, bytes32 presentationHash);\r\n> to: <token_address>\r\n> gas: 0x30D40\r\n> gasPrice: 0x\r\n> value: 0x0\r\n> param.amount: 0xE\r\n> param.destination: 0x1234abcd\r\n> presentation: You are transferring ${amount / 10 ** to.decimals()} ABC tokens to ${0xENSADDRESS.resolve(destination)}.\r\n\r\nThe signer would present the user with the following transaction to sign:\r\n> You are transferring 15 ABC tokens to MicahZoltu.eth.\r\n\r\nThe signer would include the following as the `presentationHash` parameter to the underlying contract, as part of the transaction it signs:\r\n> keccak256('You are transferring ${amount / to.decimals()} ABC tokens to ${0xENSADDRESS.resolve(destination)}.')",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/348729288/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/348806607",
    "html_url": "https://github.com/ethereum/EIPs/issues/719#issuecomment-348806607",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/719",
    "id": 348806607,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0ODgwNjYwNw==",
    "user": {
      "login": "carver",
      "id": 205327,
      "node_id": "MDQ6VXNlcjIwNTMyNw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/205327?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/carver",
      "html_url": "https://github.com/carver",
      "followers_url": "https://api.github.com/users/carver/followers",
      "following_url": "https://api.github.com/users/carver/following{/other_user}",
      "gists_url": "https://api.github.com/users/carver/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/carver/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/carver/subscriptions",
      "organizations_url": "https://api.github.com/users/carver/orgs",
      "repos_url": "https://api.github.com/users/carver/repos",
      "events_url": "https://api.github.com/users/carver/events{/privacy}",
      "received_events_url": "https://api.github.com/users/carver/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-12-03T19:14:00Z",
    "updated_at": "2017-12-03T19:14:00Z",
    "author_association": "MEMBER",
    "body": "`presentation` looks like it's missing a `10^decimals`:\r\n> `keccak256('You are transferring ${amount / 10 ** to.decimals()} ABC tokens to ${0xENSADDRESS.resolve(destination)}.')`\r\n\r\nAm I reading this right that the UI would send the hex address of the destination, and the signer would do a reverse lookup to display the ENS name? Since anyone can set their address to reverse-resolve to any name they choose, this spec should require forward resolution after reverse resolution, to confirm validity.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/348806607/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/348807142",
    "html_url": "https://github.com/ethereum/EIPs/issues/719#issuecomment-348807142",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/719",
    "id": 348807142,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0ODgwNzE0Mg==",
    "user": {
      "login": "MicahZoltu",
      "id": 886059,
      "node_id": "MDQ6VXNlcjg4NjA1OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886059?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MicahZoltu",
      "html_url": "https://github.com/MicahZoltu",
      "followers_url": "https://api.github.com/users/MicahZoltu/followers",
      "following_url": "https://api.github.com/users/MicahZoltu/following{/other_user}",
      "gists_url": "https://api.github.com/users/MicahZoltu/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MicahZoltu/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MicahZoltu/subscriptions",
      "organizations_url": "https://api.github.com/users/MicahZoltu/orgs",
      "repos_url": "https://api.github.com/users/MicahZoltu/repos",
      "events_url": "https://api.github.com/users/MicahZoltu/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MicahZoltu/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-12-03T19:21:54Z",
    "updated_at": "2017-12-03T19:21:54Z",
    "author_association": "MEMBER",
    "body": "Fixed the `10^`, thanks!  As for the ENS thing, this was meant to just be an example and assumes that `.resolve` will do all of the magic necessary to validate the name is the one the address owner actually wants displayed.  Lots of hand waving around that part, I really just wanted to show how calling some well-known-contract _might_ be done as part of a signing UI.  ðŸ˜„ ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/348807142/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/370958102",
    "html_url": "https://github.com/ethereum/EIPs/issues/719#issuecomment-370958102",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/719",
    "id": 370958102,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM3MDk1ODEwMg==",
    "user": {
      "login": "jstoxrocky",
      "id": 5459666,
      "node_id": "MDQ6VXNlcjU0NTk2NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5459666?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jstoxrocky",
      "html_url": "https://github.com/jstoxrocky",
      "followers_url": "https://api.github.com/users/jstoxrocky/followers",
      "following_url": "https://api.github.com/users/jstoxrocky/following{/other_user}",
      "gists_url": "https://api.github.com/users/jstoxrocky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jstoxrocky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jstoxrocky/subscriptions",
      "organizations_url": "https://api.github.com/users/jstoxrocky/orgs",
      "repos_url": "https://api.github.com/users/jstoxrocky/repos",
      "events_url": "https://api.github.com/users/jstoxrocky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jstoxrocky/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-03-06T22:51:59Z",
    "updated_at": "2018-03-06T22:51:59Z",
    "author_association": "CONTRIBUTOR",
    "body": "@MicahZoltu Do you have any thoughts on what you expect a concrete example to look like for signing arbitrary data? Something like this for a state-channel-like example?\r\n\r\nThe contract's function would look something like this:\r\n ```\r\nverify(uint8 v, bytes32 r, bytes32 s, uint256 amount, address recipient, bytes32 presentationHash) {\r\n  bytes32 messageHash = keccak256(amount, destination, presentationHash); \r\n  address signer = ecrecover(messageHash, v, r, s);\r\n  ...\r\n}\r\n```\r\n \r\nThe UI would send the following data to the signer via a new eth_signArbitraryMessage RPC endpoint(?):\r\n\r\n> amount: 0x38d7ea4c68000\r\n> recipient: 0x1234abcd\r\n> presentation: You are signing an IOU allowing ${0xENSADDRESS.resolve(recipient)} to withdraw ${web3.utils.fromWei(amount)} ETH from the MyDapp state-channel. \r\n\r\nThe signer would present the user with the following transaction to sign:\r\n\r\n> You are signing an IOU allowing jstoxrocky.eth to withdraw 0.001 ETH from the MyDapp state-channel. \r\n\r\nThe signer would include the following as the presentationHash parameter to the underlying contract as part: \r\n\r\n> keccak256(â€˜You are signing an IOU allowing ${0xENSADDRESS.resolve(recipient)} to withdraw ${web3.utils.fromWei(amount)} ETH from the MyDapp state-channel.â€™)",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/370958102/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/371024303",
    "html_url": "https://github.com/ethereum/EIPs/issues/719#issuecomment-371024303",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/719",
    "id": 371024303,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM3MTAyNDMwMw==",
    "user": {
      "login": "MicahZoltu",
      "id": 886059,
      "node_id": "MDQ6VXNlcjg4NjA1OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886059?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MicahZoltu",
      "html_url": "https://github.com/MicahZoltu",
      "followers_url": "https://api.github.com/users/MicahZoltu/followers",
      "following_url": "https://api.github.com/users/MicahZoltu/following{/other_user}",
      "gists_url": "https://api.github.com/users/MicahZoltu/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MicahZoltu/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MicahZoltu/subscriptions",
      "organizations_url": "https://api.github.com/users/MicahZoltu/orgs",
      "repos_url": "https://api.github.com/users/MicahZoltu/repos",
      "events_url": "https://api.github.com/users/MicahZoltu/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MicahZoltu/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-03-07T05:07:31Z",
    "updated_at": "2018-03-07T05:07:31Z",
    "author_association": "MEMBER",
    "body": "I think for state channel updates I would do something like,\r\n> You are updating the state channel to: You have 0.997 ETH; jstoxrocky.eth has 0.003 ETH\r\n\r\nPayment channels are tricky because the off-chain nature of them means that they we can't actually do a diff compared to the previous state channel update, so we can't say \"You are sending 0.001 ETH to jstoxrocky.eth\" because that requires knowing the previous state channel update.\r\n\r\nThis wouldn't depend on web3, so you would probably do something like `${amount / 10^18} ETH` instead of `web3.utils.fromWei(amount) ETH`.\r\n\r\nFocusing on the actual validation, after reading your comment I have realized that this thread actually has two different proposals.  Under one proposal, (1) the signer would ask the contract \"Is this a valid presentationHash?\" and under the other proposal (2) the signer would _include_ the presentationHash in the contract call as a final parameter (like in your example).\r\n\r\nIn (1), the signer _must_ have access to the blockchain.  This means offline MEW and hardware wallets can't utilize this system.  In (2), integration is much more complicated as it involves the contract having some magic parameter that a UI can't provide itself (it is always provided by the signer) yet is part of the contract definition.  While (2) is a more complete solution, I worry that without adding it to the protocol (as part of the signature validation system) it is going to be more headache than it is worth.\r\n\r\nIf someone wants to champion getting `presentationHash` added to Ethereum transactions I welcome that, but without I propose we move forward with the \"connected signers only supported\".\r\n\r\nSo, back to your example @jstoxrocky, if we assume we are going with (1) then the contract would look something like:\r\n```solidity\r\ncontract MyContract {\r\n    private mapping(bytes32 => bool) validDslHashes;\r\n    MyContract() {\r\n        bytes32 hash = keccak25(â€˜You are signing an IOU allowing ${0xENSADDRESS.resolve(recipient)} to withdraw ${amount / 10^18} ETH from the MyDapp state-channel.â€™);\r\n        validDslHashes[hash] = true;\r\n        // TODO: add other localizations of presentation hash\r\n    }\r\n    validateDslHash(bytes32 hash) returns (bool) {\r\n        return validDslHashes[hash];\r\n    }\r\n}\r\n```\r\n\r\nNote that the payment channel update that the signer signs would be a regular payment channel update, only including whatever is required for the payment channel, not anything about the presentation stuff (that ends at the signer).  So in your example, this would just include recipient and amount.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/371024303/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/371274847",
    "html_url": "https://github.com/ethereum/EIPs/issues/719#issuecomment-371274847",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/719",
    "id": 371274847,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM3MTI3NDg0Nw==",
    "user": {
      "login": "jstoxrocky",
      "id": 5459666,
      "node_id": "MDQ6VXNlcjU0NTk2NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5459666?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jstoxrocky",
      "html_url": "https://github.com/jstoxrocky",
      "followers_url": "https://api.github.com/users/jstoxrocky/followers",
      "following_url": "https://api.github.com/users/jstoxrocky/following{/other_user}",
      "gists_url": "https://api.github.com/users/jstoxrocky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jstoxrocky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jstoxrocky/subscriptions",
      "organizations_url": "https://api.github.com/users/jstoxrocky/orgs",
      "repos_url": "https://api.github.com/users/jstoxrocky/repos",
      "events_url": "https://api.github.com/users/jstoxrocky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jstoxrocky/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-03-07T20:32:34Z",
    "updated_at": "2018-03-07T20:33:06Z",
    "author_association": "CONTRIBUTOR",
    "body": "Thanks for that explanation @MicahZoltu  \r\n\r\nSo If I understand correctly, the dapp provides the DSL + parameters to sign. The signing UI plugs the parameters into the DSL and presents it to the user. If the user signs, the signing UI then checks the DSL against the DSL verification function in the contract. If that returns `true`, then it will send the transaction. Does this imply that contracts will need to implement a specific interface so that the signer knows where to look up and check the DSL hash? Also I'm a bit confused. Your example from Dec. 3rd contains this line: `require(acceptablePresentationHashes[presentationHash]);` making it seem like the presentationHash is validated when the transaction is sent. Not before.\r\n\r\nCould you elaborate:\r\n> If someone wants to champion getting presentationHash added to Ethereum transactions I welcome that, but without I propose we move forward with the \"connected signers only supported\".\r\nWould this be for the purpose of having access to something like:\r\n\r\n```\r\nfunction () {\r\n  require(validDslHashes[msg.presentationHash]);\r\n  ...\r\n}\r\n``` \r\n\r\nCan you elaborate on: \r\n\r\n> In (2), integration is much more complicated as it involves the contract having some magic parameter that a UI can't provide itself (it is always provided by the signer) yet is part of the contract definition. While (2) is a more complete solution, I worry that without adding it to the protocol (as part of the signature validation system) it is going to be more headache than it is worth.\r\n\r\nI think I'm confused. What is the magic parameter? In my head, my example was kind of just a reiteration of #712 but instead of having the signing UI present the raw data structure to the user, the formatted DSL is presented to the user instead - taking the place of the schema-hash when sent to the contract. \r\n\r\nIf I'm not mistaken, your example (maybe the EIP itself?) is about presenting something understandable to a user when they are signing an Ethereum transaction that interacts with a contract. What I think I am mostly concerned about is asking users to sign arbitrary data offchain in a comprehensible and safe way. Cases in which this signature is then sent to the contract later by a separate user. I like the DSL approach since it is human-readable to the user that signs, but it seems not to fit in with this EIP?\r\n\r\nWhat are your thoughts?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/371274847/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/371365372",
    "html_url": "https://github.com/ethereum/EIPs/issues/719#issuecomment-371365372",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/719",
    "id": 371365372,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM3MTM2NTM3Mg==",
    "user": {
      "login": "MicahZoltu",
      "id": 886059,
      "node_id": "MDQ6VXNlcjg4NjA1OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886059?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MicahZoltu",
      "html_url": "https://github.com/MicahZoltu",
      "followers_url": "https://api.github.com/users/MicahZoltu/followers",
      "following_url": "https://api.github.com/users/MicahZoltu/following{/other_user}",
      "gists_url": "https://api.github.com/users/MicahZoltu/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MicahZoltu/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MicahZoltu/subscriptions",
      "organizations_url": "https://api.github.com/users/MicahZoltu/orgs",
      "repos_url": "https://api.github.com/users/MicahZoltu/repos",
      "events_url": "https://api.github.com/users/MicahZoltu/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MicahZoltu/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-03-08T03:17:47Z",
    "updated_at": "2018-03-08T03:17:47Z",
    "author_association": "MEMBER",
    "body": "@jstoxrocky A slight correction to what you described.  The signer would check the `presentationHash` _before_ prompting the user to sign anything.  If it is OK then the signer will present it to the user for signing.  This way, the user can sign arbitrary off-chain data that is submitted to the chain sometime later via some other means.  Basically, the signer will not prompt you to ever sign anything where it can't verify the presentation hash.\r\n\r\nAs I mentioned in https://github.com/ethereum/EIPs/issues/719#issuecomment-371024303, there are currently two proposals kind of mixed in here.  One is to have `presentationHash` be part of Ethereum transactions.  This is a pretty big/major change to Ethereum, but would be great if someone wants to champion it as it would allow offline signers to utilize presentation hashes.  The following code is an example of how that would be used by a contract to validate the presentation hash:\r\n```\r\ncontract MyContract {\r\n    function myMethod() {\r\n        require(validDslHashes[msg.presentationHash]);\r\n        // todo the rest of myMethod business logic\r\n    }\r\n}\r\n```\r\n\r\nThe other is to just have the signer ask the contract if the presentation hash is valid before signing.  This _does_ require that contracts supporting presentation hashes implement some well known interface (which is why this needs to be an EIP so clients can standardize on the interface they look for).  However, it is much simpler than trying to do a protocol change like adding presentationHash to the transaction object.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/371365372/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/371651304",
    "html_url": "https://github.com/ethereum/EIPs/issues/719#issuecomment-371651304",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/719",
    "id": 371651304,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM3MTY1MTMwNA==",
    "user": {
      "login": "jstoxrocky",
      "id": 5459666,
      "node_id": "MDQ6VXNlcjU0NTk2NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5459666?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jstoxrocky",
      "html_url": "https://github.com/jstoxrocky",
      "followers_url": "https://api.github.com/users/jstoxrocky/followers",
      "following_url": "https://api.github.com/users/jstoxrocky/following{/other_user}",
      "gists_url": "https://api.github.com/users/jstoxrocky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jstoxrocky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jstoxrocky/subscriptions",
      "organizations_url": "https://api.github.com/users/jstoxrocky/orgs",
      "repos_url": "https://api.github.com/users/jstoxrocky/repos",
      "events_url": "https://api.github.com/users/jstoxrocky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jstoxrocky/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-03-08T22:46:31Z",
    "updated_at": "2018-03-08T22:49:16Z",
    "author_association": "CONTRIBUTOR",
    "body": "@MicahZoltu I like this idea a lot as it seems to kill several birds with one stone. I agree that having `presentationHash` as part of Ethereum transactions would be super useful. Seems like that might the real solution, if someone can get that into a scheduled protocol change. \r\n\r\nI know this is kind of a rehash of several older arguments in #712 but I am curious to hear your thoughts on the severity of this attack vector:\r\n\r\nSince validation of the presentation is performed by the signing UI and not by the contract itself when the transaction is sent, it seems like a malicious dapp could do something like this:\r\n\r\n1. A malicious dapp creates a benign presentation that validates against it's own contract.\r\n2. The malicious dapp sends the signing UI the presentation along with some arbitrary data to sign.\r\n3. The user agrees to sign the data since the presentation seems reasonable and it has been validated against the malicious dapps contract.\r\n4. The dapp receives this signature + data, but submits it to some other contract instead, extracting some value from the user or something.\r\n\r\nSeems like this could be solved by having the validation check for the presentation occur in the function being called (a dapp wishing to signal its trustworthiness would create a unique presentation for itself forcing all other malicious dapps to also show this presentation to users).\r\n\r\nJust curious as to how serious you think this is, is it scoped within this EIP, can this EIP solve it as is?\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/371651304/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/371720860",
    "html_url": "https://github.com/ethereum/EIPs/issues/719#issuecomment-371720860",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/719",
    "id": 371720860,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM3MTcyMDg2MA==",
    "user": {
      "login": "MicahZoltu",
      "id": 886059,
      "node_id": "MDQ6VXNlcjg4NjA1OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886059?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MicahZoltu",
      "html_url": "https://github.com/MicahZoltu",
      "followers_url": "https://api.github.com/users/MicahZoltu/followers",
      "following_url": "https://api.github.com/users/MicahZoltu/following{/other_user}",
      "gists_url": "https://api.github.com/users/MicahZoltu/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MicahZoltu/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MicahZoltu/subscriptions",
      "organizations_url": "https://api.github.com/users/MicahZoltu/orgs",
      "repos_url": "https://api.github.com/users/MicahZoltu/repos",
      "events_url": "https://api.github.com/users/MicahZoltu/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MicahZoltu/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-03-09T05:54:18Z",
    "updated_at": "2018-03-09T05:57:31Z",
    "author_association": "MEMBER",
    "body": "Contract authors will need to make sure the acceptable presentation strings include enough details such that the user can provide informed consent.  For on-chain transactions, like a token transfer, this is pretty easy to do and should come naturally.  For something like a state channel, you will want to make sure that the presentation string makes it clear to the user what exactly they are signing.  Contract authors should _assume_ that the presentation string is the _only_ information that the user has for deciding whether to sign or not and they should assume that prior to viewing the presentation string the user was duped or tricked in some way.\r\n\r\nA couple of examples:\r\nBad: `Transfer 5 tokens from 0xABCD to 0x1234`\r\nGood: `Transfer 5 ABC tokens from 0xABCD to 0x1234`\r\nBad: `Update state channel to 5 ABC tokens for 0xABCD and 3 ABC tokens for 0x1234`\r\nGood: `Update <product name> state channel to 5 ABC tokens for 0xABCD and 3 ABC tokens for 0x1234`",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/371720860/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/371908280",
    "html_url": "https://github.com/ethereum/EIPs/issues/719#issuecomment-371908280",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/719",
    "id": 371908280,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM3MTkwODI4MA==",
    "user": {
      "login": "jstoxrocky",
      "id": 5459666,
      "node_id": "MDQ6VXNlcjU0NTk2NjY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5459666?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jstoxrocky",
      "html_url": "https://github.com/jstoxrocky",
      "followers_url": "https://api.github.com/users/jstoxrocky/followers",
      "following_url": "https://api.github.com/users/jstoxrocky/following{/other_user}",
      "gists_url": "https://api.github.com/users/jstoxrocky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jstoxrocky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jstoxrocky/subscriptions",
      "organizations_url": "https://api.github.com/users/jstoxrocky/orgs",
      "repos_url": "https://api.github.com/users/jstoxrocky/repos",
      "events_url": "https://api.github.com/users/jstoxrocky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jstoxrocky/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-03-09T18:43:23Z",
    "updated_at": "2018-03-09T18:43:23Z",
    "author_association": "CONTRIBUTOR",
    "body": "@MicahZoltu Sorry if I sound like a broken record but I'm just trying to get a full grasp of your idea. Even in cases where the presentation is as explicit as possible, it seems like there is a chance of fraud unless part of the presentation data is verified within the contract.\r\n\r\nAssume Alice opens two separate payment channels with Bob. One settled in ETH and one settled in ABC tokens. Alice wants to update the ABC token state-channel but not the ETH state-channel. Alice is shown a presentation of the form `Update MyDappABCToken state channel to 5 ABC tokens for alice.eth and 3 ABC tokens for bob.eth`. The signing UI gives the OK that the DSL hash is fine and Alice signs and sends the signature to Bob. Alice has really only signed the following values: `senderAddress`, `newBalanceSender`, `recipientAddress`, `newBalanceRecipient` (maybe hashed and signed with a schema signature like #712). Bob could use this same signature in both payment channels.\r\n\r\nIs the solution to include some contextual strings like `MyDappABCToken` and/or `ABC` in the signature data?\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/371908280/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/372002554",
    "html_url": "https://github.com/ethereum/EIPs/issues/719#issuecomment-372002554",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/719",
    "id": 372002554,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM3MjAwMjU1NA==",
    "user": {
      "login": "MicahZoltu",
      "id": 886059,
      "node_id": "MDQ6VXNlcjg4NjA1OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886059?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MicahZoltu",
      "html_url": "https://github.com/MicahZoltu",
      "followers_url": "https://api.github.com/users/MicahZoltu/followers",
      "following_url": "https://api.github.com/users/MicahZoltu/following{/other_user}",
      "gists_url": "https://api.github.com/users/MicahZoltu/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MicahZoltu/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MicahZoltu/subscriptions",
      "organizations_url": "https://api.github.com/users/MicahZoltu/orgs",
      "repos_url": "https://api.github.com/users/MicahZoltu/repos",
      "events_url": "https://api.github.com/users/MicahZoltu/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MicahZoltu/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-03-10T04:46:59Z",
    "updated_at": "2018-03-10T04:46:59Z",
    "author_association": "MEMBER",
    "body": "@jstoxrocky I don't mind back and forth with you to help make things clear.  ðŸ˜„ If you prefer a faster round trip time, feel free to ping me in Gitter.\r\n\r\nThe problem you described is a problem with the state channel implementation, not with the presentation system.  Any state channel authored the way you described and susceptible to the attack you described is a _state channel with a critical security vulnerability_.  Such a state channel implementation should never make it into the wild and if it does it should be fixed immediately.\r\n\r\nThe presentation stuff is meant to solve a very specific problem, which is informed consent from users.  It is not intended to solve all possible malicious dapp attack vectors, which would include the one you have described.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/372002554/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
