{
  "url": "https://api.github.com/repos/ethereum/EIPs/issues/735",
  "repository_url": "https://api.github.com/repos/ethereum/EIPs",
  "labels_url": "https://api.github.com/repos/ethereum/EIPs/issues/735/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/EIPs/issues/735/comments",
  "events_url": "https://api.github.com/repos/ethereum/EIPs/issues/735/events",
  "html_url": "https://github.com/ethereum/EIPs/issues/735",
  "id": 263854330,
  "node_id": "MDU6SXNzdWUyNjM4NTQzMzA=",
  "number": 735,
  "title": "ERC: Claim Holder",
  "user": {
    "login": "frozeman",
    "id": 232662,
    "node_id": "MDQ6VXNlcjIzMjY2Mg==",
    "avatar_url": "https://avatars.githubusercontent.com/u/232662?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/frozeman",
    "html_url": "https://github.com/frozeman",
    "followers_url": "https://api.github.com/users/frozeman/followers",
    "following_url": "https://api.github.com/users/frozeman/following{/other_user}",
    "gists_url": "https://api.github.com/users/frozeman/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/frozeman/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/frozeman/subscriptions",
    "organizations_url": "https://api.github.com/users/frozeman/orgs",
    "repos_url": "https://api.github.com/users/frozeman/repos",
    "events_url": "https://api.github.com/users/frozeman/events{/privacy}",
    "received_events_url": "https://api.github.com/users/frozeman/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 2328627851,
      "node_id": "MDU6TGFiZWwyMzI4NjI3ODUx",
      "url": "https://api.github.com/repos/ethereum/EIPs/labels/stale",
      "name": "stale",
      "color": "000000",
      "default": false,
      "description": ""
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 81,
  "created_at": "2017-10-09T10:53:34Z",
  "updated_at": "2022-01-16T09:11:14Z",
  "closed_at": "2022-01-16T09:11:14Z",
  "author_association": "CONTRIBUTOR",
  "active_lock_reason": null,
  "body": "```\r\nEIP: 735\r\nTitle: Claim Holder\r\nAuthor: Fabian Vogelsteller (@frozeman)\r\nType: Standard\r\nCategory: ERC\r\nStatus: Discussion\r\nCreated: 2017-10-09\r\n```\r\n\r\n**NOTE: Due to the changes in [ERC725](https://github.com/ethereum/EIPs/issues/725), this spec is not fully compatible with the current ERC725v2. If you're interested in adopting this spec to work with 725v2, please comment below, or send a gist with changes.**\r\n\r\n# Abstract\r\n\r\nThe following describes standard functions for adding, removing and holding of claims.\r\nThese claims can attested from third parties (issuers) or self attested.\r\n\r\n\r\n# Motivation\r\n\r\nThis standardised claim holder interface will allow Dapps and smart contracts to check the claims about a claim holder. Trust is here transfered to the issuers of claims.\r\n\r\n\r\n# Definitions\r\n\r\n- `claim issuer`: is another smart contract or external account, which issues claims about this identity. The claim issuer can be an identity contract itself.\r\n- `claim`: A claim is an information an issuer has about the identity holder. This contains the following:\r\n    - `topic`: A `uint256` number which represents the topic of the claim. (e.g. 1 biometric, 2 residence  (ToBeDefined: number schemes, sub topics based on number ranges??))\r\n    - `scheme `: The scheme with which this claim SHOULD be verified or how it should be processed. Its a `uint256` for different schemes. E.g. could `3` mean contract verification, where the `data` will be call data, and the `issuer` a contract address to call (ToBeDefined). Those can also mean different key types e.g. 1 = ECDSA, 2 = RSA, etc. (ToBeDefined)\r\n    - `issuer`: The issuers identity contract address, or the address used to sign the above signature. If an identity contract, it should hold the key with which the above message was signed, if the key is not present anymore, the claim SHOULD be treated as invalid. The issuer can also be a contract address itself, at which the claim can be verified using the call `data`.\r\n    - `signature`: Signature which is the proof that the claim issuer issued a claim of `topic ` for this identity. it MUST be a signed message of the following structure: `keccak256(address identityHolder_address, uint256 _ topic, bytes data)` // or `keccak256(abi.encode(identityHolder_address, topic, data))` ?\r\n    - `data`: The hash of the claim data, sitting in another location, a bit-mask, call data, or actual data based on the claim scheme.\r\n    - `uri`: The location of the claim, this can be HTTP links, swarm hashes, IPFS hashes, and such.\r\n\r\n\r\n# Specification\r\n\r\n## Claim Holder\r\n\r\n#### claim structure\r\n\r\nThe claims issued to the identity. Returns the claim properties.\r\n\r\n``` js\r\nstruct Claim {\r\n    uint256 topic;\r\n    uint256 scheme;\r\n    address issuer; // msg.sender\r\n    bytes signature; // this.address + topic + data\r\n    bytes data;\r\n    string uri;\r\n}\r\n```\r\n\r\n#### getClaim\r\n\r\nReturns a claim by ID.\r\n\r\n```js\r\nfunction getClaim(bytes32 _claimId) constant returns(uint256 topic, uint256 scheme, address issuer, bytes signature, bytes data, string uri);\r\n```\r\n\r\n\r\n#### getClaimIdsByTopic\r\n\r\nReturns an array of claim IDs by topic.\r\n\r\n```js\r\nfunction getClaimIdsByTopic(uint256 _topic) constant returns(bytes32[] claimIds);\r\n```\r\n\r\n\r\n#### addClaim\r\n\r\nRequests the ADDITION or the CHANGE of a claim from an `issuer`. \r\nClaims can requested to be added by anybody, including the claim holder itself (self issued).\r\n\r\n`_signature` is a signed message of the following structure: `keccak256(address identityHolder_address, uint256 topic, bytes data)`.\r\n\r\nClaim IDs are generated using `keccak256(address issuer_address + uint256 topic)`.\r\n\r\nThis COULD implement an approval process for pending claims, or add them right away.\r\n\r\nPossible claim topics:\r\n\r\n- `1`: Biometric data\r\n- `2`: Permanent address\r\n\r\n(TODO: add more in the initial standard? `3`: Claim registry?)\r\n\r\n\r\n**Returns `claimRequestId`:** COULD be send to the `approve` function, to approve or reject this claim.\r\n\r\n**Triggers if the claim is new Event and approval process exists:** [ClaimRequested](#claimrequested)\r\n**Triggers if the claim is new Event and is added:** [ClaimAdded](#claimadded)\r\n**Triggers if the claim index existed Event:** [ClaimChanged](#claimchanged)\r\n\r\n``` js\r\nfunction addClaim(uint256 _topic, uint256 _scheme, address _issuer, bytes _signature, bytes _data, string _uri) returns (uint256 claimRequestId)\r\n```\r\n\r\n\r\n#### removeClaim\r\n\r\nRemoves a claim.\r\nCan only be removed by the claim issuer, or the claim holder itself.\r\n\r\nTriggers Event: [ClaimRemoved](#claimremoved)\r\n\r\n``` js\r\nfunction removeClaim(bytes32 _claimId) returns (bool success)\r\n```\r\n\r\n\r\n--------------------------------------------------------\r\n\r\n\r\n### Events\r\n\r\n\r\n#### ClaimRequested\r\n\r\nCOULD be triggered when `addClaim` was successfully called.\r\n\r\n``` js\r\nevent ClaimRequested(uint256 indexed claimRequestId, uint256 indexed topic, uint256 scheme, address indexed issuer, bytes signature, bytes data, string uri)\r\n```\r\n\r\n\r\n#### ClaimAdded\r\n\r\nMUST be triggered when a claim was successfully added.\r\n\r\n``` js\r\nevent ClaimAdded(bytes32 indexed claimId, uint256 indexed topic, uint256 scheme, address indexed issuer, bytes signature, bytes data, string uri))\r\n```\r\n\r\n\r\n#### ClaimRemoved\r\n\r\nMUST be triggered when `removeClaim` was successfully called.\r\n\r\n``` js\r\nevent ClaimRemoved(bytes32 indexed claimId, uint256 indexed topic, uint256 scheme, address indexed issuer, bytes signature, bytes data, string uri))\r\n```\r\n\r\n\r\n#### ClaimChanged\r\n\r\nMUST be triggered when `changeClaim` was successfully called.\r\n\r\n``` js\r\nevent ClaimChanged(bytes32 indexed claimId, uint256 indexed topic, uint256 scheme, address indexed issuer, bytes signature, bytes data, string uri)\r\n```\r\n\r\n\r\n## Solidity Interface\r\n```js\r\npragma solidity ^0.4.18;\r\n\r\ncontract ERC735 {\r\n\r\n    event ClaimRequested(uint256 indexed claimRequestId, uint256 indexed topic, uint256 scheme, address indexed issuer, bytes signature, bytes data, string uri);\r\n    event ClaimAdded(bytes32 indexed claimId, uint256 indexed topic, uint256 scheme, address indexed issuer, bytes signature, bytes data, string uri);\r\n    event ClaimRemoved(bytes32 indexed claimId, uint256 indexed topic, uint256 scheme, address indexed issuer, bytes signature, bytes data, string uri);\r\n    event ClaimChanged(bytes32 indexed claimId, uint256 indexed topic, uint256 scheme, address indexed issuer, bytes signature, bytes data, string uri);\r\n\r\n    struct Claim {\r\n        uint256 topic;\r\n        uint256 scheme;\r\n        address issuer; // msg.sender\r\n        bytes signature; // this.address + topic + data\r\n        bytes data;\r\n        string uri;\r\n    }\r\n\r\n    function getClaim(bytes32 _claimId) public constant returns(uint256 topic, uint256 scheme, address issuer, bytes signature, bytes data, string uri);\r\n    function getClaimIdsByTopic(uint256 _ topic) public constant returns(bytes32[] claimIds);\r\n    function addClaim(uint256 _topic, uint256 _scheme, address _issuer, bytes _signature, bytes _data, string _uri) public returns (uint256 claimRequestId);\r\n    changeClaim(bytes32 _claimId, uint256 _topic, uint256 _scheme, address _issuer, bytes _signature, bytes _data, string _uri) returns (bool success);\r\n    function removeClaim(bytes32 _claimId) public returns (bool success);\r\n}\r\n```\r\n## Constraints\r\n\r\n- A claim can only be one per topic per issuer.\r\n\r\n## Additional References\r\n\r\n- [Slides of the ERC Identity presentation](https://www.slideshare.net/FabianVogelsteller/erc-725-identity)\r\n- [W3C Verifiable Claims Use Cases](https://w3c.github.io/vc-use-cases/)\r\n- [Identity related reports](http://www.weboftrust.info/specs.html)\r\n- [Claim Holder Registry ERC780](https://github.com/ethereum/EIPs/issues/780)",
  "closed_by": {
    "login": "github-actions[bot]",
    "id": 41898282,
    "node_id": "MDM6Qm90NDE4OTgyODI=",
    "avatar_url": "https://avatars.githubusercontent.com/in/15368?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/github-actions%5Bbot%5D",
    "html_url": "https://github.com/apps/github-actions",
    "followers_url": "https://api.github.com/users/github-actions%5Bbot%5D/followers",
    "following_url": "https://api.github.com/users/github-actions%5Bbot%5D/following{/other_user}",
    "gists_url": "https://api.github.com/users/github-actions%5Bbot%5D/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/github-actions%5Bbot%5D/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/github-actions%5Bbot%5D/subscriptions",
    "organizations_url": "https://api.github.com/users/github-actions%5Bbot%5D/orgs",
    "repos_url": "https://api.github.com/users/github-actions%5Bbot%5D/repos",
    "events_url": "https://api.github.com/users/github-actions%5Bbot%5D/events{/privacy}",
    "received_events_url": "https://api.github.com/users/github-actions%5Bbot%5D/received_events",
    "type": "Bot",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/735/reactions",
    "total_count": 39,
    "+1": 26,
    "-1": 1,
    "laugh": 0,
    "hooray": 4,
    "confused": 4,
    "heart": 4,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/EIPs/issues/735/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/335127519",
    "html_url": "https://github.com/ethereum/EIPs/issues/735#issuecomment-335127519",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/735",
    "id": 335127519,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzNTEyNzUxOQ==",
    "user": {
      "login": "frozeman",
      "id": 232662,
      "node_id": "MDQ6VXNlcjIzMjY2Mg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/232662?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/frozeman",
      "html_url": "https://github.com/frozeman",
      "followers_url": "https://api.github.com/users/frozeman/followers",
      "following_url": "https://api.github.com/users/frozeman/following{/other_user}",
      "gists_url": "https://api.github.com/users/frozeman/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/frozeman/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/frozeman/subscriptions",
      "organizations_url": "https://api.github.com/users/frozeman/orgs",
      "repos_url": "https://api.github.com/users/frozeman/repos",
      "events_url": "https://api.github.com/users/frozeman/events{/privacy}",
      "received_events_url": "https://api.github.com/users/frozeman/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-09T11:10:11Z",
    "updated_at": "2017-10-09T11:10:11Z",
    "author_association": "CONTRIBUTOR",
    "body": "This is implemented by #725 ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/335127519/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/335127715",
    "html_url": "https://github.com/ethereum/EIPs/issues/735#issuecomment-335127715",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/735",
    "id": 335127715,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzNTEyNzcxNQ==",
    "user": {
      "login": "frozeman",
      "id": 232662,
      "node_id": "MDQ6VXNlcjIzMjY2Mg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/232662?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/frozeman",
      "html_url": "https://github.com/frozeman",
      "followers_url": "https://api.github.com/users/frozeman/followers",
      "following_url": "https://api.github.com/users/frozeman/following{/other_user}",
      "gists_url": "https://api.github.com/users/frozeman/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/frozeman/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/frozeman/subscriptions",
      "organizations_url": "https://api.github.com/users/frozeman/orgs",
      "repos_url": "https://api.github.com/users/frozeman/repos",
      "events_url": "https://api.github.com/users/frozeman/events{/privacy}",
      "received_events_url": "https://api.github.com/users/frozeman/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-09T11:11:09Z",
    "updated_at": "2017-10-09T11:12:19Z",
    "author_association": "CONTRIBUTOR",
    "body": "I added `uint256 signatureType`",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/335127715/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/335137432",
    "html_url": "https://github.com/ethereum/EIPs/issues/735#issuecomment-335137432",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/735",
    "id": 335137432,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzNTEzNzQzMg==",
    "user": {
      "login": "Arachnid",
      "id": 17865,
      "node_id": "MDQ6VXNlcjE3ODY1",
      "avatar_url": "https://avatars.githubusercontent.com/u/17865?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Arachnid",
      "html_url": "https://github.com/Arachnid",
      "followers_url": "https://api.github.com/users/Arachnid/followers",
      "following_url": "https://api.github.com/users/Arachnid/following{/other_user}",
      "gists_url": "https://api.github.com/users/Arachnid/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Arachnid/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Arachnid/subscriptions",
      "organizations_url": "https://api.github.com/users/Arachnid/orgs",
      "repos_url": "https://api.github.com/users/Arachnid/repos",
      "events_url": "https://api.github.com/users/Arachnid/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Arachnid/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-09T12:01:26Z",
    "updated_at": "2017-10-09T12:01:26Z",
    "author_association": "MEMBER",
    "body": "I'm still not sure why you're using signatures here, and thus restricting things to only externally owned accounts using ECDSA sigs. Wouldn't it be more general to rely on caller address?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/335137432/reactions",
      "total_count": 3,
      "+1": 3,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/335178878",
    "html_url": "https://github.com/ethereum/EIPs/issues/735#issuecomment-335178878",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/735",
    "id": 335178878,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzNTE3ODg3OA==",
    "user": {
      "login": "frozeman",
      "id": 232662,
      "node_id": "MDQ6VXNlcjIzMjY2Mg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/232662?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/frozeman",
      "html_url": "https://github.com/frozeman",
      "followers_url": "https://api.github.com/users/frozeman/followers",
      "following_url": "https://api.github.com/users/frozeman/following{/other_user}",
      "gists_url": "https://api.github.com/users/frozeman/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/frozeman/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/frozeman/subscriptions",
      "organizations_url": "https://api.github.com/users/frozeman/orgs",
      "repos_url": "https://api.github.com/users/frozeman/repos",
      "events_url": "https://api.github.com/users/frozeman/events{/privacy}",
      "received_events_url": "https://api.github.com/users/frozeman/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-09T14:41:08Z",
    "updated_at": "2017-10-09T14:45:45Z",
    "author_association": "CONTRIBUTOR",
    "body": "In order to auto-verify an claim - which could have been  added by anybody - each claim needs to contain a in smart contract verifiable signature from one key of an issuers identity. The signature must sign, claim type, claim holder address and claim reference hash.\r\n\r\nThis way any contract can auto-verify claims.\r\n\r\nThere is no way to enforce this standard, and if a supposed claim holder added a claim with `address issuer` somebody, but that somebody never made that claim, there is no way to proof that, except using signatures.\r\n\r\nI added the `uint256 signatureType` to also allow different signature in the future.\r\n\r\nAnd yes you need an external owned account, or key to sign, to allow fully on chain verification. Or do you have any other method in mind, how we could solve that problem?\r\n\r\nI will repost a pure on chain claim verification process:\r\n\r\n\r\n1. `getClaim` by index, which is the type for a trusted issuer. Index is generated: `(keccak256(address issuer_address + uint256 _claimType))`\r\n2. Ecrecover signature, retrieve address `k`\r\n3. Check if `k` is still a key hold by the claim issuers identity contract (issuer address)",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/335178878/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/335199354",
    "html_url": "https://github.com/ethereum/EIPs/issues/735#issuecomment-335199354",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/735",
    "id": 335199354,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzNTE5OTM1NA==",
    "user": {
      "login": "3esmit",
      "id": 224810,
      "node_id": "MDQ6VXNlcjIyNDgxMA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/224810?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/3esmit",
      "html_url": "https://github.com/3esmit",
      "followers_url": "https://api.github.com/users/3esmit/followers",
      "following_url": "https://api.github.com/users/3esmit/following{/other_user}",
      "gists_url": "https://api.github.com/users/3esmit/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/3esmit/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/3esmit/subscriptions",
      "organizations_url": "https://api.github.com/users/3esmit/orgs",
      "repos_url": "https://api.github.com/users/3esmit/repos",
      "events_url": "https://api.github.com/users/3esmit/events{/privacy}",
      "received_events_url": "https://api.github.com/users/3esmit/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-09T15:51:17Z",
    "updated_at": "2017-10-10T18:40:20Z",
    "author_association": "CONTRIBUTOR",
    "body": "@frozeman Would be something like this?\r\n``` js\r\npragma solidity ^0.4.15;\r\nimport \"https://gist.githubusercontent.com/AugustoL/9ddf7996e23a01c6599323761c0deeef/raw/17ae59c3dc2c82df791b2e48e5d05a5c012fec42/ECRecover.sol\"; //todo: change to repo\r\ncontract IdentityRegistry {\r\n    //(... other logic)\r\n    enum SignatureType {\r\n        DirectCall,\r\n        SignedMessage\r\n    }\r\n    function addClaim(uint256 _claimType, address issuer, uint256 signatureType, bytes _signature, bytes _claim, string _uri) returns (uint256 claimId){\r\n        \r\n        if (signatureType == SignatureType.DirectCall) {\r\n            require(issuer == msg.sender);\r\n        } else if (signatureType == SignatureType.SignedMessage) {\r\n            bytes32 signedMsg = keccak256(address(this), _claimType, _claim);\r\n            require(issuer == ECRecover.ecrecovery(_signature, signedMsg));\r\n        } else { revert(); }\r\n        //(... store claim and do stuff)\r\n    }\r\n    //(... more other logic)\r\n}\r\n```  \r\nWith this user could call directly without using signed message, and other account could register the user using the signed message? ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/335199354/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/335213216",
    "html_url": "https://github.com/ethereum/EIPs/issues/735#issuecomment-335213216",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/735",
    "id": 335213216,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzNTIxMzIxNg==",
    "user": {
      "login": "Arachnid",
      "id": 17865,
      "node_id": "MDQ6VXNlcjE3ODY1",
      "avatar_url": "https://avatars.githubusercontent.com/u/17865?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Arachnid",
      "html_url": "https://github.com/Arachnid",
      "followers_url": "https://api.github.com/users/Arachnid/followers",
      "following_url": "https://api.github.com/users/Arachnid/following{/other_user}",
      "gists_url": "https://api.github.com/users/Arachnid/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Arachnid/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Arachnid/subscriptions",
      "organizations_url": "https://api.github.com/users/Arachnid/orgs",
      "repos_url": "https://api.github.com/users/Arachnid/repos",
      "events_url": "https://api.github.com/users/Arachnid/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Arachnid/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-09T16:40:46Z",
    "updated_at": "2017-10-09T16:40:55Z",
    "author_association": "MEMBER",
    "body": "> In order to auto-verify an claim - which could have been added by anybody - each claim needs to contain a in smart contract verifiable signature from one key of an issuers identity. The signature must sign, claim type, claim holder address and claim reference hash.\r\n\r\nWhy not just have a registry of claims, whose smart contract code ensures that only valid claims can be stored there?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/335213216/reactions",
      "total_count": 6,
      "+1": 4,
      "-1": 0,
      "laugh": 0,
      "hooray": 1,
      "confused": 0,
      "heart": 1,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/335302438",
    "html_url": "https://github.com/ethereum/EIPs/issues/735#issuecomment-335302438",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/735",
    "id": 335302438,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzNTMwMjQzOA==",
    "user": {
      "login": "christianlundkvist",
      "id": 6892901,
      "node_id": "MDQ6VXNlcjY4OTI5MDE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6892901?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/christianlundkvist",
      "html_url": "https://github.com/christianlundkvist",
      "followers_url": "https://api.github.com/users/christianlundkvist/followers",
      "following_url": "https://api.github.com/users/christianlundkvist/following{/other_user}",
      "gists_url": "https://api.github.com/users/christianlundkvist/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/christianlundkvist/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/christianlundkvist/subscriptions",
      "organizations_url": "https://api.github.com/users/christianlundkvist/orgs",
      "repos_url": "https://api.github.com/users/christianlundkvist/repos",
      "events_url": "https://api.github.com/users/christianlundkvist/events{/privacy}",
      "received_events_url": "https://api.github.com/users/christianlundkvist/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-09T22:01:11Z",
    "updated_at": "2017-10-09T22:01:11Z",
    "author_association": "NONE",
    "body": "@frozeman - interesting stuff! On-chain attestations is an important use case and this is a good outline. I think the general idea of having claim types or categories are good, and the specifications you outlined are also useful. We’ve had some similar ideas in uPort although we have mainly focused on off-chain attestations.\r\n\r\nI tend to agree with @arachnid that the claim architecture would be more general if we were to allow any transaction to define a claim by using the `msg.sender` construct. Having a registry where claims are registered and where rules are enforced would allow any ethereum address to be the subject of a claim, and it would allow any smart contract capable of sending a transaction to issue a claim.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/335302438/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/335362855",
    "html_url": "https://github.com/ethereum/EIPs/issues/735#issuecomment-335362855",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/735",
    "id": 335362855,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzNTM2Mjg1NQ==",
    "user": {
      "login": "3esmit",
      "id": 224810,
      "node_id": "MDQ6VXNlcjIyNDgxMA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/224810?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/3esmit",
      "html_url": "https://github.com/3esmit",
      "followers_url": "https://api.github.com/users/3esmit/followers",
      "following_url": "https://api.github.com/users/3esmit/following{/other_user}",
      "gists_url": "https://api.github.com/users/3esmit/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/3esmit/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/3esmit/subscriptions",
      "organizations_url": "https://api.github.com/users/3esmit/orgs",
      "repos_url": "https://api.github.com/users/3esmit/repos",
      "events_url": "https://api.github.com/users/3esmit/events{/privacy}",
      "received_events_url": "https://api.github.com/users/3esmit/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-10T05:13:14Z",
    "updated_at": "2017-10-10T05:13:14Z",
    "author_association": "CONTRIBUTOR",
    "body": "I have a use case for this where a registry is using Oraclize, for example with [Oraclize+GitHubGists=user register](https://rinkeby.etherscan.io/address/0x74419ce7bb8d9a09faa5ce27930b4482dd59568b#code), and also there will be the organizations in that registry (also by oraclize), so oraclize would be the \"claimer\", and by default it's a direct message call (not sure if is possible other way). Also they provide a 'bytes proof', which should be stored together with claim? Or this case might be out of ERC735 scope? ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/335362855/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/335590588",
    "html_url": "https://github.com/ethereum/EIPs/issues/735#issuecomment-335590588",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/735",
    "id": 335590588,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzNTU5MDU4OA==",
    "user": {
      "login": "frozeman",
      "id": 232662,
      "node_id": "MDQ6VXNlcjIzMjY2Mg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/232662?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/frozeman",
      "html_url": "https://github.com/frozeman",
      "followers_url": "https://api.github.com/users/frozeman/followers",
      "following_url": "https://api.github.com/users/frozeman/following{/other_user}",
      "gists_url": "https://api.github.com/users/frozeman/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/frozeman/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/frozeman/subscriptions",
      "organizations_url": "https://api.github.com/users/frozeman/orgs",
      "repos_url": "https://api.github.com/users/frozeman/repos",
      "events_url": "https://api.github.com/users/frozeman/events{/privacy}",
      "received_events_url": "https://api.github.com/users/frozeman/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-10T20:01:47Z",
    "updated_at": "2017-10-10T20:04:17Z",
    "author_association": "CONTRIBUTOR",
    "body": "@3esmit the check shouldn’t be at the addClaim happen, but rather when the claim is verified by third party. There the signature of the claim needs to be checked. The signature type  went to support different signatures in the future, e.g. it could hold non ecdsa siagntures as well.\r\n\r\n@christianlundkvist good that your are here ;)\r\nYes sure a registry would allow for “adding” rules and this could be a useful addition, but it could get complicated when we introduce sharding , as all of those calls between the shards need then to go through an async transaction then. Though there could certainly additional registries for claims, but I think the in-contract claims are important for other off chain use cases.\r\n\r\nClaims are not only meant to be only from other smart contracts (but they can come from any), but any off chain entity, as long as they attach a valid signature they could even go through a proxy to add claims to contracts.\r\n\r\nConcerning adding claims for external accounts, yes that not possible. But I think it’s not really wanted either, your identity should have more than just a public key, which can be lost or stolen.\r\n\r\nThe reason why I kept the claim so flexible (e.g. sigtype, bytes for claim etc) is to allow all kind of claim type and verification to be added in the future. Only on chain verifications need the signature check. But claims can slow be checked off chain. Issuers could even attest claims about external accounts, but those doesn’t need to be stored in the Blockchain, this can be a transfer of those claims between two parties only. E.g. if I want to have a claim about me form an issuer, but I don’t want that the person which will verify the claim later can connect it to my on chain identity. In this case only the claim issuer need to be able to make that connection.\r\n\r\nI will present tomorrow this ERC at the London ethereum Meetup, and there will be a video of that later on attached to this ERC. \r\n\r\nI am also available for a call to discuss the details of how I think this works in a skype call. @christianlundkvist and @Arachnid you should have my skype already.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/335590588/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/335892768",
    "html_url": "https://github.com/ethereum/EIPs/issues/735#issuecomment-335892768",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/735",
    "id": 335892768,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzNTg5Mjc2OA==",
    "user": {
      "login": "3esmit",
      "id": 224810,
      "node_id": "MDQ6VXNlcjIyNDgxMA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/224810?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/3esmit",
      "html_url": "https://github.com/3esmit",
      "followers_url": "https://api.github.com/users/3esmit/followers",
      "following_url": "https://api.github.com/users/3esmit/following{/other_user}",
      "gists_url": "https://api.github.com/users/3esmit/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/3esmit/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/3esmit/subscriptions",
      "organizations_url": "https://api.github.com/users/3esmit/orgs",
      "repos_url": "https://api.github.com/users/3esmit/repos",
      "events_url": "https://api.github.com/users/3esmit/events{/privacy}",
      "received_events_url": "https://api.github.com/users/3esmit/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-11T17:48:21Z",
    "updated_at": "2017-10-11T18:01:46Z",
    "author_association": "CONTRIBUTOR",
    "body": "Wouldn't be equivalent, or more flexible to have `function getClaimIdsByType(uint256 _claimType) constant returns(bytes32[])` over `function getClaimsByType(uint256 _claimType) constant returns(Claim[]);`?\r\n\r\nAlso, \r\n`function addClaim(uint256 _claimType, address issuer, uint256 signatureType, bytes _signature, bytes _claim, string _uri) returns (uint256 claimId)`  to `returns (bytes32 claimId)`?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/335892768/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/336102670",
    "html_url": "https://github.com/ethereum/EIPs/issues/735#issuecomment-336102670",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/735",
    "id": 336102670,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzNjEwMjY3MA==",
    "user": {
      "login": "m-schmoock",
      "id": 4090425,
      "node_id": "MDQ6VXNlcjQwOTA0MjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4090425?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/m-schmoock",
      "html_url": "https://github.com/m-schmoock",
      "followers_url": "https://api.github.com/users/m-schmoock/followers",
      "following_url": "https://api.github.com/users/m-schmoock/following{/other_user}",
      "gists_url": "https://api.github.com/users/m-schmoock/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/m-schmoock/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/m-schmoock/subscriptions",
      "organizations_url": "https://api.github.com/users/m-schmoock/orgs",
      "repos_url": "https://api.github.com/users/m-schmoock/repos",
      "events_url": "https://api.github.com/users/m-schmoock/events{/privacy}",
      "received_events_url": "https://api.github.com/users/m-schmoock/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-12T11:42:44Z",
    "updated_at": "2017-10-12T11:42:44Z",
    "author_association": "NONE",
    "body": "@frozeman \r\nImagine a claim was self-claimed ('self-signed'), i.e. because a users sets up his identity and claims initial data (like real name and such):\r\n\r\n 1. The approval process for this would not be required, correct?\r\n 2. How would a second party 'sign' a self-claim, meaning claiming that the self-claimed data is correct?\r\n 3. How would a third party iterate through the chain of claims?\r\n\r\nMaybe you can provide some pseudo code of how this would look like..",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/336102670/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/336428333",
    "html_url": "https://github.com/ethereum/EIPs/issues/735#issuecomment-336428333",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/735",
    "id": 336428333,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzNjQyODMzMw==",
    "user": {
      "login": "frozeman",
      "id": 232662,
      "node_id": "MDQ6VXNlcjIzMjY2Mg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/232662?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/frozeman",
      "html_url": "https://github.com/frozeman",
      "followers_url": "https://api.github.com/users/frozeman/followers",
      "following_url": "https://api.github.com/users/frozeman/following{/other_user}",
      "gists_url": "https://api.github.com/users/frozeman/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/frozeman/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/frozeman/subscriptions",
      "organizations_url": "https://api.github.com/users/frozeman/orgs",
      "repos_url": "https://api.github.com/users/frozeman/repos",
      "events_url": "https://api.github.com/users/frozeman/events{/privacy}",
      "received_events_url": "https://api.github.com/users/frozeman/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-13T11:41:29Z",
    "updated_at": "2017-10-13T11:41:29Z",
    "author_association": "CONTRIBUTOR",
    "body": "@3esmit Thanks for the catches, i fixed it and change the function to `getClaimIdsByType`, which is something we can certainly make work in todays ABI.\r\n\r\nI changed the `bytes claim` to `bytes data` in the claim, to adhere to @holiman critic of claim being used twice in different contexts.\r\n\r\n@m-schmoock for self assigned claims one wouldn't need the approval process and not even a signature, if the `address issuer` address is the same as the contract itself, there is no verification necessary, as the contract itself holds and returns the claim.\r\n\r\nfor 3. you could get claims but type using `getClaimIdsByType` or your know which claim issuer your trust and which claim type you want, then you can recalculate the index using `keccak256(address issuer_address + uint256 _claimType)` and retrieve the claim directly using `getClaim`",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/336428333/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/336435235",
    "html_url": "https://github.com/ethereum/EIPs/issues/735#issuecomment-336435235",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/735",
    "id": 336435235,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzNjQzNTIzNQ==",
    "user": {
      "login": "frozeman",
      "id": 232662,
      "node_id": "MDQ6VXNlcjIzMjY2Mg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/232662?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/frozeman",
      "html_url": "https://github.com/frozeman",
      "followers_url": "https://api.github.com/users/frozeman/followers",
      "following_url": "https://api.github.com/users/frozeman/following{/other_user}",
      "gists_url": "https://api.github.com/users/frozeman/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/frozeman/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/frozeman/subscriptions",
      "organizations_url": "https://api.github.com/users/frozeman/orgs",
      "repos_url": "https://api.github.com/users/frozeman/repos",
      "events_url": "https://api.github.com/users/frozeman/events{/privacy}",
      "received_events_url": "https://api.github.com/users/frozeman/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-13T12:11:04Z",
    "updated_at": "2017-10-13T12:11:04Z",
    "author_association": "CONTRIBUTOR",
    "body": "I added a `Additional References` section.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/336435235/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/336589877",
    "html_url": "https://github.com/ethereum/EIPs/issues/735#issuecomment-336589877",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/735",
    "id": 336589877,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzNjU4OTg3Nw==",
    "user": {
      "login": "realcodywburns",
      "id": 13103499,
      "node_id": "MDQ6VXNlcjEzMTAzNDk5",
      "avatar_url": "https://avatars.githubusercontent.com/u/13103499?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/realcodywburns",
      "html_url": "https://github.com/realcodywburns",
      "followers_url": "https://api.github.com/users/realcodywburns/followers",
      "following_url": "https://api.github.com/users/realcodywburns/following{/other_user}",
      "gists_url": "https://api.github.com/users/realcodywburns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/realcodywburns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/realcodywburns/subscriptions",
      "organizations_url": "https://api.github.com/users/realcodywburns/orgs",
      "repos_url": "https://api.github.com/users/realcodywburns/repos",
      "events_url": "https://api.github.com/users/realcodywburns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/realcodywburns/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-13T23:28:01Z",
    "updated_at": "2017-10-13T23:28:01Z",
    "author_association": "CONTRIBUTOR",
    "body": "A `disputeClaim` function would be a nice feature. This would allow for an issuer to assert a `claimType n` that is negative in nature (late payments, poor conduct) that could be pertinent to both claiming identity and character, however, is inaccurate. While in dispute, the claim would be unavailable to `getClaim` and possibly third party arbitration assigned or timeout to remove the lock. ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/336589877/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/336626887",
    "html_url": "https://github.com/ethereum/EIPs/issues/735#issuecomment-336626887",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/735",
    "id": 336626887,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzNjYyNjg4Nw==",
    "user": {
      "login": "frozeman",
      "id": 232662,
      "node_id": "MDQ6VXNlcjIzMjY2Mg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/232662?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/frozeman",
      "html_url": "https://github.com/frozeman",
      "followers_url": "https://api.github.com/users/frozeman/followers",
      "following_url": "https://api.github.com/users/frozeman/following{/other_user}",
      "gists_url": "https://api.github.com/users/frozeman/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/frozeman/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/frozeman/subscriptions",
      "organizations_url": "https://api.github.com/users/frozeman/orgs",
      "repos_url": "https://api.github.com/users/frozeman/repos",
      "events_url": "https://api.github.com/users/frozeman/events{/privacy}",
      "received_events_url": "https://api.github.com/users/frozeman/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-14T10:47:36Z",
    "updated_at": "2017-10-14T10:47:36Z",
    "author_association": "CONTRIBUTOR",
    "body": "@realcodywburns according to this standard you approve any claim addition, and you can remove claims at any point. So there is no dispute necessary.\r\nBut you sure can’t do anything claiming something about you in other places. Like in social media today.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/336626887/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/336631439",
    "html_url": "https://github.com/ethereum/EIPs/issues/735#issuecomment-336631439",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/735",
    "id": 336631439,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzNjYzMTQzOQ==",
    "user": {
      "login": "andrewrd",
      "id": 11558472,
      "node_id": "MDQ6VXNlcjExNTU4NDcy",
      "avatar_url": "https://avatars.githubusercontent.com/u/11558472?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/andrewrd",
      "html_url": "https://github.com/andrewrd",
      "followers_url": "https://api.github.com/users/andrewrd/followers",
      "following_url": "https://api.github.com/users/andrewrd/following{/other_user}",
      "gists_url": "https://api.github.com/users/andrewrd/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/andrewrd/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/andrewrd/subscriptions",
      "organizations_url": "https://api.github.com/users/andrewrd/orgs",
      "repos_url": "https://api.github.com/users/andrewrd/repos",
      "events_url": "https://api.github.com/users/andrewrd/events{/privacy}",
      "received_events_url": "https://api.github.com/users/andrewrd/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-14T12:20:12Z",
    "updated_at": "2017-10-14T14:41:49Z",
    "author_association": "NONE",
    "body": "@frozeman @realcodywburns Another use case for a ```disputeClaim``` would be to flag identities which have been compromised. ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/336631439/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/336674803",
    "html_url": "https://github.com/ethereum/EIPs/issues/735#issuecomment-336674803",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/735",
    "id": 336674803,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzNjY3NDgwMw==",
    "user": {
      "login": "realcodywburns",
      "id": 13103499,
      "node_id": "MDQ6VXNlcjEzMTAzNDk5",
      "avatar_url": "https://avatars.githubusercontent.com/u/13103499?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/realcodywburns",
      "html_url": "https://github.com/realcodywburns",
      "followers_url": "https://api.github.com/users/realcodywburns/followers",
      "following_url": "https://api.github.com/users/realcodywburns/following{/other_user}",
      "gists_url": "https://api.github.com/users/realcodywburns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/realcodywburns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/realcodywburns/subscriptions",
      "organizations_url": "https://api.github.com/users/realcodywburns/orgs",
      "repos_url": "https://api.github.com/users/realcodywburns/repos",
      "events_url": "https://api.github.com/users/realcodywburns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/realcodywburns/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-14T23:32:21Z",
    "updated_at": "2017-10-14T23:32:21Z",
    "author_association": "CONTRIBUTOR",
    "body": "Yes, the inability to remove some claims would be the goal. For example: an issuer assets a claim that identity `0xdeadbeaf` has participated in their auction contract and is known to the community. As time passes , addational claims are asserted that timely payments have been received as per terms of the contract; these claims would further add credibility to both the character and validity of the identity. In the event that a shipment comes missing, the issuer then adds a claim to this effect. As the history exists, the issuer has attested that `0xdeadbeaf` is trustworthy and can remove any derogatory claims with impunity. Anyone interacting with `0xdeadbeef` would not know of her more recent bad actions. \r\n\r\nIf the situation arises by mistake, `0xdeadbeaf` could `disputeClaim`, resolve the situation, and retain the longstanding credible claim. If `0xdeadbeef` has actually done wrong, the claim both establishes identity and character and should be kept as record for sometime. \r\n\r\nAllowing only positive assertions my establish identity but may not capture the full picture of an individual. At the same time, one should have the right to self defense\r\n ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/336674803/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/336688036",
    "html_url": "https://github.com/ethereum/EIPs/issues/735#issuecomment-336688036",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/735",
    "id": 336688036,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzNjY4ODAzNg==",
    "user": {
      "login": "MikeD123",
      "id": 5343176,
      "node_id": "MDQ6VXNlcjUzNDMxNzY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5343176?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MikeD123",
      "html_url": "https://github.com/MikeD123",
      "followers_url": "https://api.github.com/users/MikeD123/followers",
      "following_url": "https://api.github.com/users/MikeD123/following{/other_user}",
      "gists_url": "https://api.github.com/users/MikeD123/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MikeD123/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MikeD123/subscriptions",
      "organizations_url": "https://api.github.com/users/MikeD123/orgs",
      "repos_url": "https://api.github.com/users/MikeD123/repos",
      "events_url": "https://api.github.com/users/MikeD123/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MikeD123/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-15T05:39:41Z",
    "updated_at": "2018-07-27T12:54:56Z",
    "author_association": "NONE",
    "body": "I'm not sure if I've misunderstood it here @frozeman  but I think a common structure for claimType like this would be awesome (if I'm understanding correctly on first glance). I get that this may be out of scope for this EIP in particular, and the list will always grow over time, but something that outlines things like this?\r\n \r\n* `01` - Individual\r\n* `02` - Business\r\n\r\nThen specifying the following:\r\n\r\n* `01` - Social\r\n  * `01` - video\r\n  * `02` - photo\r\n  * `03` - phone\r\n  * `04` - video\r\n  * `05` - platform (e.g. platformURL\r\n\r\n//\r\n* `02` - Sovereign \r\n  * `isoNumericM49` // country specification\r\n    * `01` - passport\r\n    * `02` - nationalIdNumber\r\n    * `03` - governmentId\r\n    * `04` - proofOfAddress\r\n    * `05` - bankStatement\r\n\r\n//\r\n* `03` - Device/Machine\r\n  * `01` - ip\r\n  * `02` - os\r\n  * `03` - browser\r\n  * `04` - etc.. \r\n\r\n\r\nLooking up an individual for their sovereign doc, in USA, that is a passport.\r\n`function getClaimIdsByType(uint256 010284001) constant returns(bytes32[] claimIds);`\r\n\r\nFeel like I may have misunderstood something, or this is a bit outside of scope, but either way, really excited for this, and thanks for doing it!\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/336688036/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/336738166",
    "html_url": "https://github.com/ethereum/EIPs/issues/735#issuecomment-336738166",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/735",
    "id": 336738166,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzNjczODE2Ng==",
    "user": {
      "login": "buendiadas",
      "id": 6004324,
      "node_id": "MDQ6VXNlcjYwMDQzMjQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6004324?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/buendiadas",
      "html_url": "https://github.com/buendiadas",
      "followers_url": "https://api.github.com/users/buendiadas/followers",
      "following_url": "https://api.github.com/users/buendiadas/following{/other_user}",
      "gists_url": "https://api.github.com/users/buendiadas/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/buendiadas/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/buendiadas/subscriptions",
      "organizations_url": "https://api.github.com/users/buendiadas/orgs",
      "repos_url": "https://api.github.com/users/buendiadas/repos",
      "events_url": "https://api.github.com/users/buendiadas/events{/privacy}",
      "received_events_url": "https://api.github.com/users/buendiadas/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-15T20:14:00Z",
    "updated_at": "2017-10-15T20:14:00Z",
    "author_association": "NONE",
    "body": "Great initiative @frozeman, I think using a unique URI field can lead to mistake when different Unique Resource Ids from different protocols are uploaded. Additionally to the collusion risk, as we are aggregating many different protocols, a resolver would not be able to know where to take the resource (should I request from IPFS?).  \r\n\r\nA solution could be an additional generic`bytes32` protocol identifier inside the claim or a real URI creation outside the contract including the protocol distinction.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/336738166/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/337245800",
    "html_url": "https://github.com/ethereum/EIPs/issues/735#issuecomment-337245800",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/735",
    "id": 337245800,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzNzI0NTgwMA==",
    "user": {
      "login": "frozeman",
      "id": 232662,
      "node_id": "MDQ6VXNlcjIzMjY2Mg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/232662?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/frozeman",
      "html_url": "https://github.com/frozeman",
      "followers_url": "https://api.github.com/users/frozeman/followers",
      "following_url": "https://api.github.com/users/frozeman/following{/other_user}",
      "gists_url": "https://api.github.com/users/frozeman/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/frozeman/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/frozeman/subscriptions",
      "organizations_url": "https://api.github.com/users/frozeman/orgs",
      "repos_url": "https://api.github.com/users/frozeman/repos",
      "events_url": "https://api.github.com/users/frozeman/events{/privacy}",
      "received_events_url": "https://api.github.com/users/frozeman/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-17T14:15:46Z",
    "updated_at": "2017-10-17T14:15:46Z",
    "author_association": "CONTRIBUTOR",
    "body": "@realcodywburns @andrewrd the dispute claim is IMO not necessary. This standard is a shell for your own identity. First of you don't want to have every buy transaction references with your real world identity INSIDE you identity smart contract, that would be a huge privacy issue. And second there can be many reputation systems referencing this identity, this doesn't mean, every step needs to be a claim added to your identity. \r\n\r\nTechnically everybody can issuer a claim and post it anywhere (e.g. a reputation system, or facebook, twitter, etc) You can't defend yourself from that anyway (and shouldn't, as it might be legit). Allowing a claim on YOUR identity means, YOU approve it. Again don't get me wrong, reputation systems should exists, which allow sellers to verify the credibility of a buyer, but this is outside of this standard, and might just happen in a peer2peer way by sending over reputation claims you collected over time, or referencing your identity AND a reputation system you are using (These two don't have to be publicly connected, as long as you can proof owner ship of both)\r\n\r\n@MikeD123 I think you get it a bit wrong. The idea of claimTypes is more of the nature of properties of you, e.g. `1: biometric data` will obviously means your a person and not a business. `2. address` will show that you are based somewhere, means you have a physical address or reference point. We could add claim types for certain social media, but thats up to discussion.\r\n\r\nIf you want to verify a claim, you most likely will not look for the type, but for a specific issuer you trust, so you can generate the ID of the claim in advance e.g.:\r\n\r\n`keccak256(address issuer_address + uint256 _claimType) -> keccak256('0x123456789...' + 1)`\r\n\r\nwill generate you the hash of the claim you can get using `getClaim(bytes32 _Id)`. If the claim doesn't exist, you either look for another, or you have to manually verify that person, or not at all. If the claim exists, you verify the signature inside the claim, and see if that recovered key is still hold by the claim issuer.\r\n\r\nAs over time, there will be trusted claim issuer, like the US gov, or some decentralised service, people can always know the index of the claims they want to retrieve and even hardcode that in their smart contracts.\r\n\r\nOn the end in most cases we don't care about the data itself, but that somebody verified it.\r\n\r\nConcerning the subTypes. I wouldn't go so detailed, as then people can know why sub type of claim was changed when, which could be a privacy leak. For some data it might make sense to give them a separate type, but for example for biometric data, just that might be enough.\r\n\r\nTo auto verify a person in front of you, the claim issuer for biometric data needs to have some bio matching services, or zero knowledge proof smart contracts, which can take some takes biometric data, and match it against their data set, and return `true` or `false`, should the data match the person claim `data` reference you gave them.\r\n\r\n@buendiadas concerning the URI, it should contain the protocol like `ipfs://...`, or `bzz://` or `https://`\r\n\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/337245800/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/337284218",
    "html_url": "https://github.com/ethereum/EIPs/issues/735#issuecomment-337284218",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/735",
    "id": 337284218,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzNzI4NDIxOA==",
    "user": {
      "login": "frozeman",
      "id": 232662,
      "node_id": "MDQ6VXNlcjIzMjY2Mg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/232662?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/frozeman",
      "html_url": "https://github.com/frozeman",
      "followers_url": "https://api.github.com/users/frozeman/followers",
      "following_url": "https://api.github.com/users/frozeman/following{/other_user}",
      "gists_url": "https://api.github.com/users/frozeman/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/frozeman/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/frozeman/subscriptions",
      "organizations_url": "https://api.github.com/users/frozeman/orgs",
      "repos_url": "https://api.github.com/users/frozeman/repos",
      "events_url": "https://api.github.com/users/frozeman/events{/privacy}",
      "received_events_url": "https://api.github.com/users/frozeman/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-17T16:15:08Z",
    "updated_at": "2017-10-17T16:15:08Z",
    "author_association": "CONTRIBUTOR",
    "body": "As next steps, it would be good to create a collection of PROs and CONs for having claim issues in a registry vs. having them on your identity contract directly.\r\n\r\nSome short ideas i gathered when talking to @Arachnid, I put into this wiki page, which everybody can extend and add to it, so we don't have to do this over a series of issues:  https://github.com/ethereum/wiki/wiki/ERC-735:-Claim-Holder-Registry-vs.-in-contract\r\n\r\nThis will allow us gather a good overview over both sides.\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/337284218/reactions",
      "total_count": 5,
      "+1": 4,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 1,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/337926772",
    "html_url": "https://github.com/ethereum/EIPs/issues/735#issuecomment-337926772",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/735",
    "id": 337926772,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzNzkyNjc3Mg==",
    "user": {
      "login": "bneiluj",
      "id": 3680497,
      "node_id": "MDQ6VXNlcjM2ODA0OTc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3680497?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bneiluj",
      "html_url": "https://github.com/bneiluj",
      "followers_url": "https://api.github.com/users/bneiluj/followers",
      "following_url": "https://api.github.com/users/bneiluj/following{/other_user}",
      "gists_url": "https://api.github.com/users/bneiluj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bneiluj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bneiluj/subscriptions",
      "organizations_url": "https://api.github.com/users/bneiluj/orgs",
      "repos_url": "https://api.github.com/users/bneiluj/repos",
      "events_url": "https://api.github.com/users/bneiluj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bneiluj/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-19T14:32:00Z",
    "updated_at": "2017-10-19T14:32:00Z",
    "author_association": "NONE",
    "body": "@frozeman Great idea the wiki page ! https://github.com/ethereum/wiki/wiki/ERC-735:-Claim-Holder-Registry-vs.-in-contract. Let's create a vote counting with some eth ! 😅",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/337926772/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/338159568",
    "html_url": "https://github.com/ethereum/EIPs/issues/735#issuecomment-338159568",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/735",
    "id": 338159568,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzODE1OTU2OA==",
    "user": {
      "login": "frozeman",
      "id": 232662,
      "node_id": "MDQ6VXNlcjIzMjY2Mg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/232662?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/frozeman",
      "html_url": "https://github.com/frozeman",
      "followers_url": "https://api.github.com/users/frozeman/followers",
      "following_url": "https://api.github.com/users/frozeman/following{/other_user}",
      "gists_url": "https://api.github.com/users/frozeman/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/frozeman/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/frozeman/subscriptions",
      "organizations_url": "https://api.github.com/users/frozeman/orgs",
      "repos_url": "https://api.github.com/users/frozeman/repos",
      "events_url": "https://api.github.com/users/frozeman/events{/privacy}",
      "received_events_url": "https://api.github.com/users/frozeman/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-20T09:45:50Z",
    "updated_at": "2017-10-20T09:45:50Z",
    "author_association": "CONTRIBUTOR",
    "body": "Keep in mind both can work hand in hand, so a claim registry could be useful for some cases, and for others the attached claims in the contract itself are more useful. So can one claim referencing the claim registry, maybe with `claimType` `5` :)",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/338159568/reactions",
      "total_count": 3,
      "+1": 3,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/338163696",
    "html_url": "https://github.com/ethereum/EIPs/issues/735#issuecomment-338163696",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/735",
    "id": 338163696,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzODE2MzY5Ng==",
    "user": {
      "login": "jacqueswww",
      "id": 6917456,
      "node_id": "MDQ6VXNlcjY5MTc0NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6917456?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jacqueswww",
      "html_url": "https://github.com/jacqueswww",
      "followers_url": "https://api.github.com/users/jacqueswww/followers",
      "following_url": "https://api.github.com/users/jacqueswww/following{/other_user}",
      "gists_url": "https://api.github.com/users/jacqueswww/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jacqueswww/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jacqueswww/subscriptions",
      "organizations_url": "https://api.github.com/users/jacqueswww/orgs",
      "repos_url": "https://api.github.com/users/jacqueswww/repos",
      "events_url": "https://api.github.com/users/jacqueswww/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jacqueswww/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-20T10:02:58Z",
    "updated_at": "2017-10-20T10:04:51Z",
    "author_association": "MEMBER",
    "body": "@frozeman - so one question I had is about the possibility of expiring claims. I can imagine something like a physical address being semi-permanent, and needing re-verification every couple of years. As far as I understand it - with current layout of a Claim one would use the data field in the struct to store a value in the future? OR one would have to look up the date of ClaimAdded in the event log - which we can't do from within another contract right ;)\r\nSimpler option is just returning a date created timestamp as part of the getClaim/claim struct, then a contract/service can decide the the delta from the getClaim call if they are willing to accept the claims' date.\r\nLet me know what you think :smile_cat:  (I know it could possibly be scope creep over the standard, however one could argue that timestamping is something that almost anyone would be interested in)\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/338163696/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/338463378",
    "html_url": "https://github.com/ethereum/EIPs/issues/735#issuecomment-338463378",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/735",
    "id": 338463378,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzODQ2MzM3OA==",
    "user": {
      "login": "frozeman",
      "id": 232662,
      "node_id": "MDQ6VXNlcjIzMjY2Mg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/232662?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/frozeman",
      "html_url": "https://github.com/frozeman",
      "followers_url": "https://api.github.com/users/frozeman/followers",
      "following_url": "https://api.github.com/users/frozeman/following{/other_user}",
      "gists_url": "https://api.github.com/users/frozeman/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/frozeman/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/frozeman/subscriptions",
      "organizations_url": "https://api.github.com/users/frozeman/orgs",
      "repos_url": "https://api.github.com/users/frozeman/repos",
      "events_url": "https://api.github.com/users/frozeman/events{/privacy}",
      "received_events_url": "https://api.github.com/users/frozeman/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-22T09:21:13Z",
    "updated_at": "2017-10-22T09:21:13Z",
    "author_association": "CONTRIBUTOR",
    "body": "@jacqueswww Currently there would be two ways to handle that situation:\r\n\r\n1. One way it would be that you make the date part of the data field, as you described.\r\n\r\n2. Or the claim holder signs specific claims with keys he will expire on his identity himself. As everybody who will verify a claim should definitely check that the claim signing key is still valid, any claim issuer could remove that claim key based on a time frame.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/338463378/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/338782419",
    "html_url": "https://github.com/ethereum/EIPs/issues/735#issuecomment-338782419",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/735",
    "id": 338782419,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzODc4MjQxOQ==",
    "user": {
      "login": "0xc1c4da",
      "id": 2714786,
      "node_id": "MDQ6VXNlcjI3MTQ3ODY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2714786?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/0xc1c4da",
      "html_url": "https://github.com/0xc1c4da",
      "followers_url": "https://api.github.com/users/0xc1c4da/followers",
      "following_url": "https://api.github.com/users/0xc1c4da/following{/other_user}",
      "gists_url": "https://api.github.com/users/0xc1c4da/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/0xc1c4da/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/0xc1c4da/subscriptions",
      "organizations_url": "https://api.github.com/users/0xc1c4da/orgs",
      "repos_url": "https://api.github.com/users/0xc1c4da/repos",
      "events_url": "https://api.github.com/users/0xc1c4da/events{/privacy}",
      "received_events_url": "https://api.github.com/users/0xc1c4da/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-23T20:13:51Z",
    "updated_at": "2017-10-23T20:16:57Z",
    "author_association": "NONE",
    "body": "Hey guys! We've started the draft implementation of #725 and #735 in both Solidity and Viper. Special thanks to @jacqueswww and @3esmit for whipping them up!\r\n\r\nhttps://github.com/status-im/contracts/tree/master/contracts",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/338782419/reactions",
      "total_count": 5,
      "+1": 4,
      "-1": 0,
      "laugh": 0,
      "hooray": 1,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/349016857",
    "html_url": "https://github.com/ethereum/EIPs/issues/735#issuecomment-349016857",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/735",
    "id": 349016857,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0OTAxNjg1Nw==",
    "user": {
      "login": "stephanlotter",
      "id": 4803512,
      "node_id": "MDQ6VXNlcjQ4MDM1MTI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4803512?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/stephanlotter",
      "html_url": "https://github.com/stephanlotter",
      "followers_url": "https://api.github.com/users/stephanlotter/followers",
      "following_url": "https://api.github.com/users/stephanlotter/following{/other_user}",
      "gists_url": "https://api.github.com/users/stephanlotter/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/stephanlotter/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/stephanlotter/subscriptions",
      "organizations_url": "https://api.github.com/users/stephanlotter/orgs",
      "repos_url": "https://api.github.com/users/stephanlotter/repos",
      "events_url": "https://api.github.com/users/stephanlotter/events{/privacy}",
      "received_events_url": "https://api.github.com/users/stephanlotter/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-12-04T16:29:45Z",
    "updated_at": "2017-12-04T16:29:45Z",
    "author_association": "NONE",
    "body": "@frozeman thanks for this! I'd like to see some kind of approveClaimRequest function where I need to approve a getClaim call. This will be valuable for protecting private claims like proof of address, proof of income, etc. I would not want just anybody to retrieve my address, but I would want to allow say a bank to see it when they want to verify my address. And maybe limit the number of times the requester may see the address too (a lot like approve on ERC-20). This way I can prove my address to a supplier and they can only access it that one time.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/349016857/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/349979739",
    "html_url": "https://github.com/ethereum/EIPs/issues/735#issuecomment-349979739",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/735",
    "id": 349979739,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0OTk3OTczOQ==",
    "user": {
      "login": "frozeman",
      "id": 232662,
      "node_id": "MDQ6VXNlcjIzMjY2Mg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/232662?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/frozeman",
      "html_url": "https://github.com/frozeman",
      "followers_url": "https://api.github.com/users/frozeman/followers",
      "following_url": "https://api.github.com/users/frozeman/following{/other_user}",
      "gists_url": "https://api.github.com/users/frozeman/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/frozeman/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/frozeman/subscriptions",
      "organizations_url": "https://api.github.com/users/frozeman/orgs",
      "repos_url": "https://api.github.com/users/frozeman/repos",
      "events_url": "https://api.github.com/users/frozeman/events{/privacy}",
      "received_events_url": "https://api.github.com/users/frozeman/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-12-07T14:18:24Z",
    "updated_at": "2017-12-07T14:18:24Z",
    "author_association": "CONTRIBUTOR",
    "body": "@stephanlotter This function doesn't make much sense, as the data blockchain is publicly readable anyway. But you are right there should be a process of how i can make claims CONTENT data accessible, which is not defined in this standard and needs to be around a claim data retrieval standard.\r\n\r\nso whatever claim references you put on your public profile will be readable by everybody. BUT you 1. only put references to claims, not the data itself, and 2. could have a secret claim registry like what uport is building where you can give access on a request basis.\r\n\r\nThis is more about like your \"public profile\", which actually only reveals who claim what topics/types, and not what _content_.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/349979739/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/352440823",
    "html_url": "https://github.com/ethereum/EIPs/issues/735#issuecomment-352440823",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/735",
    "id": 352440823,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1MjQ0MDgyMw==",
    "user": {
      "login": "svenstucki",
      "id": 692141,
      "node_id": "MDQ6VXNlcjY5MjE0MQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/692141?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/svenstucki",
      "html_url": "https://github.com/svenstucki",
      "followers_url": "https://api.github.com/users/svenstucki/followers",
      "following_url": "https://api.github.com/users/svenstucki/following{/other_user}",
      "gists_url": "https://api.github.com/users/svenstucki/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/svenstucki/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/svenstucki/subscriptions",
      "organizations_url": "https://api.github.com/users/svenstucki/orgs",
      "repos_url": "https://api.github.com/users/svenstucki/repos",
      "events_url": "https://api.github.com/users/svenstucki/events{/privacy}",
      "received_events_url": "https://api.github.com/users/svenstucki/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-12-18T14:29:15Z",
    "updated_at": "2017-12-18T14:30:16Z",
    "author_association": "NONE",
    "body": "I like the idea of adding an expiration date. I think it's better than a creation / issue date, since it's very easy to check. With an issue date only, there's external information needed to check a claim.\r\n\r\nIt's also much more practical than revoking keys all the time - e.g. imagine you are the equivalent of a CA for ERC725/735 and issue a lot of claims. If you want them to have an expiration date, you'll have to add a separate key for each of them and remove them again at the right time. Not very efficient. There's a similar problem with revocation in that case, which is not easy to solve. That would probably work best with a claim holder registry.\r\n\r\n---\r\n\r\nIs the `url` intentionally not covered by the signature? I.e. allowing users to move their data to a different storage location is permitted (of course the integrity can still be verified)?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/352440823/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/352443157",
    "html_url": "https://github.com/ethereum/EIPs/issues/735#issuecomment-352443157",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/735",
    "id": 352443157,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1MjQ0MzE1Nw==",
    "user": {
      "login": "frozeman",
      "id": 232662,
      "node_id": "MDQ6VXNlcjIzMjY2Mg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/232662?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/frozeman",
      "html_url": "https://github.com/frozeman",
      "followers_url": "https://api.github.com/users/frozeman/followers",
      "following_url": "https://api.github.com/users/frozeman/following{/other_user}",
      "gists_url": "https://api.github.com/users/frozeman/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/frozeman/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/frozeman/subscriptions",
      "organizations_url": "https://api.github.com/users/frozeman/orgs",
      "repos_url": "https://api.github.com/users/frozeman/repos",
      "events_url": "https://api.github.com/users/frozeman/events{/privacy}",
      "received_events_url": "https://api.github.com/users/frozeman/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-12-18T14:37:39Z",
    "updated_at": "2017-12-18T14:52:03Z",
    "author_association": "CONTRIBUTOR",
    "body": "@svenstucki I was discussing this with @chriseth as well. Adding an expiry means this needs to be part of the signature.\r\n\r\nIt might be inefficient to revoke keys, but would give a real time expiry. But i am open for discussion about adding that.\r\n\r\nAnd yes the location should be irrelevant, as long as the data itself is referenced by hash.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/352443157/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
