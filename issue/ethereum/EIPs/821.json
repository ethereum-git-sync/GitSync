{
  "url": "https://api.github.com/repos/ethereum/EIPs/issues/821",
  "repository_url": "https://api.github.com/repos/ethereum/EIPs",
  "labels_url": "https://api.github.com/repos/ethereum/EIPs/issues/821/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/EIPs/issues/821/comments",
  "events_url": "https://api.github.com/repos/ethereum/EIPs/issues/821/events",
  "html_url": "https://github.com/ethereum/EIPs/issues/821",
  "id": 286291948,
  "node_id": "MDU6SXNzdWUyODYyOTE5NDg=",
  "number": 821,
  "title": "EIP 821: Distinguishable Assets Registry (Contract for NFTs)",
  "user": {
    "login": "eordano",
    "id": 42750,
    "node_id": "MDQ6VXNlcjQyNzUw",
    "avatar_url": "https://avatars.githubusercontent.com/u/42750?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/eordano",
    "html_url": "https://github.com/eordano",
    "followers_url": "https://api.github.com/users/eordano/followers",
    "following_url": "https://api.github.com/users/eordano/following{/other_user}",
    "gists_url": "https://api.github.com/users/eordano/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/eordano/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/eordano/subscriptions",
    "organizations_url": "https://api.github.com/users/eordano/orgs",
    "repos_url": "https://api.github.com/users/eordano/repos",
    "events_url": "https://api.github.com/users/eordano/events{/privacy}",
    "received_events_url": "https://api.github.com/users/eordano/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [

  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 84,
  "created_at": "2018-01-05T13:42:20Z",
  "updated_at": "2018-03-04T07:39:47Z",
  "closed_at": "2018-03-04T07:39:47Z",
  "author_association": "NONE",
  "active_lock_reason": null,
  "body": "    EIP: <not assigned>\r\n    Title: Distinguishable Assets Registry\r\n    Author: Esteban Ordano <esteban@decentraland.org>\r\n    Type: Standard Track\r\n    Category: ERC\r\n    Status: Draft\r\n    Created: 2018-01-05\r\n    Updated: 2018-02-21\r\n\r\n## Summary\r\n\r\nA Distinguishable Assets Registry (DAR for short) is a contract that tracks ownership of, and information about a set of assets that are distinguishable from each other, and are commonly refferred to as \"NFTs\", for \"Non Fungible Tokens\".\r\n\r\nSee https://github.com/decentraland/erc821 for a reference implementation.\r\n\r\nSee the \"Revisions\" section for a history of this ERC.\r\n\r\n## Abstract\r\n\r\nTracking the ownership of physical or digital distinguishable items on a blockchain has a broad range of applications, from virtual collectibles to physical art pieces. This proposal aims at standardizing a way to reference distinguishable assets along with the foreseeable required operations and interfaces for effective management of those assets on a blockchain.\r\n\r\n## Introduction\r\n\r\nThe number of virtual collectibles tracked on the Ethereum blockchain is rapidly growing, creating a demand for a more robust standard for distinguishable digital assets. This proposal suggests improvements to the vocabulary used to refer to such assets, and attempts to provide a solid and future-proof reference implementation of the basic functionality needed. This EIP also proposes better naming conventions and vocabulary for the different components of the NFT economy: the assets, the NFTs (representations of those assets on the blockchain), the DARs (the contracts registering such assets), distinguishing ownership from holding addresses, and more.\r\n\r\nSee also: ERC #721, ERC #20, ERC #223, and ERC #777.\r\n\r\nThe key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\",  \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119.\r\n\r\n## Specification\r\n\r\nA non-fungible token (NFT) is a distinguishable asset that has a unique representation as a register in a smart contract. This proposal specifies such contracts, referenced as Distinguishable Asset Registries, or DARs. NFTs MAY also be reffered to as \"deeds\".\r\n\r\nDARs can be identified by the blockchain in which they were deployed, and the 160-bit address of the contract instance. NFTs are identified by an ID, a 256 bit number, which MAY correspond to some cryptographic hash of the non-fungible's natural key.\r\n\r\nNFTs SHOULD be referenced by a URI that follows this schema:\r\n\r\n    nft://<chain's common name>/<DAR's address>/<NFT's ID>\r\n\r\nThe NFT's ID SHOULD have a hint that helps to decode it. For instance, if the encoding of the number is in hexadecimal, the NFT’s ID SHOULD start with `0x`. The DAR's address SHOULD follow the checksum by casing as proposed on #55.\r\n\r\nSome common names for Ethereum blockchains are:\r\n\r\n* `ethereum`, `livenet`, or `mainnet`\r\n* `ropsten`, `testnet`\r\n* `kovan`\r\n* `rinkeby`\r\n\r\nSome examples of NFT URIs follow:\r\n\r\n* nft://ethereum/0xF87E31492Faf9A91B02Ee0dEAAd50d51d56D5d4d/0\r\n* nft://ropsten/0xF87E31492Faf9A91B02Ee0dEAAd50d51d56D5d4d/0xfaa5be24e996feadf4c96b905af2c77c456e2debd075bab4d8fd5f70f209de44\r\n\r\nEvery NFT MUST have a `owner` address associated with it. NFTs associated with the null address are assumed non-existent or destroyed.\r\n\r\nAn owner MAY assign one or multiple `operator` addresses. These addresses will be able to transfer any asset of the owner.\r\n\r\nDARs MUST trigger `Transfer` events every time a NFT's `owner` changes. This might happen under three circumstances:\r\n\r\n* A NFT is created. In this case, the `from` value of the `Transfer` event MUST be the zero address.\r\n* A NFT is transferred to a different owner.\r\n* A NFT is destroyed. In this case, the `to` value of the `Transfer` event MUST be the zero address.\r\n\r\n`Transfer` events SHALL NOT simultaneously have a zero value in both the `from` and `to` fields (this means, the same `Transfer` event can't both create and destroy a token).\r\n\r\n#### Associated Metadata\r\n\r\nMetadata associated with each asset is out of scope for this standard.\r\n\r\n### DAR global methods\r\n\r\n#### `totalSupply():uint256`\r\n\r\nReturn the total amount of assets under this DAR. This method SHALL NOT throw.\r\n\r\n#### `supportsInterface(bytes8 interfaceId):bool`\r\n\r\nThis method returns `true` if the `interfaceId` is a supported interface (165, corresponding to 0x01ffc9a7, or 821, corresponding to 0x959d7abb). This method SHALL NOT throw.\r\n\r\n### NFT getter methods\r\n\r\n#### `exists(uint256 assetId):bool`\r\n\r\nThis method returns a boolean value, `true` if the asset identified with the given `assetId` exists under this DAR. This method SHALL NOT throw.\r\n\r\n#### `ownerOf(uint256 assetId):address`\r\n\r\nThis method returns the `address` of the owner of the NFT. This method SHALL NOT throw. If the `assetId` does not exist, the return value MUST be the null address.\r\n\r\n### Owner-centric getter methods\r\n\r\n#### `balanceOf(address owner):uint256`\r\n\r\nThis method returns the amount of NFTs held by the `owner` address under this DAR. This method MUST not throw.\r\n\r\n#### `assetByIndex(address owner, uint256 index):uint256`\r\n\r\nThis method returns the ID of the `index`th NFT held by the `owner` address under this DAR, when all the IDs of the NFTs held by such address are stored as an array.\r\n\r\nThis method MUST throw if `assetCount(owner) >= index`. This method MUST throw if `index >= 2^128`.\r\n\r\nThe DAR MAY change the order assigned to any NFT held by a particular address.\r\n\r\nThis method is expected to be used by other contracts to iterate through an `owner`'s assets. Contracts implementing such iterations SHOULD be aware of race conditions that might occur, if this iteration happens over multiple transactions.\r\n\r\n#### `assetsOf(address owner):uint256[]`\r\n\r\nThis method returns an array of IDs of the NFTs held by `owner`. This method SHALL NOT throw.\r\n\r\n### Operator getters\r\n\r\n#### `isAuthorizedBy(address operator, address owner):bool`\r\n\r\nThis method returns `true` if `owner` has called the method `authorize` with parameters `(operator, true)` and has not called `authorize(operator, false)` afterwards. This method returns `false` otherwise.\r\n\r\nThis method MUST return `true` if `operator == owner`.\r\n\r\nThis method SHALL NOT throw.\r\n\r\n#### `isApprovedFor(address operator, uint256 assetId):bool`\r\n\r\nThis method returns `true` if `owner` has called the method `approve` with parameters `(operator, assetId)` and has not called it with a different operator value afterwards. This method returns `false` otherwise.\r\n\r\nThis method MUST return `true` if `operator == owner`.\r\n\r\nThis method SHALL NOT throw.\r\n\r\n### Transfers\r\n\r\n#### `transfer(address to, uint256 assetId, bytes userData, bytes operatorData)`\r\n\r\nTransfers holding of the NFT referenced by `assetId` from `ownerOf(assetId)` to the address `to`.\r\n\r\n`to` SHALL NOT be the zero address. If `to` is the zero address, the call MUST throw.\r\n\r\n`to` SHALL NOT be `ownerOf(assetId)`. If this condition is met, the call MUST throw.\r\n\r\n`isAuthorizedBy(msg.sender, ownerOf(assetId))` MUST return true as a precondition. \r\n\r\nThis means that the `msg.sender` MUST be `ownerOf(assetId)` or an authorized operator.\r\n\r\nIf the NFT referenced by `assetId` does not exist, then the call MUST throw.\r\n\r\nIf there was any single authorized operator (see the `approve()` method below), this authorization MUST be cleared.\r\n\r\nIf the call doesn't throw, it triggers the event `Transfer` with the following parameters:\r\n\r\n* from: value of `ownerOf(assetId)` before the call\r\n* to: the `to` argument\r\n* assetId: the `assetId` argument\r\n* operator: `msg.sender`\r\n* userData: the `userData` argument\r\n* operatorData: the `operatorData` argument\r\n\r\nIf `to` is a contract's address, this call MUST verify that the contract can receive the tokens. In order to do so, the method MUST do a #165 check for support to handle tokens to the target contract.\r\nThe implementation for the receiver is as follows:\r\n```\r\ninterface IAssetHolder {\r\n  function onAssetReceived(\r\n    /* address _assetRegistry == msg.sender */\r\n    uint256 _assetId,\r\n    address _previousOwner,\r\n    address _currentOwner,\r\n    bytes   _userData\r\n  ) public;\r\n}\r\n```\r\n\r\nIf the `supportsInterface` method call fails, the transfer must be reversed and this call MUST throw. Otherwise, the method `onAssetReceived` MUST be invoked with the corresponding information, **after** the asset has been transferred.\r\n\r\n#### `transfer(address to, uint256 assetId, bytes userData)`\r\n\r\nShorthand method that MUST be equivalent to calling `transfer(to, assetId, userData, EMPTY_BYTES)`.\r\n\r\n#### `transfer(address to, uint256 assetId)`\r\n\r\nShorthand method that MUST be equivalent to calling `transfer(to, assetId, EMPTY_BYTES, EMPTY_BYTES)`.\r\n\r\n#### `transferFrom(address from, address to, uint256 assetId, bytes userData, bytes operatorData)`\r\n\r\nTransfers holding of the NFT referenced by `assetId` from `ownerOf(assetId)` to the address `to`, iff `from == ownerOf(assetId)`.\r\n\r\nAfter checking that the asset is owned by the `from` address, this method MUST behave exactly as calling `transfer(to, assetId, EMPTY_BYTES, EMPTY_BYTES)`.\r\n\r\n#### `transferFrom(address from, address to, uint256 assetId, bytes userData)`\r\n\r\nShorthand method that MUST be equivalent to calling `transferFrom(to, assetId, userData, EMPTY_BYTES)`.\r\n\r\n#### `transferFrom(address from, address to, uint256 assetId)`\r\n\r\nShorthand method that MUST be equivalent to calling `transferFrom(to, assetId, EMPTY_BYTES, EMPTY_BYTES)`.\r\n\r\n### Authorization\r\n\r\n#### `authorize(address operator, bool authorized)`\r\n\r\nIf `authorized` is `true`, allows `operator` to `transfer` any NFT held by `msg.sender`.\r\n\r\nThis method MUST throw if `operator` is the zero address. This method MUST throw if `authorized` is true and `operator` is already authorized by the sender. This method MUST throw if `authorized` is false and `operator` is unauthorized.\r\n\r\nThis method MUST throw if `msg.sender == operator`.\r\n\r\nThis method MUST trigger an `AuthorizeOperator` event if it doesn't throw.\r\n\r\n#### `approve(address operator, uint256 assetId)`\r\n\r\nAllow `operator` to `transfer` an asset without delegating full access to all assets.\r\n\r\nOnly the `owner` of an asset can call this method. Otherwise, the call MUST fail.\r\n\r\nOnly one address can receive `approval` at the same time. Clearing approval for a transfer can be done by setting the `operator` value to the zero address.\r\n\r\nThis method MUST trigger an `Approve` event if it doesn't throw.\r\n\r\n### Events\r\n\r\n```\r\ninterface AssetRegistryEvents {\r\n  event Transfer(\r\n    address indexed from,\r\n    address indexed to,\r\n    uint256 indexed assetId,\r\n    address operator,\r\n    bytes userData,\r\n    bytes operatorData\r\n  );\r\n  event AuthorizeOperator(\r\n    address indexed operator,\r\n    address indexed holder,\r\n    bool authorized\r\n  );\r\n  event Approve(\r\n    address indexed owner,\r\n    address indexed operator,\r\n    uint256 indexed assetId\r\n  );\r\n}\r\n```\r\n### Interfaces\r\n```\r\ninterface IAssetRegistry {\r\n  function totalSupply() public view returns (uint256);\r\n\r\n  function exists(uint256 assetId) public view returns (bool);\r\n  function ownerOf(uint256 assetId) public view returns (address);\r\n\r\n  function balanceOf(address holder) public view returns (uint256);\r\n\r\n  function assetByIndex(address holder, uint256 index) public view returns (uint256);\r\n  function assetsOf(address holder) external view returns (uint256[]);\r\n\r\n  function transfer(address to, uint256 assetId) public;\r\n  function transfer(address to, uint256 assetId, bytes userData) public;\r\n  function transfer(address to, uint256 assetId, bytes userData, bytes operatorData) public;\r\n\r\n  function transferFrom(address from, address to, uint256 assetId) public;\r\n  function transferFrom(address from, address to, uint256 assetId, bytes userData) public;\r\n  function transferFrom(address from, address to, uint256 assetId, bytes userData, bytes operatorData) public;\r\n\r\n  function approveAll(address operator, bool authorized) public;\r\n  function approve(address operator, uint256 assetId) public;\r\n\r\n  function isAuthorizedBy(address operator, address assetOwner) public view returns (bool);\r\n  function isApprovedFor(address operator, uint256 assetId) public view returns (bool);\r\n  function approvedFor(uint256 assetId) public view returns (address);\r\n}\r\n```\r\n\r\n## Implementation\r\n\r\nhttps://github.com/decentraland/erc821\r\n\r\n## Revisions\r\n\r\n* 2018/02/21: RC2, drop name, symbol, description\r\n* 2018/02/21: RC1\r\n* 2018/02/20: Drop metadata\r\n* 2018/02/20: Add `transferFrom`\r\n* 2018/02/20: Try to remove `operator` from public facing interfaces\r\n* 2018/02/20: Simplify `holder` -> `owner` to use the most common name\r\n* 2018/02/20: Drop all ERC820 references\r\n* 2018/02/03: Add `approve` to approve individual assets to be transferred\r\n* 2018/01/27: Add exception for `msg.sender` being the manager\r\n* 2018/01/27: Add table for `ERC820` and `IAssetHolder` interface check\r\n* 2018/01/27: Change `IAssetOwner` for `IAssetHolder` to reflect that another contract might hold tokens for one\r\n* 2018/01/27: Errata on `transfer` text\r\n* 2018/01/26: Alias \"balanceOf\" to \"assetCount\" for ERC20 compatibility\r\n* 2018/01/26: Add `decimals` for more ERC20 compatibility\r\n* 2018/01/26: Propose more metadata to be stored on-chain.\r\n* 2018/01/26: Make EIP820 compatibility optional to receive tokens if `onAssetReceived(...)` is implemented.\r\n* 2018/01/26: Add `isERC821` flag to detect support.\r\n* 2018/01/26: Revert `holder` to `owner`.\r\n* 2018/01/18: `transfer`: `to` MUST NOT be `holderOf(assetId)`\r\n* 2018/01/17: Added `safeAssetData` method\r\n* 2018/01/17: Clarification to `transfer`: it MUST throw if the asset does not exist.\r\n* 2018/01/17: Published first version of the specification\r\n* 2018/01/16: Published implementation\r\n* 2018/01/05: Initial draft\r\n\r\n## Copyright\r\n\r\nCopyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).\r\n\r\n",
  "closed_by": {
    "login": "eordano",
    "id": 42750,
    "node_id": "MDQ6VXNlcjQyNzUw",
    "avatar_url": "https://avatars.githubusercontent.com/u/42750?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/eordano",
    "html_url": "https://github.com/eordano",
    "followers_url": "https://api.github.com/users/eordano/followers",
    "following_url": "https://api.github.com/users/eordano/following{/other_user}",
    "gists_url": "https://api.github.com/users/eordano/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/eordano/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/eordano/subscriptions",
    "organizations_url": "https://api.github.com/users/eordano/orgs",
    "repos_url": "https://api.github.com/users/eordano/repos",
    "events_url": "https://api.github.com/users/eordano/events{/privacy}",
    "received_events_url": "https://api.github.com/users/eordano/received_events",
    "type": "User",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/821/reactions",
    "total_count": 41,
    "+1": 28,
    "-1": 0,
    "laugh": 0,
    "hooray": 3,
    "confused": 0,
    "heart": 10,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/EIPs/issues/821/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/357948933",
    "html_url": "https://github.com/ethereum/EIPs/issues/821#issuecomment-357948933",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/821",
    "id": 357948933,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1Nzk0ODkzMw==",
    "user": {
      "login": "ImAllInNow",
      "id": 5776003,
      "node_id": "MDQ6VXNlcjU3NzYwMDM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5776003?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ImAllInNow",
      "html_url": "https://github.com/ImAllInNow",
      "followers_url": "https://api.github.com/users/ImAllInNow/followers",
      "following_url": "https://api.github.com/users/ImAllInNow/following{/other_user}",
      "gists_url": "https://api.github.com/users/ImAllInNow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ImAllInNow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ImAllInNow/subscriptions",
      "organizations_url": "https://api.github.com/users/ImAllInNow/orgs",
      "repos_url": "https://api.github.com/users/ImAllInNow/repos",
      "events_url": "https://api.github.com/users/ImAllInNow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ImAllInNow/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-01-16T12:45:56Z",
    "updated_at": "2018-01-16T12:54:47Z",
    "author_association": "NONE",
    "body": "As far as I understand it from the implementation, assetByIndex will constantly change (slightly) as users trade their assets around (since the last item in their asset array is moved around). Is there any real need for the assetByIndex function then since that ordering is not very useful? An indexOfAsset(assetId) function seems more necessary as the main way UI is going to display your assets is to use something like the following:\r\n\r\n```\r\nvar assetIds = assetregistry.assetsOf(user);\r\nvar sortedAssets = new Array(assetIds.length);\r\nfor (var i = 0; i < assetIds.length; ++i) {\r\n    sortedAssets[assetregistry.indexOf(assetIds[i])] = assetId;\r\n}\r\n```\r\n\r\nEdit:\r\nIt may be that assetByIndex should be implemented to return the asset such that it's actual id in the _indexOfAsset map == index (which it doesn't in your current implementation). It could be that assetByIndex needs to be implemented more like below:\r\n\r\n```\r\nfunction assetByIndex(address holder, uint256 index) external view returns (uint256) {\r\n    uint size = _assetsOf[holder].length;\r\n    require(index < size);\r\n    for (uint i = 0; i < size; i++) {\r\n        uint256 asset = _assetOf[holder][i];\r\n        if (_indexOfAsset[asset] == index) {\r\n           return asset;\r\n        }\r\n    }\r\n    assert(1 == 0);\r\n}\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/357948933/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/357953284",
    "html_url": "https://github.com/ethereum/EIPs/issues/821#issuecomment-357953284",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/821",
    "id": 357953284,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1Nzk1MzI4NA==",
    "user": {
      "login": "ImAllInNow",
      "id": 5776003,
      "node_id": "MDQ6VXNlcjU3NzYwMDM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5776003?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ImAllInNow",
      "html_url": "https://github.com/ImAllInNow",
      "followers_url": "https://api.github.com/users/ImAllInNow/followers",
      "following_url": "https://api.github.com/users/ImAllInNow/following{/other_user}",
      "gists_url": "https://api.github.com/users/ImAllInNow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ImAllInNow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ImAllInNow/subscriptions",
      "organizations_url": "https://api.github.com/users/ImAllInNow/orgs",
      "repos_url": "https://api.github.com/users/ImAllInNow/repos",
      "events_url": "https://api.github.com/users/ImAllInNow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ImAllInNow/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-01-16T13:05:15Z",
    "updated_at": "2018-01-16T13:16:38Z",
    "author_association": "NONE",
    "body": "I don't think create() (and possibly update()) should necessarily be part of a standard ERC821 token. They seem optional, and for many assets, their creation probably won't be a publicly accessible function and updating might not be relevant for that contract.\r\n\r\nEdit:\r\nThinking about it more, I think there is a potential to front-run the create() function too. If a malicious user sees a create call being made pending, they could create that same asset for themselves first. It would make managing these assets difficult to have to try and ignore maliciously added assetIds.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/357953284/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/358013060",
    "html_url": "https://github.com/ethereum/EIPs/issues/821#issuecomment-358013060",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/821",
    "id": 358013060,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1ODAxMzA2MA==",
    "user": {
      "login": "eordano",
      "id": 42750,
      "node_id": "MDQ6VXNlcjQyNzUw",
      "avatar_url": "https://avatars.githubusercontent.com/u/42750?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/eordano",
      "html_url": "https://github.com/eordano",
      "followers_url": "https://api.github.com/users/eordano/followers",
      "following_url": "https://api.github.com/users/eordano/following{/other_user}",
      "gists_url": "https://api.github.com/users/eordano/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/eordano/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/eordano/subscriptions",
      "organizations_url": "https://api.github.com/users/eordano/orgs",
      "repos_url": "https://api.github.com/users/eordano/repos",
      "events_url": "https://api.github.com/users/eordano/events{/privacy}",
      "received_events_url": "https://api.github.com/users/eordano/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-01-16T16:08:22Z",
    "updated_at": "2018-01-16T16:08:57Z",
    "author_association": "NONE",
    "body": "Thanks @ImAllInNow! \r\n\r\n1) Regarding `assetByIndex`. The idea behind this is to have that accessed from a smart contract. Use case: access from another contract for migrating all assets in batch mode to a new owner. `allAssets` might consume too much gas, or kill the evm stack\r\n\r\n2) You're right about `create`. Front-running makes it a no-go. I'll keep them in the standard implementation as `internal`.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/358013060/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/358014800",
    "html_url": "https://github.com/ethereum/EIPs/issues/821#issuecomment-358014800",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/821",
    "id": 358014800,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1ODAxNDgwMA==",
    "user": {
      "login": "eordano",
      "id": 42750,
      "node_id": "MDQ6VXNlcjQyNzUw",
      "avatar_url": "https://avatars.githubusercontent.com/u/42750?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/eordano",
      "html_url": "https://github.com/eordano",
      "followers_url": "https://api.github.com/users/eordano/followers",
      "following_url": "https://api.github.com/users/eordano/following{/other_user}",
      "gists_url": "https://api.github.com/users/eordano/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/eordano/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/eordano/subscriptions",
      "organizations_url": "https://api.github.com/users/eordano/orgs",
      "repos_url": "https://api.github.com/users/eordano/repos",
      "events_url": "https://api.github.com/users/eordano/events{/privacy}",
      "received_events_url": "https://api.github.com/users/eordano/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-01-16T16:13:33Z",
    "updated_at": "2018-01-16T16:14:09Z",
    "author_association": "NONE",
    "body": "Regarding `update` and the metadata: is there really a case where no errata would be published? For my quick checklist:\r\n- [ ] Real world art pieces: `update` is good for appending new information (change of location, status, news)\r\n- [ ] Virtual trading card games: `update` is great for amendment on card rules\r\n- [ ] Virtual collectibles: `update` is used for errata or fixing typos\r\n- [ ] Decentraland Land: `update` is used to store the data for the land\r\n\r\nThe rule of the owner being the one authorized to make the changes is policy. You're right, it should not be part of the standard (same as before, I'll keep the mechanism as internal so the implementor can decide on the policy)",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/358014800/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/358015682",
    "html_url": "https://github.com/ethereum/EIPs/issues/821#issuecomment-358015682",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/821",
    "id": 358015682,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1ODAxNTY4Mg==",
    "user": {
      "login": "eordano",
      "id": 42750,
      "node_id": "MDQ6VXNlcjQyNzUw",
      "avatar_url": "https://avatars.githubusercontent.com/u/42750?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/eordano",
      "html_url": "https://github.com/eordano",
      "followers_url": "https://api.github.com/users/eordano/followers",
      "following_url": "https://api.github.com/users/eordano/following{/other_user}",
      "gists_url": "https://api.github.com/users/eordano/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/eordano/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/eordano/subscriptions",
      "organizations_url": "https://api.github.com/users/eordano/orgs",
      "repos_url": "https://api.github.com/users/eordano/repos",
      "events_url": "https://api.github.com/users/eordano/events{/privacy}",
      "received_events_url": "https://api.github.com/users/eordano/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-01-16T16:16:10Z",
    "updated_at": "2018-01-16T16:16:10Z",
    "author_association": "NONE",
    "body": "Last note on `assetsOf`: there's a problem of concurrency, it would be nice to have a function that atomically returns all assetIds and all the associated data (otherwise if the order changes between fetches the UI will display erroneous information).\r\n\r\nI'll add a note that UIs should list the items in sorted order, or keep their own information based on the transfer logs or user preferences.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/358015682/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/358022298",
    "html_url": "https://github.com/ethereum/EIPs/issues/821#issuecomment-358022298",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/821",
    "id": 358022298,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1ODAyMjI5OA==",
    "user": {
      "login": "ImAllInNow",
      "id": 5776003,
      "node_id": "MDQ6VXNlcjU3NzYwMDM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5776003?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ImAllInNow",
      "html_url": "https://github.com/ImAllInNow",
      "followers_url": "https://api.github.com/users/ImAllInNow/followers",
      "following_url": "https://api.github.com/users/ImAllInNow/following{/other_user}",
      "gists_url": "https://api.github.com/users/ImAllInNow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ImAllInNow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ImAllInNow/subscriptions",
      "organizations_url": "https://api.github.com/users/ImAllInNow/orgs",
      "repos_url": "https://api.github.com/users/ImAllInNow/repos",
      "events_url": "https://api.github.com/users/ImAllInNow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ImAllInNow/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-01-16T16:36:17Z",
    "updated_at": "2018-01-16T16:36:17Z",
    "author_association": "NONE",
    "body": "@eordano You're right about update. I was getting it confused with updating the assetId rather than the data associated with the assetId.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/358022298/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/358156701",
    "html_url": "https://github.com/ethereum/EIPs/issues/821#issuecomment-358156701",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/821",
    "id": 358156701,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1ODE1NjcwMQ==",
    "user": {
      "login": "abcoathup",
      "id": 28278242,
      "node_id": "MDQ6VXNlcjI4Mjc4MjQy",
      "avatar_url": "https://avatars.githubusercontent.com/u/28278242?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/abcoathup",
      "html_url": "https://github.com/abcoathup",
      "followers_url": "https://api.github.com/users/abcoathup/followers",
      "following_url": "https://api.github.com/users/abcoathup/following{/other_user}",
      "gists_url": "https://api.github.com/users/abcoathup/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/abcoathup/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/abcoathup/subscriptions",
      "organizations_url": "https://api.github.com/users/abcoathup/orgs",
      "repos_url": "https://api.github.com/users/abcoathup/repos",
      "events_url": "https://api.github.com/users/abcoathup/events{/privacy}",
      "received_events_url": "https://api.github.com/users/abcoathup/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-01-17T00:44:04Z",
    "updated_at": "2018-01-17T00:44:04Z",
    "author_association": "CONTRIBUTOR",
    "body": "For those coming straight to ERC821 @eordano has written a distinguishable asset manifesto: https://blog.decentraland.org/the-non-fungibles-revolution-of-2018-304270525b05",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/358156701/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/358163141",
    "html_url": "https://github.com/ethereum/EIPs/issues/821#issuecomment-358163141",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/821",
    "id": 358163141,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1ODE2MzE0MQ==",
    "user": {
      "login": "abcoathup",
      "id": 28278242,
      "node_id": "MDQ6VXNlcjI4Mjc4MjQy",
      "avatar_url": "https://avatars.githubusercontent.com/u/28278242?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/abcoathup",
      "html_url": "https://github.com/abcoathup",
      "followers_url": "https://api.github.com/users/abcoathup/followers",
      "following_url": "https://api.github.com/users/abcoathup/following{/other_user}",
      "gists_url": "https://api.github.com/users/abcoathup/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/abcoathup/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/abcoathup/subscriptions",
      "organizations_url": "https://api.github.com/users/abcoathup/orgs",
      "repos_url": "https://api.github.com/users/abcoathup/repos",
      "events_url": "https://api.github.com/users/abcoathup/events{/privacy}",
      "received_events_url": "https://api.github.com/users/abcoathup/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-01-17T01:20:11Z",
    "updated_at": "2018-01-17T01:20:11Z",
    "author_association": "CONTRIBUTOR",
    "body": "My original thinking for (unique) assets was given existing ERC20 support in wallets was to create assets that are ERC20 compatible, rather than get wallets to support (unique) assets but if we can get enough support for a unique assets standard for wallets to implement, then all the better.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/358163141/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/358167639",
    "html_url": "https://github.com/ethereum/EIPs/issues/821#issuecomment-358167639",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/821",
    "id": 358167639,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1ODE2NzYzOQ==",
    "user": {
      "login": "abcoathup",
      "id": 28278242,
      "node_id": "MDQ6VXNlcjI4Mjc4MjQy",
      "avatar_url": "https://avatars.githubusercontent.com/u/28278242?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/abcoathup",
      "html_url": "https://github.com/abcoathup",
      "followers_url": "https://api.github.com/users/abcoathup/followers",
      "following_url": "https://api.github.com/users/abcoathup/following{/other_user}",
      "gists_url": "https://api.github.com/users/abcoathup/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/abcoathup/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/abcoathup/subscriptions",
      "organizations_url": "https://api.github.com/users/abcoathup/orgs",
      "repos_url": "https://api.github.com/users/abcoathup/repos",
      "events_url": "https://api.github.com/users/abcoathup/events{/privacy}",
      "received_events_url": "https://api.github.com/users/abcoathup/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-01-17T01:46:03Z",
    "updated_at": "2018-01-17T01:46:03Z",
    "author_association": "CONTRIBUTOR",
    "body": "**Cost**\r\nFor me reducing the cost of creation and send are hugely important.  So want to think about how the standard impacts the implementation and hence the cost.\r\n\r\n**ERC821 meta data**\r\n(Similar to my comments on ERC721)\r\nFor assets to be displayed in wallets we ideally want a name, logo and possibly a symbol representing the assets in ERC21 registry.\r\nMetaMask uses name and logo with optional symbol in their metadata. https://github.com/MetaMask/eth-contract-metadata\r\nIdeally the logo would be non-optional, though there will likely be use cases where assets won’t want to be displayed in wallets\r\n\r\n**CUD**\r\nCUD access may depend on the implementation. E.g.:\r\nCreate may only be called by the contract owner.\r\nUpdate may only be called by the contract owner or the asset owner depending on what is in data.\r\nDestroy may only be called by the asset owner.\r\n\r\n**Send**\r\nDoes the standard need two send functions?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/358167639/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/358196025",
    "html_url": "https://github.com/ethereum/EIPs/issues/821#issuecomment-358196025",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/821",
    "id": 358196025,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1ODE5NjAyNQ==",
    "user": {
      "login": "eordano",
      "id": 42750,
      "node_id": "MDQ6VXNlcjQyNzUw",
      "avatar_url": "https://avatars.githubusercontent.com/u/42750?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/eordano",
      "html_url": "https://github.com/eordano",
      "followers_url": "https://api.github.com/users/eordano/followers",
      "following_url": "https://api.github.com/users/eordano/following{/other_user}",
      "gists_url": "https://api.github.com/users/eordano/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/eordano/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/eordano/subscriptions",
      "organizations_url": "https://api.github.com/users/eordano/orgs",
      "repos_url": "https://api.github.com/users/eordano/repos",
      "events_url": "https://api.github.com/users/eordano/events{/privacy}",
      "received_events_url": "https://api.github.com/users/eordano/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-01-17T04:47:28Z",
    "updated_at": "2018-01-17T04:47:28Z",
    "author_association": "NONE",
    "body": "Thanks for the comments, @abcoathup! Please note that I've updated the body of the proposal to include as much detail as I thought necessary\r\n\r\n1) Cost: I can run some benchmarks tomorrow and give you some estimate\r\n\r\n2) Should we add a `logo`? Should there be some kind of specification, perhaps following iOS or Android's standard for logo sizes?\r\n\r\n3) CUD: Updated to reflect your thoughts. Note:\r\n\r\n```Our implementation tries to follow the UNIX principle of providing mechanisms, not policy. That's why it contains functions to create, update, and destroy tokens, but they are marked as internal.```\r\n\r\n4) Does it save a significant amount of gas? I think not, except perhaps for calls between contracts?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/358196025/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/358212233",
    "html_url": "https://github.com/ethereum/EIPs/issues/821#issuecomment-358212233",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/821",
    "id": 358212233,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1ODIxMjIzMw==",
    "user": {
      "login": "abcoathup",
      "id": 28278242,
      "node_id": "MDQ6VXNlcjI4Mjc4MjQy",
      "avatar_url": "https://avatars.githubusercontent.com/u/28278242?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/abcoathup",
      "html_url": "https://github.com/abcoathup",
      "followers_url": "https://api.github.com/users/abcoathup/followers",
      "following_url": "https://api.github.com/users/abcoathup/following{/other_user}",
      "gists_url": "https://api.github.com/users/abcoathup/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/abcoathup/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/abcoathup/subscriptions",
      "organizations_url": "https://api.github.com/users/abcoathup/orgs",
      "repos_url": "https://api.github.com/users/abcoathup/repos",
      "events_url": "https://api.github.com/users/abcoathup/events{/privacy}",
      "received_events_url": "https://api.github.com/users/abcoathup/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-01-17T06:40:54Z",
    "updated_at": "2018-01-17T06:46:54Z",
    "author_association": "CONTRIBUTOR",
    "body": "@eordano rather than `description` for the DAR, I was thinking this should be `data` (metaData) in the same format as the `data` for the NFT and include a logo.\r\n\r\nSuggest reaching out to wallets and dApp browsers (e.g. the likes of MetaMask, Toshi, Status.im and Cipher Browser) for input on logo specifications.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/358212233/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/358213056",
    "html_url": "https://github.com/ethereum/EIPs/issues/821#issuecomment-358213056",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/821",
    "id": 358213056,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1ODIxMzA1Ng==",
    "user": {
      "login": "abcoathup",
      "id": 28278242,
      "node_id": "MDQ6VXNlcjI4Mjc4MjQy",
      "avatar_url": "https://avatars.githubusercontent.com/u/28278242?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/abcoathup",
      "html_url": "https://github.com/abcoathup",
      "followers_url": "https://api.github.com/users/abcoathup/followers",
      "following_url": "https://api.github.com/users/abcoathup/following{/other_user}",
      "gists_url": "https://api.github.com/users/abcoathup/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/abcoathup/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/abcoathup/subscriptions",
      "organizations_url": "https://api.github.com/users/abcoathup/orgs",
      "repos_url": "https://api.github.com/users/abcoathup/repos",
      "events_url": "https://api.github.com/users/abcoathup/events{/privacy}",
      "received_events_url": "https://api.github.com/users/abcoathup/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-01-17T06:46:21Z",
    "updated_at": "2018-01-17T06:46:21Z",
    "author_association": "CONTRIBUTOR",
    "body": "Is there a need for both `holderOf` and 'safeHolderOf' when there is an `exists`?\r\n\r\nShould all functions that accept an `assetId` require that it exists so there is consistent behavior?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/358213056/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/358279468",
    "html_url": "https://github.com/ethereum/EIPs/issues/821#issuecomment-358279468",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/821",
    "id": 358279468,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1ODI3OTQ2OA==",
    "user": {
      "login": "eordano",
      "id": 42750,
      "node_id": "MDQ6VXNlcjQyNzUw",
      "avatar_url": "https://avatars.githubusercontent.com/u/42750?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/eordano",
      "html_url": "https://github.com/eordano",
      "followers_url": "https://api.github.com/users/eordano/followers",
      "following_url": "https://api.github.com/users/eordano/following{/other_user}",
      "gists_url": "https://api.github.com/users/eordano/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/eordano/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/eordano/subscriptions",
      "organizations_url": "https://api.github.com/users/eordano/orgs",
      "repos_url": "https://api.github.com/users/eordano/repos",
      "events_url": "https://api.github.com/users/eordano/events{/privacy}",
      "received_events_url": "https://api.github.com/users/eordano/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-01-17T11:40:18Z",
    "updated_at": "2018-01-17T11:40:18Z",
    "author_association": "NONE",
    "body": "`safeHolderOf` is a cheaper way of calling `exists` and `holderOf`.\r\n\r\nDiscussion comes from #721 throwing on `ownerOf` if the asset doesn't exist. I think this prevented `exists` from being calculated.\r\n\r\nMy take on this is that both are valid use cases... that you might want to save *some* gas by just calling `safeHolderOf`, but that there might be some useful way of checking `holderOf` and calculating `exists` yourself. For example, when used as an external function and you want to do only one roundtrip.\r\n\r\nThe other functions that accept an assetId are not relevantly modified by this behavior, except maybe on the case of `assetData`, but it might be expected that `safeHolderOf` would be called first, or the logic implemented \"client\"-side.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/358279468/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/358322340",
    "html_url": "https://github.com/ethereum/EIPs/issues/821#issuecomment-358322340",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/821",
    "id": 358322340,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1ODMyMjM0MA==",
    "user": {
      "login": "AnthonyAkentiev",
      "id": 1623033,
      "node_id": "MDQ6VXNlcjE2MjMwMzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1623033?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/AnthonyAkentiev",
      "html_url": "https://github.com/AnthonyAkentiev",
      "followers_url": "https://api.github.com/users/AnthonyAkentiev/followers",
      "following_url": "https://api.github.com/users/AnthonyAkentiev/following{/other_user}",
      "gists_url": "https://api.github.com/users/AnthonyAkentiev/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/AnthonyAkentiev/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/AnthonyAkentiev/subscriptions",
      "organizations_url": "https://api.github.com/users/AnthonyAkentiev/orgs",
      "repos_url": "https://api.github.com/users/AnthonyAkentiev/repos",
      "events_url": "https://api.github.com/users/AnthonyAkentiev/events{/privacy}",
      "received_events_url": "https://api.github.com/users/AnthonyAkentiev/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-01-17T14:34:02Z",
    "updated_at": "2018-01-17T14:34:10Z",
    "author_association": "NONE",
    "body": "Thx for the great idea.\r\nI think that you have to describe how #821 is different/better from the #721. \r\n\r\nAs long as #721 was added before, it is your goal to clearly describe why you decided to add new non-fungible token standard. Thx again.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/358322340/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/358362031",
    "html_url": "https://github.com/ethereum/EIPs/issues/821#issuecomment-358362031",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/821",
    "id": 358362031,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1ODM2MjAzMQ==",
    "user": {
      "login": "eordano",
      "id": 42750,
      "node_id": "MDQ6VXNlcjQyNzUw",
      "avatar_url": "https://avatars.githubusercontent.com/u/42750?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/eordano",
      "html_url": "https://github.com/eordano",
      "followers_url": "https://api.github.com/users/eordano/followers",
      "following_url": "https://api.github.com/users/eordano/following{/other_user}",
      "gists_url": "https://api.github.com/users/eordano/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/eordano/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/eordano/subscriptions",
      "organizations_url": "https://api.github.com/users/eordano/orgs",
      "repos_url": "https://api.github.com/users/eordano/repos",
      "events_url": "https://api.github.com/users/eordano/events{/privacy}",
      "received_events_url": "https://api.github.com/users/eordano/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-01-17T16:34:12Z",
    "updated_at": "2018-01-17T16:34:12Z",
    "author_association": "NONE",
    "body": "I'll expand later, but for the time being:\r\n\r\n1) If I have 100 NFTs, calling `approve` 100 times with the same `to` value (a decentralized exchange probably) is very inefficient, specially given that it's usually used that way (see Etherdelta, 0x)\r\n2) Lack of `exists` function in #721 -- There's no way to do a \"try-catch\" for `ownerOf` from a contract.\r\n3) Lack of `transferAndCall` functionality -- More than 4 million USD have been lost according to https://github.com/Dexaran/ERC223-token-standard. It's **critical** that we have a way to not loose tokens for sending them to a contract that doesn't handle it.\r\n4) Possibility to log more information in the `Transfer` event, following #777 \r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/358362031/reactions",
      "total_count": 4,
      "+1": 4,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/358364084",
    "html_url": "https://github.com/ethereum/EIPs/issues/821#issuecomment-358364084",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/821",
    "id": 358364084,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1ODM2NDA4NA==",
    "user": {
      "login": "dete",
      "id": 1195159,
      "node_id": "MDQ6VXNlcjExOTUxNTk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1195159?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dete",
      "html_url": "https://github.com/dete",
      "followers_url": "https://api.github.com/users/dete/followers",
      "following_url": "https://api.github.com/users/dete/following{/other_user}",
      "gists_url": "https://api.github.com/users/dete/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dete/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dete/subscriptions",
      "organizations_url": "https://api.github.com/users/dete/orgs",
      "repos_url": "https://api.github.com/users/dete/repos",
      "events_url": "https://api.github.com/users/dete/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dete/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-01-17T16:40:33Z",
    "updated_at": "2018-01-17T16:40:33Z",
    "author_association": "NONE",
    "body": "Lots of good thinking has gone into this. Decentraland brings a perspective to NFTs that we don't have at CryptoKitties. Thanks for bringing this to the community, @eordano!\r\n\r\nI'm confused as to why you think this needs to be an whole new standard, tho. I don't know about anyone else, but I don't consider ERC-721 as finalized, and I'm not sure it's appropriate to have a whole new standard that is largely the same.\r\n\r\nI appreciate that I've been a bad steward of ERC-721 for the last few weeks, and I can see how you might be frustrated by the lack of forward progress, but I would rather we find a way to move forward with one standard, rather than two. I mean, it's kind of the point of standards! 😅 ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/358364084/reactions",
      "total_count": 10,
      "+1": 10,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/358446323",
    "html_url": "https://github.com/ethereum/EIPs/issues/821#issuecomment-358446323",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/821",
    "id": 358446323,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1ODQ0NjMyMw==",
    "user": {
      "login": "eordano",
      "id": 42750,
      "node_id": "MDQ6VXNlcjQyNzUw",
      "avatar_url": "https://avatars.githubusercontent.com/u/42750?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/eordano",
      "html_url": "https://github.com/eordano",
      "followers_url": "https://api.github.com/users/eordano/followers",
      "following_url": "https://api.github.com/users/eordano/following{/other_user}",
      "gists_url": "https://api.github.com/users/eordano/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/eordano/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/eordano/subscriptions",
      "organizations_url": "https://api.github.com/users/eordano/orgs",
      "repos_url": "https://api.github.com/users/eordano/repos",
      "events_url": "https://api.github.com/users/eordano/events{/privacy}",
      "received_events_url": "https://api.github.com/users/eordano/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-01-17T21:10:28Z",
    "updated_at": "2018-01-17T21:10:28Z",
    "author_association": "NONE",
    "body": "Hey Dieter, I thought this was a better way to express the wholeness of the changes I was proposing (as you see, they are quite a lot).\r\n\r\nThe three things were I think we've got completely different approaches are:\r\n\r\n* Using `authorizeOperator` instead of individually `approve`-ing every asset\r\n* The need for `transfer` to prevent tokens from getting lost to contracts that can't handle them\r\n* Upgradability through #820 w",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/358446323/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/358482690",
    "html_url": "https://github.com/ethereum/EIPs/issues/821#issuecomment-358482690",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/821",
    "id": 358482690,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1ODQ4MjY5MA==",
    "user": {
      "login": "dete",
      "id": 1195159,
      "node_id": "MDQ6VXNlcjExOTUxNTk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1195159?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dete",
      "html_url": "https://github.com/dete",
      "followers_url": "https://api.github.com/users/dete/followers",
      "following_url": "https://api.github.com/users/dete/following{/other_user}",
      "gists_url": "https://api.github.com/users/dete/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dete/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dete/subscriptions",
      "organizations_url": "https://api.github.com/users/dete/orgs",
      "repos_url": "https://api.github.com/users/dete/repos",
      "events_url": "https://api.github.com/users/dete/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dete/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-01-17T23:19:25Z",
    "updated_at": "2018-01-17T23:19:25Z",
    "author_association": "NONE",
    "body": "> Using `authorizeOperator` instead of individually `approve`-ing every asset\r\n\r\n[I like this!](https://github.com/ethereum/EIPs/issues/721#issuecomment-354381410) I haven't had a chance to integrate it into the 721 draft, however.\r\n\r\n> The need for transfer to prevent tokens from getting lost to contracts that can't handle them\r\n\r\nUnfortunately, we do disagree on this. I think that preventing user errors is a [porcelain problem](https://git-scm.com/book/en/v2/Git-Internals-Plumbing-and-Porcelain), not a plumbing problem. It's not the job of the filesystem to decide if the file you've named `.jpg` is actually compliant with the JPEG standard. (That's admittedly an exaggerated analogy, but I don't think Ethereum will ever see mass adoption if we continue to assume that users will be directly interacting with smart contracts!)\r\n\r\n> Upgradability through #820\r\n\r\nEIP-820 is obviously very new, and looks pretty smart. So far as I can tell, it doesn't dictate anything about how an interface is structured, though, so it should be possible to use it for any standard past or future (even good ol' ERC-20).",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/358482690/reactions",
      "total_count": 3,
      "+1": 3,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/358548950",
    "html_url": "https://github.com/ethereum/EIPs/issues/821#issuecomment-358548950",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/821",
    "id": 358548950,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1ODU0ODk1MA==",
    "user": {
      "login": "ImAllInNow",
      "id": 5776003,
      "node_id": "MDQ6VXNlcjU3NzYwMDM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5776003?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ImAllInNow",
      "html_url": "https://github.com/ImAllInNow",
      "followers_url": "https://api.github.com/users/ImAllInNow/followers",
      "following_url": "https://api.github.com/users/ImAllInNow/following{/other_user}",
      "gists_url": "https://api.github.com/users/ImAllInNow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ImAllInNow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ImAllInNow/subscriptions",
      "organizations_url": "https://api.github.com/users/ImAllInNow/orgs",
      "repos_url": "https://api.github.com/users/ImAllInNow/repos",
      "events_url": "https://api.github.com/users/ImAllInNow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ImAllInNow/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-01-18T06:17:06Z",
    "updated_at": "2018-01-18T06:17:06Z",
    "author_association": "NONE",
    "body": "I agree with @dete that moving towards one NFT standard is preferable to multiple standards especially when this concept is new and has not been specifically supported by wallets/exchanges yet (that I know of).\r\n\r\nDefinitely some good improvements suggested in the interface as described here. I like the use of an authorized operator and the idea of storing an index mapping to allow for a users assets to be stored as an array for easy retrieval through MetaMask without timing out when there are large numbers of assets (I recently noticed I can't retrieve all CryptoKitties for a user anymore :( ).\r\n\r\nI think deciding to prevent user transfer errors can be left up to the contract itself. It is a slight extra cost to make this check so if a contract wants to add to the gas cost of transfers to protect their users, that's great, but I don't think it necessarily needs to be mandated in the standard.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/358548950/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/358612024",
    "html_url": "https://github.com/ethereum/EIPs/issues/821#issuecomment-358612024",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/821",
    "id": 358612024,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1ODYxMjAyNA==",
    "user": {
      "login": "simondlr",
      "id": 716965,
      "node_id": "MDQ6VXNlcjcxNjk2NQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/716965?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/simondlr",
      "html_url": "https://github.com/simondlr",
      "followers_url": "https://api.github.com/users/simondlr/followers",
      "following_url": "https://api.github.com/users/simondlr/following{/other_user}",
      "gists_url": "https://api.github.com/users/simondlr/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/simondlr/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/simondlr/subscriptions",
      "organizations_url": "https://api.github.com/users/simondlr/orgs",
      "repos_url": "https://api.github.com/users/simondlr/repos",
      "events_url": "https://api.github.com/users/simondlr/events{/privacy}",
      "received_events_url": "https://api.github.com/users/simondlr/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-01-18T10:57:45Z",
    "updated_at": "2018-01-18T10:57:45Z",
    "author_association": "NONE",
    "body": "> I think that preventing user errors is a porcelain problem, not a plumbing problem.\r\n\r\nI think regardless whether the UI should prevent the user from doing this (I think it should), it's still valuable to have another contract be notified with only requiring 1 transaction (from a plumbing perspective).",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/358612024/reactions",
      "total_count": 3,
      "+1": 3,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/359212745",
    "html_url": "https://github.com/ethereum/EIPs/issues/821#issuecomment-359212745",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/821",
    "id": 359212745,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1OTIxMjc0NQ==",
    "user": {
      "login": "macalinao",
      "id": 401263,
      "node_id": "MDQ6VXNlcjQwMTI2Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/401263?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/macalinao",
      "html_url": "https://github.com/macalinao",
      "followers_url": "https://api.github.com/users/macalinao/followers",
      "following_url": "https://api.github.com/users/macalinao/following{/other_user}",
      "gists_url": "https://api.github.com/users/macalinao/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/macalinao/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/macalinao/subscriptions",
      "organizations_url": "https://api.github.com/users/macalinao/orgs",
      "repos_url": "https://api.github.com/users/macalinao/repos",
      "events_url": "https://api.github.com/users/macalinao/events{/privacy}",
      "received_events_url": "https://api.github.com/users/macalinao/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-01-21T00:15:10Z",
    "updated_at": "2018-01-21T00:18:26Z",
    "author_association": "NONE",
    "body": "Have you considered implementing something for lienholders?\r\n\r\nLet's say you have a plot of LAND that you are using as collateral for a loan, e.g. a mortgage. What if there was a way to allow the lender contract to transfer ownership of a plot of LAND without the land owner being able to revoke this access?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/359212745/reactions",
      "total_count": 3,
      "+1": 3,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/359276751",
    "html_url": "https://github.com/ethereum/EIPs/issues/821#issuecomment-359276751",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/821",
    "id": 359276751,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1OTI3Njc1MQ==",
    "user": {
      "login": "shrugs",
      "id": 1535001,
      "node_id": "MDQ6VXNlcjE1MzUwMDE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1535001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/shrugs",
      "html_url": "https://github.com/shrugs",
      "followers_url": "https://api.github.com/users/shrugs/followers",
      "following_url": "https://api.github.com/users/shrugs/following{/other_user}",
      "gists_url": "https://api.github.com/users/shrugs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/shrugs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/shrugs/subscriptions",
      "organizations_url": "https://api.github.com/users/shrugs/orgs",
      "repos_url": "https://api.github.com/users/shrugs/repos",
      "events_url": "https://api.github.com/users/shrugs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/shrugs/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-01-21T20:11:08Z",
    "updated_at": "2018-01-21T20:11:16Z",
    "author_association": "NONE",
    "body": "I expect lienholders (new word for me!) to be a strong usecase for NFTs, especially as we move to a tokenized future. Think loans collateralized by fine art (or, hell, cryptokitties). Same with, say, propy houses.\r\n\r\nIt'd be possible to create that functionality with a \"wrapper\" contract (like an escrow), but that's not _entirely_ ideal. \r\n\r\nCould either be an optional extension to this EIP (nice) or another EIP (long process).",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/359276751/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/359532484",
    "html_url": "https://github.com/ethereum/EIPs/issues/821#issuecomment-359532484",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/821",
    "id": 359532484,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1OTUzMjQ4NA==",
    "user": {
      "login": "hyperfekt",
      "id": 9434715,
      "node_id": "MDQ6VXNlcjk0MzQ3MTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/9434715?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/hyperfekt",
      "html_url": "https://github.com/hyperfekt",
      "followers_url": "https://api.github.com/users/hyperfekt/followers",
      "following_url": "https://api.github.com/users/hyperfekt/following{/other_user}",
      "gists_url": "https://api.github.com/users/hyperfekt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/hyperfekt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/hyperfekt/subscriptions",
      "organizations_url": "https://api.github.com/users/hyperfekt/orgs",
      "repos_url": "https://api.github.com/users/hyperfekt/repos",
      "events_url": "https://api.github.com/users/hyperfekt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/hyperfekt/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-01-22T19:13:26Z",
    "updated_at": "2018-01-23T08:27:35Z",
    "author_association": "NONE",
    "body": "I suggest that every ERC821 asset registry must register the \"IAssetRegistry\" interface with ERC820, that way contracts can automatically discern if a given NFT registry conforms to this standard.  \r\nAn example of how that would be used: https://github.com/hyperfekt/ethereum-auctions/blob/master/NFTAuction.sol#L29",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/359532484/reactions",
      "total_count": 1,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 1,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/360144790",
    "html_url": "https://github.com/ethereum/EIPs/issues/821#issuecomment-360144790",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/821",
    "id": 360144790,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM2MDE0NDc5MA==",
    "user": {
      "login": "AusIV",
      "id": 977954,
      "node_id": "MDQ6VXNlcjk3Nzk1NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/977954?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/AusIV",
      "html_url": "https://github.com/AusIV",
      "followers_url": "https://api.github.com/users/AusIV/followers",
      "following_url": "https://api.github.com/users/AusIV/following{/other_user}",
      "gists_url": "https://api.github.com/users/AusIV/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/AusIV/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/AusIV/subscriptions",
      "organizations_url": "https://api.github.com/users/AusIV/orgs",
      "repos_url": "https://api.github.com/users/AusIV/repos",
      "events_url": "https://api.github.com/users/AusIV/events{/privacy}",
      "received_events_url": "https://api.github.com/users/AusIV/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-01-24T14:02:38Z",
    "updated_at": "2018-01-24T14:02:38Z",
    "author_association": "NONE",
    "body": "What is the operatorData argument of `transfer()` for? The description of \"the operatorData argument\" is a self-referential description, and says nothing about what data goes there. \r\n\r\nI'm kind of assuming it's just a blob of information that people can use when they need to communicate something not defined by the spec, but I feel like it needs more clarification.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/360144790/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/360152759",
    "html_url": "https://github.com/ethereum/EIPs/issues/821#issuecomment-360152759",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/821",
    "id": 360152759,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM2MDE1Mjc1OQ==",
    "user": {
      "login": "AusIV",
      "id": 977954,
      "node_id": "MDQ6VXNlcjk3Nzk1NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/977954?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/AusIV",
      "html_url": "https://github.com/AusIV",
      "followers_url": "https://api.github.com/users/AusIV/followers",
      "following_url": "https://api.github.com/users/AusIV/following{/other_user}",
      "gists_url": "https://api.github.com/users/AusIV/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/AusIV/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/AusIV/subscriptions",
      "organizations_url": "https://api.github.com/users/AusIV/orgs",
      "repos_url": "https://api.github.com/users/AusIV/repos",
      "events_url": "https://api.github.com/users/AusIV/events{/privacy}",
      "received_events_url": "https://api.github.com/users/AusIV/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-01-24T14:29:42Z",
    "updated_at": "2018-01-24T14:29:42Z",
    "author_association": "NONE",
    "body": "I feel like there's still room for an `approve()` call.\r\n\r\nCalling `recipient.onAssetReceived()` eliminates part of the need for `approve()` in that you an send an asset and invoke the recipient in the same call, rather than needing to call `approve()`, invoke a separate contract and have it execute `transferFrom()`. \r\n\r\nHaving `authorizeOperator()` addresses another part of the need for `approve()`, for the scenario where there may be a considerable period of time between authorization and transfer (such as waiting for an order to be filled on an exchange). But I feel authorizing another account to transfer *all* of your registered assets, much like authorizing a contract to transfer an unlimited number of your ERC20 tokens, is a bit of an anti-pattern. It saves gas, which is obviously not insignificant, but it also means that if the security of authorized operator is compromised *all* assets are subject to transfer, not just the ones you intended that operator to transfer on your behalf.\r\n\r\nIn light of the numerous security compromises we've already seen (the DAO hack, Parity Multisig Wallets Rounds 1 and 2) building a standard on the assumption that contracts will always work as intended seems short sighted. An `approve()` method would allow people to be more conservative, only risking assets they anticipate transferring in the event that the operator contract gets compromised. That would come at a higher gas cost for the authorizer, but if they are confident in the contract they are authorizing, they would still have the option to call `authorizeOperator()`.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/360152759/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/360956064",
    "html_url": "https://github.com/ethereum/EIPs/issues/821#issuecomment-360956064",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/821",
    "id": 360956064,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM2MDk1NjA2NA==",
    "user": {
      "login": "eordano",
      "id": 42750,
      "node_id": "MDQ6VXNlcjQyNzUw",
      "avatar_url": "https://avatars.githubusercontent.com/u/42750?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/eordano",
      "html_url": "https://github.com/eordano",
      "followers_url": "https://api.github.com/users/eordano/followers",
      "following_url": "https://api.github.com/users/eordano/following{/other_user}",
      "gists_url": "https://api.github.com/users/eordano/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/eordano/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/eordano/subscriptions",
      "organizations_url": "https://api.github.com/users/eordano/orgs",
      "repos_url": "https://api.github.com/users/eordano/repos",
      "events_url": "https://api.github.com/users/eordano/events{/privacy}",
      "received_events_url": "https://api.github.com/users/eordano/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-01-27T03:21:37Z",
    "updated_at": "2018-01-27T03:21:37Z",
    "author_association": "NONE",
    "body": "@AusIV the `operatorData` is there for protocols like 0x where you'd like to log some information about *why* the transaction was successful, for better auditability. For example, you could have the market making order be the operatorData, and the `userData` would be whatever arguments you want to pass on to the contract receiving the asset.\r\n\r\nI think you're right about allowing `approve` as well as `approveAll`. I was thinking that one could just have a \"filter\" contract that can take care of this granularity, to save the complexity of implementing that to the DAR, but now that I think of it again, I'm not convinced. What do you think?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/360956064/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/360956172",
    "html_url": "https://github.com/ethereum/EIPs/issues/821#issuecomment-360956172",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/821",
    "id": 360956172,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM2MDk1NjE3Mg==",
    "user": {
      "login": "eordano",
      "id": 42750,
      "node_id": "MDQ6VXNlcjQyNzUw",
      "avatar_url": "https://avatars.githubusercontent.com/u/42750?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/eordano",
      "html_url": "https://github.com/eordano",
      "followers_url": "https://api.github.com/users/eordano/followers",
      "following_url": "https://api.github.com/users/eordano/following{/other_user}",
      "gists_url": "https://api.github.com/users/eordano/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/eordano/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/eordano/subscriptions",
      "organizations_url": "https://api.github.com/users/eordano/orgs",
      "repos_url": "https://api.github.com/users/eordano/repos",
      "events_url": "https://api.github.com/users/eordano/events{/privacy}",
      "received_events_url": "https://api.github.com/users/eordano/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-01-27T03:23:28Z",
    "updated_at": "2018-01-27T03:25:48Z",
    "author_association": "NONE",
    "body": "@hyperfekt I think the correct way to go about this is that the DAR should register the `ERC821` interface (an empty interface, just using it for the name) as a way of signaling that it implements the standard... what do you think? In any case, I added the `isERC821()` method because of feedback from potential users that they want to have an easier way to check for compatibility.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/360956172/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/360956211",
    "html_url": "https://github.com/ethereum/EIPs/issues/821#issuecomment-360956211",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/821",
    "id": 360956211,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM2MDk1NjIxMQ==",
    "user": {
      "login": "eordano",
      "id": 42750,
      "node_id": "MDQ6VXNlcjQyNzUw",
      "avatar_url": "https://avatars.githubusercontent.com/u/42750?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/eordano",
      "html_url": "https://github.com/eordano",
      "followers_url": "https://api.github.com/users/eordano/followers",
      "following_url": "https://api.github.com/users/eordano/following{/other_user}",
      "gists_url": "https://api.github.com/users/eordano/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/eordano/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/eordano/subscriptions",
      "organizations_url": "https://api.github.com/users/eordano/orgs",
      "repos_url": "https://api.github.com/users/eordano/repos",
      "events_url": "https://api.github.com/users/eordano/events{/privacy}",
      "received_events_url": "https://api.github.com/users/eordano/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-01-27T03:24:17Z",
    "updated_at": "2018-01-27T03:24:49Z",
    "author_association": "NONE",
    "body": "I just updated the post with the following changes:\r\n\r\n* 2018/01/26: Alias \"balanceOf\" to \"assetCount\" for ERC20 compatibility\r\n* 2018/01/26: Add decimals for more ERC20 compatibility\r\n* 2018/01/26: Propose more metadata to be stored on-chain.\r\n* 2018/01/26: Make EIP820 compatibility optional to receive tokens if onAssetReceived(...) is implemented.\r\n* 2018/01/26: Add isERC821 flag to detect support.\r\n* 2018/01/26: Revert holder to owner.\r\n\r\nHistorical versions can be seen at:\r\nhttps://github.com/decentraland/erc821/blob/master/ERC821.md",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/360956211/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/360981489",
    "html_url": "https://github.com/ethereum/EIPs/issues/821#issuecomment-360981489",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/821",
    "id": 360981489,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM2MDk4MTQ4OQ==",
    "user": {
      "login": "hyperfekt",
      "id": 9434715,
      "node_id": "MDQ6VXNlcjk0MzQ3MTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/9434715?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/hyperfekt",
      "html_url": "https://github.com/hyperfekt",
      "followers_url": "https://api.github.com/users/hyperfekt/followers",
      "following_url": "https://api.github.com/users/hyperfekt/following{/other_user}",
      "gists_url": "https://api.github.com/users/hyperfekt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/hyperfekt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/hyperfekt/subscriptions",
      "organizations_url": "https://api.github.com/users/hyperfekt/orgs",
      "repos_url": "https://api.github.com/users/hyperfekt/repos",
      "events_url": "https://api.github.com/users/hyperfekt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/hyperfekt/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-01-27T12:25:48Z",
    "updated_at": "2018-01-27T12:25:48Z",
    "author_association": "NONE",
    "body": "@eordano What makes you propose an empty interface? I might be confused what you mean by this - shouldn't every registry announcing ERC821 support offer the full interface?\r\n\r\nOne thing that I'm a bit concerned with is the balanceOf alias - this could lead users who are not aware of the non-fungible nature to accidentally transfer random NFTs with id <= assetCount instead of that number of tokens, could it not?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/360981489/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/360984058",
    "html_url": "https://github.com/ethereum/EIPs/issues/821#issuecomment-360984058",
    "issue_url": "https://api.github.com/repos/ethereum/EIPs/issues/821",
    "id": 360984058,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM2MDk4NDA1OA==",
    "user": {
      "login": "hyperfekt",
      "id": 9434715,
      "node_id": "MDQ6VXNlcjk0MzQ3MTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/9434715?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/hyperfekt",
      "html_url": "https://github.com/hyperfekt",
      "followers_url": "https://api.github.com/users/hyperfekt/followers",
      "following_url": "https://api.github.com/users/hyperfekt/following{/other_user}",
      "gists_url": "https://api.github.com/users/hyperfekt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/hyperfekt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/hyperfekt/subscriptions",
      "organizations_url": "https://api.github.com/users/hyperfekt/orgs",
      "repos_url": "https://api.github.com/users/hyperfekt/repos",
      "events_url": "https://api.github.com/users/hyperfekt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/hyperfekt/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-01-27T13:12:04Z",
    "updated_at": "2018-01-27T14:17:28Z",
    "author_association": "NONE",
    "body": "Also I fear that allowing to detect support via a method seriously hampers upgradeability in the spirit of ERC #820, where an old NFT registry can have the new methods added.\r\nThis of course only works if it's default or required to only use the ERC821 methods with the implementer ERC820 returns (maybe this condition should be part of ERC820?).\r\nPlease tell me if I've misunderstood how ERC820 upgradeability is supposed to work. /cc @jbaylina",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/EIPs/issues/comments/360984058/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
