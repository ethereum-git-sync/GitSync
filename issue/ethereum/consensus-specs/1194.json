{
  "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1194",
  "repository_url": "https://api.github.com/repos/ethereum/consensus-specs",
  "labels_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1194/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1194/comments",
  "events_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1194/events",
  "html_url": "https://github.com/ethereum/consensus-specs/issues/1194",
  "id": 457758725,
  "node_id": "MDU6SXNzdWU0NTc3NTg3MjU=",
  "number": 1194,
  "title": "Inefficiencies in data availability proofs",
  "user": {
    "login": "vbuterin",
    "id": 2230894,
    "node_id": "MDQ6VXNlcjIyMzA4OTQ=",
    "avatar_url": "https://avatars.githubusercontent.com/u/2230894?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/vbuterin",
    "html_url": "https://github.com/vbuterin",
    "followers_url": "https://api.github.com/users/vbuterin/followers",
    "following_url": "https://api.github.com/users/vbuterin/following{/other_user}",
    "gists_url": "https://api.github.com/users/vbuterin/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/vbuterin/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/vbuterin/subscriptions",
    "organizations_url": "https://api.github.com/users/vbuterin/orgs",
    "repos_url": "https://api.github.com/users/vbuterin/repos",
    "events_url": "https://api.github.com/users/vbuterin/events{/privacy}",
    "received_events_url": "https://api.github.com/users/vbuterin/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 1170173759,
      "node_id": "MDU6TGFiZWwxMTcwMTczNzU5",
      "url": "https://api.github.com/repos/ethereum/consensus-specs/labels/phase1",
      "name": "phase1",
      "color": "F7C242",
      "default": false,
      "description": ""
    },
    {
      "id": 1252242617,
      "node_id": "MDU6TGFiZWwxMjUyMjQyNjE3",
      "url": "https://api.github.com/repos/ethereum/consensus-specs/labels/phase2",
      "name": "phase2",
      "color": "90B44B",
      "default": false,
      "description": ""
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 5,
  "created_at": "2019-06-19T01:01:23Z",
  "updated_at": "2020-04-29T06:43:03Z",
  "closed_at": "2020-04-29T06:43:03Z",
  "author_association": "MEMBER",
  "active_lock_reason": null,
  "body": "There are three major sources of inefficiency in the current construction for data availability proofs:\r\n\r\n1. The structure demands a `2^k * 2^k` square, so data needs to be padded to the next power of 4. This may on average double the amount of data that needs to be erasure-coded and stored by the network.\r\n2. Due to EIP 1559 implementation, on average a block will be ~half full, requiring further zero-padding within the space allocated for each block.\r\n3. The space allocated for each block is 2x the size of the block data itself; the remaining half is allocated for the block header and witnesses for state reads.\r\n\r\nPossible ideas to improve efficiency:\r\n\r\n1. Adjust EIP 1559 so that blocks are on average eg. 80% full. This will however nullify a large part of the benefit of EIP 1559, as blocks will much more frequently be full and so the first price auction mode will more frequently dominate.\r\n2. Adjust the crosslink structure so that while there is a static _per-epoch_ limit, individual blocks can take up different amounts of space. Allows EIP 1559 to keep functioning as long as the gasprice does not need more than ~half an epoch to adjust.\r\n3. Adjust the crosslink structure so that it stores the concatenation of all block structures in SSZ format as dynamic-sized lists (so any extra zero bytes are not included, positions of individual blocks are variable, and the indices of each block appear at the left end of the tree structure). The main disadvantage is the need to do two Merkle tree accesses instead of one to access a shard block.\r\n4. Be liberal with the witnesses for state reads allowed in the block (eg. allow an unlimited number of \"top-level transactions\") so more of the non-block-data space is used.\r\n5. Somehow modify the erasure coding mechanism to be able to process large contiguous zero bytes trivially or at least more efficiently. This is ideal if possible, but not sure how to actually do this.\r\n6. Remove the `2^k * 2^k` requirement and replace it with an arbitary `n * n` (not sure this is actually an efficiency improvement; FFTs are easiest to use when handling exact powers of two)\r\n7. Allow `2^k * 2^(k-1)` rectangles.\r\n\r\nThis is still in \"think mode\"; better ideas may come up. So far (3) seems least bad, plus possibly (7). The issues are far from fatal, but hopefully there are easy ways to remove at least some of the current theoretical ~8x inefficiency.",
  "closed_by": {
    "login": "JustinDrake",
    "id": 731743,
    "node_id": "MDQ6VXNlcjczMTc0Mw==",
    "avatar_url": "https://avatars.githubusercontent.com/u/731743?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/JustinDrake",
    "html_url": "https://github.com/JustinDrake",
    "followers_url": "https://api.github.com/users/JustinDrake/followers",
    "following_url": "https://api.github.com/users/JustinDrake/following{/other_user}",
    "gists_url": "https://api.github.com/users/JustinDrake/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/JustinDrake/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/JustinDrake/subscriptions",
    "organizations_url": "https://api.github.com/users/JustinDrake/orgs",
    "repos_url": "https://api.github.com/users/JustinDrake/repos",
    "events_url": "https://api.github.com/users/JustinDrake/events{/privacy}",
    "received_events_url": "https://api.github.com/users/JustinDrake/received_events",
    "type": "User",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1194/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1194/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/503764339",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1194#issuecomment-503764339",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1194",
    "id": 503764339,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUwMzc2NDMzOQ==",
    "user": {
      "login": "dankrad",
      "id": 6130607,
      "node_id": "MDQ6VXNlcjYxMzA2MDc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6130607?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dankrad",
      "html_url": "https://github.com/dankrad",
      "followers_url": "https://api.github.com/users/dankrad/followers",
      "following_url": "https://api.github.com/users/dankrad/following{/other_user}",
      "gists_url": "https://api.github.com/users/dankrad/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dankrad/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dankrad/subscriptions",
      "organizations_url": "https://api.github.com/users/dankrad/orgs",
      "repos_url": "https://api.github.com/users/dankrad/repos",
      "events_url": "https://api.github.com/users/dankrad/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dankrad/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-06-19T22:06:24Z",
    "updated_at": "2019-06-19T22:06:24Z",
    "author_association": "MEMBER",
    "body": "Very interesting problem. I would love to think about these. How final are these ideas? Could there be other schemes out there and would we be willing to consider them at this point?\r\n\r\nOne question about https://arxiv.org/pdf/1809.09044.pdf (is this a good reference?), section 7.1: I am currently thinking about polynomial and functional commitment schemes. Is it possible that such a scheme could be used, rather than a full zk-SNARK (which is currently prohibitively expensive)?\r\n\r\nI am currently looking at some polynomial commitment schemes that could potentially replace the proof of custody with a non-interactive version. They aren't quite ready for prime time yet (still some problems with efficiency and outsourcability), but I'm planning to post my thoughts to get some more outside thoughts about it.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/503764339/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/504019848",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1194#issuecomment-504019848",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1194",
    "id": 504019848,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUwNDAxOTg0OA==",
    "user": {
      "login": "vbuterin",
      "id": 2230894,
      "node_id": "MDQ6VXNlcjIyMzA4OTQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2230894?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vbuterin",
      "html_url": "https://github.com/vbuterin",
      "followers_url": "https://api.github.com/users/vbuterin/followers",
      "following_url": "https://api.github.com/users/vbuterin/following{/other_user}",
      "gists_url": "https://api.github.com/users/vbuterin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vbuterin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vbuterin/subscriptions",
      "organizations_url": "https://api.github.com/users/vbuterin/orgs",
      "repos_url": "https://api.github.com/users/vbuterin/repos",
      "events_url": "https://api.github.com/users/vbuterin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vbuterin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-06-20T13:10:50Z",
    "updated_at": "2019-06-20T13:10:50Z",
    "author_association": "MEMBER",
    "body": "In terms of how much is final and how much can be changed, I'd say there's good arguments for the use of erasure coding and commitment to erasure coded data in some form being optimal:\r\n\r\n* In a sharded system there's less replication of each piece of data and hence more reason to pay attention to making sure to maximize the chance of survival of each piece of data. Erasure coding strictly outperforms simple replication as a way of doing this for any specific redundancy factor.\r\n* If erasure-coded extension of block data is done anyway, then the marginal cost to commit to it and let people make data availability queries is low.\r\n\r\nAs far as choice of scheme goes, I think biggest pragmatic reason to stick to hash-based things in this case, aside from simplicity of implementation, future-proofness and all the other usual reasons, is that erasure codes and Merkle trees are really fast to generate (eg. I can do it within an epoch for 512 MB of data in python) but I don't see any more complicated scheme having the same property (as precedent, think of how the proving time for STARKs is 10x faster than for SNARKs). Additionally purely hash-based schemes can work over binary fields and one reason binary fields are especially nice is that they can represent 32-byte chunks with no overhead, whereas any finite field runs the risk that even if a block is entirely composed of values `< 2**256`, the extended chunks will not be (the same goes for any byte size less than 32).\r\n\r\nThough it does seem to me like polynomial commitment schemes are a superior alternative to SNARKs over Merkle trees; they're more \"direct\", rather than one construction wrapping over a completely foreign one and hence incurring arithmetization inefficiencies. And the assumptions in polynomial commitment schemes are definitely milder than the assumptions in SNARKs.\r\n\r\nBlock layout in commitment data is still very flexible, and my intuition is that whatever efficiencies remain would remain the same regardless of the scheme used.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/504019848/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/504720270",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1194#issuecomment-504720270",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1194",
    "id": 504720270,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUwNDcyMDI3MA==",
    "user": {
      "login": "vbuterin",
      "id": 2230894,
      "node_id": "MDQ6VXNlcjIyMzA4OTQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2230894?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vbuterin",
      "html_url": "https://github.com/vbuterin",
      "followers_url": "https://api.github.com/users/vbuterin/followers",
      "following_url": "https://api.github.com/users/vbuterin/following{/other_user}",
      "gists_url": "https://api.github.com/users/vbuterin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vbuterin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vbuterin/subscriptions",
      "organizations_url": "https://api.github.com/users/vbuterin/orgs",
      "repos_url": "https://api.github.com/users/vbuterin/repos",
      "events_url": "https://api.github.com/users/vbuterin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vbuterin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-06-23T05:02:57Z",
    "updated_at": "2019-06-23T05:02:57Z",
    "author_association": "MEMBER",
    "body": "Idea from a conversation with Justin yesterday: if there are large segments of contiguous zero bytes, fill them with any of:\r\n\r\n* Portions of beacon chain state\r\n* Portions of shard state\r\n* Recent blocks *of other shards* (to incentivize more availability of that data)\r\n\r\nAll of these objects are larger than 64kb, so we can either randomly choose indices from where to include data each time, or store indices and try to cycle through the data.\r\n\r\nI actually like this. There's definitely something unclean about \"grab as many bytes of this thing as possible\", but it allows us to preserve the existing (quite clean!) structure of the crosslink data.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/504720270/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/617153307",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1194#issuecomment-617153307",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1194",
    "id": 617153307,
    "node_id": "MDEyOklzc3VlQ29tbWVudDYxNzE1MzMwNw==",
    "user": {
      "login": "JustinDrake",
      "id": 731743,
      "node_id": "MDQ6VXNlcjczMTc0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/731743?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JustinDrake",
      "html_url": "https://github.com/JustinDrake",
      "followers_url": "https://api.github.com/users/JustinDrake/followers",
      "following_url": "https://api.github.com/users/JustinDrake/following{/other_user}",
      "gists_url": "https://api.github.com/users/JustinDrake/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JustinDrake/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JustinDrake/subscriptions",
      "organizations_url": "https://api.github.com/users/JustinDrake/orgs",
      "repos_url": "https://api.github.com/users/JustinDrake/repos",
      "events_url": "https://api.github.com/users/JustinDrake/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JustinDrake/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-04-21T12:38:45Z",
    "updated_at": "2020-04-29T06:42:55Z",
    "author_association": "MEMBER",
    "body": "@vbuterin @dankrad Can we close this issue for staleness? (Trying to address old Github issues, and data availability research has progressed significantly since June 2019.)",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/617153307/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/620851234",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1194#issuecomment-620851234",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1194",
    "id": 620851234,
    "node_id": "MDEyOklzc3VlQ29tbWVudDYyMDg1MTIzNA==",
    "user": {
      "login": "dankrad",
      "id": 6130607,
      "node_id": "MDQ6VXNlcjYxMzA2MDc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6130607?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dankrad",
      "html_url": "https://github.com/dankrad",
      "followers_url": "https://api.github.com/users/dankrad/followers",
      "following_url": "https://api.github.com/users/dankrad/following{/other_user}",
      "gists_url": "https://api.github.com/users/dankrad/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dankrad/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dankrad/subscriptions",
      "organizations_url": "https://api.github.com/users/dankrad/orgs",
      "repos_url": "https://api.github.com/users/dankrad/repos",
      "events_url": "https://api.github.com/users/dankrad/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dankrad/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-04-28T20:58:25Z",
    "updated_at": "2020-04-28T20:58:25Z",
    "author_association": "MEMBER",
    "body": "I'd say it can be closed. I would say the data availability proof now will\nmostly follow from whatever we use for shard data commitments.\n\nOn Tue, 21 Apr 2020 at 13:38, Justin <notifications@github.com> wrote:\n\n> @vbuterin <https://github.com/vbuterin> @dankrad\n> <https://github.com/dankrad> Can we close this issue for staleness?\n> (Trying to address old Github issue, and data availability research has\n> progressed significantly since June 2019.)\n>\n> â€”\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/ethereum/eth2.0-specs/issues/1194#issuecomment-617153307>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/ABOYXL56QI2SPZCOFUN74K3RNWHWHANCNFSM4HZE7KNQ>\n> .\n>\n\n\n-- \n\n*Dr. Dankrad Feist*Researcher at Ethereum Foundation\n\ndankrad@ethereum.org\n+44 750 3267828\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/620851234/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
