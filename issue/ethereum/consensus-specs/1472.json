{
  "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1472",
  "repository_url": "https://api.github.com/repos/ethereum/consensus-specs",
  "labels_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1472/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1472/comments",
  "events_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1472/events",
  "html_url": "https://github.com/ethereum/consensus-specs/issues/1472",
  "id": 520054460,
  "node_id": "MDU6SXNzdWU1MjAwNTQ0NjA=",
  "number": 1472,
  "title": "Sparse Merkle Trees (SMTs) designs",
  "user": {
    "login": "protolambda",
    "id": 19571989,
    "node_id": "MDQ6VXNlcjE5NTcxOTg5",
    "avatar_url": "https://avatars.githubusercontent.com/u/19571989?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/protolambda",
    "html_url": "https://github.com/protolambda",
    "followers_url": "https://api.github.com/users/protolambda/followers",
    "following_url": "https://api.github.com/users/protolambda/following{/other_user}",
    "gists_url": "https://api.github.com/users/protolambda/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/protolambda/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/protolambda/subscriptions",
    "organizations_url": "https://api.github.com/users/protolambda/orgs",
    "repos_url": "https://api.github.com/users/protolambda/repos",
    "events_url": "https://api.github.com/users/protolambda/events{/privacy}",
    "received_events_url": "https://api.github.com/users/protolambda/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 1137720193,
      "node_id": "MDU6TGFiZWwxMTM3NzIwMTkz",
      "url": "https://api.github.com/repos/ethereum/consensus-specs/labels/general:discussion",
      "name": "general:discussion",
      "color": "F17C67",
      "default": false,
      "description": ""
    },
    {
      "id": 1170174610,
      "node_id": "MDU6TGFiZWwxMTcwMTc0NjEw",
      "url": "https://api.github.com/repos/ethereum/consensus-specs/labels/scope:SSZ",
      "name": "scope:SSZ",
      "color": "77428D",
      "default": false,
      "description": "Simple Serialize"
    }
  ],
  "state": "open",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 17,
  "created_at": "2019-11-08T14:46:47Z",
  "updated_at": "2020-05-17T15:39:09Z",
  "closed_at": null,
  "author_association": "MEMBER",
  "active_lock_reason": null,
  "body": "SSZ for general purpose merkleization is lacking a few types, of which sparse merkle trees are probably the most different from what is already there.\r\n\r\nIt only passed by a few times in the specs:\r\n- lists merkleization discussion [`1115`](https://github.com/ethereum/eth2.0-specs/issues/1115)\r\n- multi-proof queries [`644`](https://github.com/ethereum/eth2.0-specs/issues/644)\r\n- lists/vectors, and the desire for a future sparse vector variant [`1160`](https://github.com/ethereum/eth2.0-specs/issues/1160)\r\n\r\nHowever I do think it is necessary to have if SSZ is to be adopted more widely than the current spec state machines.\r\n\r\n## Options\r\n\r\nThere is not one way to implement this, we have many options:\r\n\r\n- With breaking changes:\r\n    - Back to specialized trees like Merkle Patricia Trees, at the cost of complexity and hard to optimize structures/merkleization\r\n    - Hack in extension nodes in the otherwise binary tree\r\n    - Change of hash function for efficient merges with zeroes, but have to maintain some information in the hash, a byte or two: https://ethresear.ch/t/a-nearly-trivial-on-zero-inputs-32-bytes-long-collision-resistant-hash-function/5511\r\n- No breaking changes, but full hashing (large proof size problem, slow on-chain):\r\n    - Compress proof data, but do the full-depth hashes: https://ethresear.ch/t/optimizing-sparse-merkle-trees/3751/12\r\n    - Plasma cash SMTs, bitfield to refer where zero hashes are: https://ethresear.ch/t/plasma-cash-with-sparse-merkle-trees-bloom-filters-and-probabilistic-transfers/2006\r\n- Merkleize based on prefix difference (with vector commitment problem):\r\n    - Preserve position by hashing in the key into each leaf (\"Compressed merkle proofs\"): https://github.com/aergoio/aergo/tree/master/pkg/trie\r\n        - Similarities with the \"1 hash extra\" case I described in the list discussion: harden leaf nodes to then put them anywhere easily.\r\n        - Also called Compact Merkle Trees, with \"split index\" for point of divergence, assuming unique leaf nodes, no precise vector commitment. https://ethresear.ch/t/compact-sparse-merkle-trees/3741/16\r\n        - \"Binary Indexed Tree\": like above, but with max distance between nodes to navigate: https://github.com/ChosunOne/merkle_bit\r\n    - Purposefully forget about positions in favor of fast sparse set merkleization, the \"Merklix\" (Merkle + radix) tree: https://www.deadalnix.me/2016/09/24/introducing-merklix-tree-as-an-unordered-merkle-tree-on-steroid/\r\n    - Libra sparse compact merkle tree: make leaf nodes different by typing them\r\n        - \"jellyfish merkle\" implementation: https://github.com/libra/libra/tree/master/storage/jellyfish-merkle\r\n        - https://developers.libra.org/docs/assets/papers/the-libra-blockchain.pdf\r\n            - \"Secure Merkle trees must use different hash functions to hash the leaves and internal nodes to avoid confusion between the two types of nodes.\"\r\n    - New idea (or thought experiment, not efficient, but new possibilities): Compact merkle tree with special mixin at root, see below. *Separating the vector commitment from the contents commitment, while preserving some other properties with affinity for SSZ in the contents commitment*.\r\n\r\n- More suggestions welcome, it is hard to aggregate it all.\r\n\r\n## Opinion\r\n\r\nPersonally I dislike breaking changes here, and feel like those solutions are too specialized, hard to optimize or simply too incompatible with other parts of the spec.\r\n\r\nThe full hashing is also something I like to avoid, 256 hashes is computationally unacceptable, even with proof encoding compression (something proof backings should be optimizing, not sparse merkle trees).\r\n",
  "closed_by": null,
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1472/reactions",
    "total_count": 9,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 9
  },
  "timeline_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1472/timeline",
  "performed_via_github_app": null,
  "state_reason": null
}
[
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/551856078",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1472#issuecomment-551856078",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1472",
    "id": 551856078,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU1MTg1NjA3OA==",
    "user": {
      "login": "protolambda",
      "id": 19571989,
      "node_id": "MDQ6VXNlcjE5NTcxOTg5",
      "avatar_url": "https://avatars.githubusercontent.com/u/19571989?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/protolambda",
      "html_url": "https://github.com/protolambda",
      "followers_url": "https://api.github.com/users/protolambda/followers",
      "following_url": "https://api.github.com/users/protolambda/following{/other_user}",
      "gists_url": "https://api.github.com/users/protolambda/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/protolambda/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/protolambda/subscriptions",
      "organizations_url": "https://api.github.com/users/protolambda/orgs",
      "repos_url": "https://api.github.com/users/protolambda/repos",
      "events_url": "https://api.github.com/users/protolambda/events{/privacy}",
      "received_events_url": "https://api.github.com/users/protolambda/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-11-08T14:48:13Z",
    "updated_at": "2019-11-08T14:48:13Z",
    "author_association": "MEMBER",
    "body": "By all means, do tear the new idea apart, there are many options and discussion is welcome.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/551856078/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/552105267",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1472#issuecomment-552105267",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1472",
    "id": 552105267,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU1MjEwNTI2Nw==",
    "user": {
      "login": "protolambda",
      "id": 19571989,
      "node_id": "MDQ6VXNlcjE5NTcxOTg5",
      "avatar_url": "https://avatars.githubusercontent.com/u/19571989?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/protolambda",
      "html_url": "https://github.com/protolambda",
      "followers_url": "https://api.github.com/users/protolambda/followers",
      "following_url": "https://api.github.com/users/protolambda/following{/other_user}",
      "gists_url": "https://api.github.com/users/protolambda/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/protolambda/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/protolambda/subscriptions",
      "organizations_url": "https://api.github.com/users/protolambda/orgs",
      "repos_url": "https://api.github.com/users/protolambda/repos",
      "events_url": "https://api.github.com/users/protolambda/events{/privacy}",
      "received_events_url": "https://api.github.com/users/protolambda/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-11-09T14:26:29Z",
    "updated_at": "2019-11-09T17:59:45Z",
    "author_association": "MEMBER",
    "body": "Another possible variant of the compact sparse merkle trees, to make it work somewhat with generalized indices, and define two missing sparse data structures:\r\n\r\nWe define a `MerkleSet[T]`, `MerkleMap[K, V]` and *generalized index annotations*.\r\n\r\n`MerkleSet[T]`: Take the hash-tree-root of each element, this will be the identity in the set.\r\nThe set is merkleized as a compact tree, with each element in the position determined by its hash-tree-root, but each element is wrapped with a right-hand zero to mark it as a leaf element. `H(obj_T, 0x000...)`\r\n\r\n`MerkleMap[K, V]`: As a `MerkleSet[T]`, where each element is positioned by just the hash-tree-root of `K`, but is merkleized as `H(H(V, K), 0x000...)` (incl the right-hand-zeroes as leaf marker).\r\n\r\nNow, to access a set or map value with a stable generalized index we need the generalized index to know where to stop and look for a `0x000...` right hand in the tree.\r\n\r\nA generalized index could be like:\r\n```\r\n1aaaa...aaaabbbb...bbbbcccc...cccc\r\naaaa...aaaa: some regular generalized index path, anything, leading to the root of the set or map.\r\nbbbb...bbbb: 32 bytes key embedded. (set value hash-tree-root, or map key hash-tree-root)\r\ncccc...cccc: path within the value\r\n```\r\n\r\nAnd then add an annotation like \"at bit index `i` a 32 byte key can be found, follow this path like normal, but stop and skip to the end of the 32 byte key once a right-hand zeroed node is encountered. Check if the key matches the HTR of the left-hand\".\r\nAnd to work with for the `MerkleMap` encoding, define a second type of annotation, exactly like the first, but with a different key check: \"the 32 byte key must match the next right child node\" (i.e. in the pair left from the zeroes).\r\n\r\nSuch annotation could be just an index, maybe 2 bytes with the first bit reserved to describe the map case (2**15 = 32768 max merkle depth). \r\n\r\nAnd one modification could be made to consider the hash with zeroes (`H(e, 0x000...)`) as the identity, instead of the element itself. Making the content keys uniform.\r\nThe pro of not doing this would be that keys can be chosen (and made uniform manually with a hash if necessary), and more readable in the generalized index.\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/552105267/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/552631254",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1472#issuecomment-552631254",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1472",
    "id": 552631254,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU1MjYzMTI1NA==",
    "user": {
      "login": "protolambda",
      "id": 19571989,
      "node_id": "MDQ6VXNlcjE5NTcxOTg5",
      "avatar_url": "https://avatars.githubusercontent.com/u/19571989?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/protolambda",
      "html_url": "https://github.com/protolambda",
      "followers_url": "https://api.github.com/users/protolambda/followers",
      "following_url": "https://api.github.com/users/protolambda/following{/other_user}",
      "gists_url": "https://api.github.com/users/protolambda/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/protolambda/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/protolambda/subscriptions",
      "organizations_url": "https://api.github.com/users/protolambda/orgs",
      "repos_url": "https://api.github.com/users/protolambda/repos",
      "events_url": "https://api.github.com/users/protolambda/events{/privacy}",
      "received_events_url": "https://api.github.com/users/protolambda/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-11-11T21:47:09Z",
    "updated_at": "2019-11-11T21:47:09Z",
    "author_association": "MEMBER",
    "body": "As I am implementing a merkle-tree backing and typed views/partials in Go I'm starting to be a fan of single-node mixins. I.e. A mix-in like the list length is not opt-out: it's always part of a proof about the data. You are forced into the right direction, enabled to check in every case, and deal with less edge cases.\r\n\r\nSimilarly the zeroes as stopper for the sparse tree work well, they are always part of the proof data.\r\nMaybe the flexibility and super-compatibility (with regular ssz merkle trees) offered by the content-vector commitment separation is still worth it, but it will be much more difficult to enforce to use it properly.\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/552631254/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/553161926",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1472#issuecomment-553161926",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1472",
    "id": 553161926,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU1MzE2MTkyNg==",
    "user": {
      "login": "protolambda",
      "id": 19571989,
      "node_id": "MDQ6VXNlcjE5NTcxOTg5",
      "avatar_url": "https://avatars.githubusercontent.com/u/19571989?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/protolambda",
      "html_url": "https://github.com/protolambda",
      "followers_url": "https://api.github.com/users/protolambda/followers",
      "following_url": "https://api.github.com/users/protolambda/following{/other_user}",
      "gists_url": "https://api.github.com/users/protolambda/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/protolambda/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/protolambda/subscriptions",
      "organizations_url": "https://api.github.com/users/protolambda/orgs",
      "repos_url": "https://api.github.com/users/protolambda/repos",
      "events_url": "https://api.github.com/users/protolambda/events{/privacy}",
      "received_events_url": "https://api.github.com/users/protolambda/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-11-12T23:16:16Z",
    "updated_at": "2019-11-12T23:16:16Z",
    "author_association": "MEMBER",
    "body": "Edited this out of the main-post. It is a complementary idea to the compact trees that has some efficiency problems (2x proof size of individual leaf), but offers some fun new possibilities. Think of it as a thought-experiment to complete the picture of the different compact merkle trees.\r\n\r\n----\r\n\r\nThe idea of compact sparse merkle trees has been re-hashed (no pun intended ðŸ¤”) by many authors, but I think gets close to fitting our needs. (ignoring stable merkle depth for a moment here). Let's just explore another variant.\r\n\r\n### Compact tree affinity\r\n\r\nOne thing that is particularly striking is that prefixes just fit well with binary trees and our generalized indices:\r\n- `1`, `100`, `1000000`, etc are all exclusive: cannot represent them as leafs in the same sparse compact tree (unless you define splits over depth differences too). Aligning it to the left is no problem. E.g. `1000000000 ... 0000` can be a key.\r\n- Always starts with a `1`, we can special case something that starts with a `0` when we merkleize this type of info.\r\n- If we do not mess the with leaf nodes, *every current SSZ merkle structure* is a valid sparse merkle tree!\r\n    - vector commitment issue: positions are ignored by the sparse merkle tree. But the SSZ structures embedded here would have a static shape anyway.\r\n\r\n### Vector commitment mixin\r\n\r\nNow take a look at SSZ lists:\r\n- Positional information is mixed in *at the root*, not per leaf. It's just that lists are not very complex, but it could be anything. And it is convenient for proofs to have this basic vector commitment: \"elements 0...N are here\"\r\n- Only when the vector commitment changes, the mix-in changes.\r\n\r\nNow this new idea is to do the same for sparse trees: **separate the vector commitment, and call it the \"sparse tree mixin\".**\r\n\r\nAnd this vector commitment can be a compact sparse tree of keys, optimized exactly the same way.\r\n\r\nAnd since the vector commitment may not change as much (well, in some cases it does, in others never at all), an extra hash for an update there wouldn't be as bad.\r\nSo in the vector commitment, we take the \"1 extra hash\" to separate leafs (the actual keys) from hashes. And this hash can be `000...0000` as positions all start with 1 and can't collide with the zeroes. Nor should a random hash.\r\n\r\nAlso note that the *contents* part would back the `values` and the *vector* part would back the `keys` of the data-structure. And *membership* commitment depends on what you are after: content inclusion can be proven with just the `values` part, identity inclusion can be proven with just the `keys` part.\r\n\r\nAnd now that the vector commitment can be summarized into 32 bytes, and the contents commitment part is compatible with regular SSZ trees, we can have really interesting type-less but safe tree interactions:\r\nE.g. a `BeaconState` can be explored as a sparse tree, by just mixing in (to the regular `BeaconState` root) a constant magic 32 bytes derived from its type definition to convert a regular root into that of a valid sparse tree.\r\n\r\nAnother special property is that moving a value by just a little (slight key alternation) may only change the keys commitment part.\r\n\r\n### Compactness vs Stable depth\r\n\r\nThe remaining problem here is that compactness on a sparse structure cannot be achieved without breaking the stable depth. A generalized index to an actual sparse tree leaf cannot be derived without knowing about the contents of the tree. On the bright side, the separation of the vector commitment makes this easy to learn and communicate.\r\n\r\nThe compactness gets us `O(log(N))` node depth for `N` nodes with uniformly distributed tree keys.\r\nThis compactness applies to both the values as the keys part of the tree.\r\nAnd the compactness still puts adjacent keys close together efficiently, if a sparse tree is used for non-uniform data it is perfectly fine. (bit bigger proof size, but not much more than a regular `List` would do, and fast computation)\r\n\r\n### Drawbacks\r\n\r\n**size**: If the only use case is to both proof the key and value at the same time, and the tree changes a lot, it would be ~2x more data (separate key and value proofs) compared to regular compact trees that harden the leaf nodes with a position. The total amount of nodes may be comparable still, but the 2x is especially noticeable when proofing \r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/553161926/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/553225248",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1472#issuecomment-553225248",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1472",
    "id": 553225248,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU1MzIyNTI0OA==",
    "user": {
      "login": "vbuterin",
      "id": 2230894,
      "node_id": "MDQ6VXNlcjIyMzA4OTQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2230894?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vbuterin",
      "html_url": "https://github.com/vbuterin",
      "followers_url": "https://api.github.com/users/vbuterin/followers",
      "following_url": "https://api.github.com/users/vbuterin/following{/other_user}",
      "gists_url": "https://api.github.com/users/vbuterin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vbuterin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vbuterin/subscriptions",
      "organizations_url": "https://api.github.com/users/vbuterin/orgs",
      "repos_url": "https://api.github.com/users/vbuterin/repos",
      "events_url": "https://api.github.com/users/vbuterin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vbuterin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-11-13T03:42:30Z",
    "updated_at": "2019-11-13T03:50:03Z",
    "author_association": "MEMBER",
    "body": "Out of all the options I think I like leaf-level mixins the most (so to store `v` at position `k`, store `H(k, v)`). The main challenge (really, with any of these schemes except my modified hash function proposal) is that generalized indices would not work because the path for any given object would be dynamic. I would suggest we just bite the bullet and in objects that contain sets/dicts we just require a path to consist of a generalized index (that pretends every key is the full 256 bits) along with a second object that is a list of pairs (depth of dict root, depth of leaf relative to root). Note that this list would need to be dynamically generated and passed along with each proof.\r\n\r\nFrom this list of pairs, you can translate the generalized index into a \"modified generalized index\" (basically, the bit positions corresponding to levels that were elided in the tree get snipped out of the generalized index), and generate a list of mixin checks (\"check that the value at generalized index x is y\").\r\n\r\nSomething like:\r\n\r\n```python\r\ndef transform_generalized_index(gindex: Bitlist, positions: Sequence[Tuple[int,int]]) -> Bitlist:\r\n    o = []\r\n    my_pos = 0\r\n    for pos, length in positions:\r\n        assert pos >= my_pos\r\n        # my_pos:pos is everything in between the dicts, pos:pos+branch is the branch within the dict itself\r\n        o.extend(gindex[my_pos:pos + length])\r\n        # Keys have length 32, plus one bit for the mixin\r\n        my_pos = pos + 33\r\n        # Mixin is the left child of the leaf node, value is the right child\r\n        o.append(1)\r\n    return o\r\n```\r\n\r\nThe function could also be augmented to return a list of generalized indices at the leaf of each dict along the path, along with the key; this would be fed into a Merkle branch or multiproof checker so it can verify that the key provided in the mixin equals to the expected key.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/553225248/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/553418612",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1472#issuecomment-553418612",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1472",
    "id": 553418612,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU1MzQxODYxMg==",
    "user": {
      "login": "protolambda",
      "id": 19571989,
      "node_id": "MDQ6VXNlcjE5NTcxOTg5",
      "avatar_url": "https://avatars.githubusercontent.com/u/19571989?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/protolambda",
      "html_url": "https://github.com/protolambda",
      "followers_url": "https://api.github.com/users/protolambda/followers",
      "following_url": "https://api.github.com/users/protolambda/following{/other_user}",
      "gists_url": "https://api.github.com/users/protolambda/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/protolambda/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/protolambda/subscriptions",
      "organizations_url": "https://api.github.com/users/protolambda/orgs",
      "repos_url": "https://api.github.com/users/protolambda/repos",
      "events_url": "https://api.github.com/users/protolambda/events{/privacy}",
      "received_events_url": "https://api.github.com/users/protolambda/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-11-13T14:06:39Z",
    "updated_at": "2019-11-13T14:06:39Z",
    "author_association": "MEMBER",
    "body": "Instead of transforming the generalized indices, and then still having to pass the information to check the keys, we could also mark the \"anchor points\" with generalized indices:\r\nSay, for some type there is a SMT with its root anchored at `0b10010011`, then it would be sufficient to pass that to the multiproof checker. The checker can check if it is in this subtree, and if so, check that the 32 bytes after this prefix in the gindex of a SMT leaf match the key part of the SMT leaf. (Assuming we standardize on 32 byte keys, and hash-tree-root if the actual key is bigger).\r\nAnd this data would be the same for every entry in the sparse merkle tree: no need to duplicate it for each leaf in that subtree under the SMT anchor. And if regular SMTs are not nested very deep into the type of the proof as whole, this SMT anchor gindex only costs a few bytes. Negligible compared to the size of a single leaf node.\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/553418612/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/553965817",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1472#issuecomment-553965817",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1472",
    "id": 553965817,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU1Mzk2NTgxNw==",
    "user": {
      "login": "Tolsi",
      "id": 1512650,
      "node_id": "MDQ6VXNlcjE1MTI2NTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1512650?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Tolsi",
      "html_url": "https://github.com/Tolsi",
      "followers_url": "https://api.github.com/users/Tolsi/followers",
      "following_url": "https://api.github.com/users/Tolsi/following{/other_user}",
      "gists_url": "https://api.github.com/users/Tolsi/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Tolsi/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Tolsi/subscriptions",
      "organizations_url": "https://api.github.com/users/Tolsi/orgs",
      "repos_url": "https://api.github.com/users/Tolsi/repos",
      "events_url": "https://api.github.com/users/Tolsi/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Tolsi/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-11-14T16:26:56Z",
    "updated_at": "2019-11-14T16:26:56Z",
    "author_association": "NONE",
    "body": "What do you think about [AVL+ trees](https://eprint.iacr.org/2016/994.pdf)?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/553965817/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/554637521",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1472#issuecomment-554637521",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1472",
    "id": 554637521,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU1NDYzNzUyMQ==",
    "user": {
      "login": "protolambda",
      "id": 19571989,
      "node_id": "MDQ6VXNlcjE5NTcxOTg5",
      "avatar_url": "https://avatars.githubusercontent.com/u/19571989?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/protolambda",
      "html_url": "https://github.com/protolambda",
      "followers_url": "https://api.github.com/users/protolambda/followers",
      "following_url": "https://api.github.com/users/protolambda/following{/other_user}",
      "gists_url": "https://api.github.com/users/protolambda/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/protolambda/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/protolambda/subscriptions",
      "organizations_url": "https://api.github.com/users/protolambda/orgs",
      "repos_url": "https://api.github.com/users/protolambda/repos",
      "events_url": "https://api.github.com/users/protolambda/events{/privacy}",
      "received_events_url": "https://api.github.com/users/protolambda/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-11-16T13:29:00Z",
    "updated_at": "2019-11-16T13:29:00Z",
    "author_association": "MEMBER",
    "body": "@Tolsi Here is my view, primarily focused on how compact trees compare. I probably missed a few things, but will do a proper full read when I have more time.\r\n\r\n> Observation  1:   Use  Tree-Balancing  Operations  that  Stay  on  Path\r\n\r\nIf single-node branches are already reduced to just the node itself, and keys are random and uniform, I do not think rebalancing is helpful. It is more like another way to compress a set of leafs into a binary looking tree, just with more edge-cases an optimized merkleization implementation has to deal with. A compact tree of `N` leafs has an avg. leaf depth of `O(log(N)` which is fine. And no re-hashing of anything else than on the branch of a modified leaf.\r\n\r\n> Observation 2:  Do Not Hash Internal Keys\r\n> - we do not add the  keys  of  internal  nodes\r\n> - the verifier does not need to know how  the  leaf  was  found\r\n\r\nThere do not have to be internal keys indeed; if you already key the leafs, the internal nodes just have to reach them indeed, and be able to verify the leaf corresponds to some key. And IMHO it is much better if it is intuitive and simple: walk the path of the key until you find the key. Rather than determine your path based on the entire contents of the tree. All of this may end up in a every-op-counts smartcontract. And although the verifier does not need to know where the leaf was found, being able to quickly locate and read/write a leaf in a proof is important.\r\n\r\n> Observation 3:  Skip Lists are Just a Variant of Treaps\r\n\r\nAnother thing with SSZ is to keep optimized tree descriptions separate from merkleization: new use-cases and algorithms will keep emerging. Merkleization should just be fast, minimal and straightforward. The lookup tricks and tree description can be provided alongside the proof. A \"backing\" is a representation that implements the merkle proof tree traversal needs, and optimizes reads/writes/etc. as it likes. Tree-rotation is something too much (ssz trees are static and predictable, and we hope SMTs can be nearly-statically described), but skip lists etc. can be part of the \"backing\". E.g. you can optimize lookups without moving nodes perfectly fine. See tree-offsets described here: https://github.com/protolambda/eth-merkle-trees\r\n\r\n> Observation 4:  Deterministic is Better.\r\n> However,  since inserted keys may be influenced by the adversary, this method of generating randomness may give an attacker the ability to make the data structure very slow and the proofs very long\r\n\r\nYes, deterministic structures and values are better. A SSZ SMT should hash to the same root regardless of tree constructor or insertion order.\r\n\r\nRegarding determinism in compact trees: I do think choosing keys is not so much of a problem: keys are already hashes of other data (with the exception of basic keys, see below). And because of the compacting property (a branch stops at a single node, no extra depth), the only real attack surface is to insert a large amount of keys, or lots of keys with the same prefix (which is exponentially hard the longer the prefix is, so only effectively adds a few hashes).\r\n\r\nFor `MerkleSet[A]` or `MerkleMap[A, X]` of `A` a basic type or Bytes32, the user can pick a `MerkleMap[K, V]`, where `K = Hash(A)`. Chosen consecutive basic keys are not that bad either: keys are little-endian and so the prefix should differ immediately for regular use of basic keys `0 ... N` has a minimal amount of common prefixes. However, if you try to use e.g. a range of `2**240 ... 2**240 + N` as your keys, then yes, the common prefix is `240` bits long and the proof gets very large. Hash your keys, or avoid such arbitrary range. We can try to optimize out this common prefix, but the user can handle this exceptional case themselves, and I do not like some type of extension-nodes as in Merkle Patricia Trees: breaking otherwise viable optimizations and dealing with them in every single proof is not worth it. I may reconsider this if we get numbers on possible attacks and just the random birthday-like chance of a tree leaf key sharing a long common prefix with another.\r\n\r\n > Observation 5:  AVL Trees Outperform on the Most Relevant Parameters\r\n> the worst-case distance [for leafs when inserting many random keys] for AVL trees is 1.44 times the optimal \r\n\r\nWe should run some numbers on compact trees, but I don't expect this worst case to occur very often with uniform keys.\r\n\r\n> Observation 6:  Proofs for Multiple Operations Can Be Compressed.\r\n\r\nAs with any multi-merkle-proof? Providing just the leaf nodes, and witness data that can't be constructed from lower witness-data and leaves is relatively easy. There is some (naive but readable) pseudo code here: [multiproofs](https://github.com/ethereum/eth2.0-specs/blob/dev/specs/light_client/merkle_proofs.md#merkle-multiproofs). Compression of the actual description of the tree is then a responsibility of the \"backing\", replaceable later.\r\n\r\n>  Implementation and Evaluation\r\n\r\nImpressed by the amount of analysis in the paper, but prefer simplicity and closer affinity with the general binary merkle spec. The `MerkleSet` and `MerkleMap` are just a discussion thing for now, before anything gets standardized proposals, simulations and review will be done. \r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/554637521/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/557344116",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1472#issuecomment-557344116",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1472",
    "id": 557344116,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU1NzM0NDExNg==",
    "user": {
      "login": "vbuterin",
      "id": 2230894,
      "node_id": "MDQ6VXNlcjIyMzA4OTQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2230894?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vbuterin",
      "html_url": "https://github.com/vbuterin",
      "followers_url": "https://api.github.com/users/vbuterin/followers",
      "following_url": "https://api.github.com/users/vbuterin/following{/other_user}",
      "gists_url": "https://api.github.com/users/vbuterin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vbuterin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vbuterin/subscriptions",
      "organizations_url": "https://api.github.com/users/vbuterin/orgs",
      "repos_url": "https://api.github.com/users/vbuterin/repos",
      "events_url": "https://api.github.com/users/vbuterin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vbuterin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-11-22T01:16:26Z",
    "updated_at": "2019-11-22T01:16:26Z",
    "author_association": "MEMBER",
    "body": "> Say, for some type there is a SMT with its root anchored at 0b10010011, then it would be sufficient to pass that to the multiproof checker. The checker can check if it is in this subtree, and if so, check that the 32 bytes after this prefix in the gindex of a SMT leaf match the key part of the SMT leaf. (Assuming we standardize on 32 byte keys, and hash-tree-root if the actual key is bigger).\r\n\r\nAh, I was thinking of the case where the SMT is fully embedded into the SSZ suite, so you could have the SMT be an element of other structures, other structures be an element of the SMT, etc, with possibly multiple SMTs in one path. Yes, if you have a gindex for just an SMT leaf from its own root then that is sufficient.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/557344116/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/557351192",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1472#issuecomment-557351192",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1472",
    "id": 557351192,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU1NzM1MTE5Mg==",
    "user": {
      "login": "protolambda",
      "id": 19571989,
      "node_id": "MDQ6VXNlcjE5NTcxOTg5",
      "avatar_url": "https://avatars.githubusercontent.com/u/19571989?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/protolambda",
      "html_url": "https://github.com/protolambda",
      "followers_url": "https://api.github.com/users/protolambda/followers",
      "following_url": "https://api.github.com/users/protolambda/following{/other_user}",
      "gists_url": "https://api.github.com/users/protolambda/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/protolambda/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/protolambda/subscriptions",
      "organizations_url": "https://api.github.com/users/protolambda/orgs",
      "repos_url": "https://api.github.com/users/protolambda/repos",
      "events_url": "https://api.github.com/users/protolambda/events{/privacy}",
      "received_events_url": "https://api.github.com/users/protolambda/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-11-22T01:49:06Z",
    "updated_at": "2019-11-22T01:49:06Z",
    "author_association": "MEMBER",
    "body": "Right, for each SMT anchor (start of the tree, i.e. the SMT root) in an SSZ structure you would need to declare it's an SMT to get the special traversal behavior. But nothing extra depending on SMT contents. And it's just the anchor to be described if we standardize on 32 byte SMT keys. (Take hash-tree-root of key).",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/557351192/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/557355292",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1472#issuecomment-557355292",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1472",
    "id": 557355292,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU1NzM1NTI5Mg==",
    "user": {
      "login": "vbuterin",
      "id": 2230894,
      "node_id": "MDQ6VXNlcjIyMzA4OTQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2230894?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vbuterin",
      "html_url": "https://github.com/vbuterin",
      "followers_url": "https://api.github.com/users/vbuterin/followers",
      "following_url": "https://api.github.com/users/vbuterin/following{/other_user}",
      "gists_url": "https://api.github.com/users/vbuterin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vbuterin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vbuterin/subscriptions",
      "organizations_url": "https://api.github.com/users/vbuterin/orgs",
      "repos_url": "https://api.github.com/users/vbuterin/repos",
      "events_url": "https://api.github.com/users/vbuterin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vbuterin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-11-22T02:09:09Z",
    "updated_at": "2019-11-22T02:09:09Z",
    "author_association": "MEMBER",
    "body": "You would also need to specify the length of the branches. Otherwise if you just provide a branch it's not clear what part is supposed to go down to the leaf and what part is doing something further after that leaf. One possible case to think about would be a direct 2-level SMT (ie. an SMT of SMTs); you need to declare where the first one ends and the second begins.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/557355292/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/557365918",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1472#issuecomment-557365918",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1472",
    "id": 557365918,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU1NzM2NTkxOA==",
    "user": {
      "login": "protolambda",
      "id": 19571989,
      "node_id": "MDQ6VXNlcjE5NTcxOTg5",
      "avatar_url": "https://avatars.githubusercontent.com/u/19571989?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/protolambda",
      "html_url": "https://github.com/protolambda",
      "followers_url": "https://api.github.com/users/protolambda/followers",
      "following_url": "https://api.github.com/users/protolambda/following{/other_user}",
      "gists_url": "https://api.github.com/users/protolambda/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/protolambda/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/protolambda/subscriptions",
      "organizations_url": "https://api.github.com/users/protolambda/orgs",
      "repos_url": "https://api.github.com/users/protolambda/repos",
      "events_url": "https://api.github.com/users/protolambda/events{/privacy}",
      "received_events_url": "https://api.github.com/users/protolambda/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-11-22T02:57:12Z",
    "updated_at": "2019-11-22T02:57:12Z",
    "author_association": "MEMBER",
    "body": "Well, you don't need an end and start I think, just the anchors of each SMT: if you have the start (anchor) info of both SMTs, and you traverse the first one, you can skip 256 bits of gindex after this first anchor. Navigate the SMT till you hit the bottom (zero right hand, or 256 gindex bits all consumed), check the key (against the skipped 256 bits), and then continue reading the remaining part of the gindex to navigate deeper. Which could be into the next deeper SMT, anchored at `higher SMT anchor ++ its SMT 256 bit position ++ optional in-between SMTs navigation.` (`++` is generalized index concat). It's not pretty, but still minimal enough imo.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/557365918/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/557367025",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1472#issuecomment-557367025",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1472",
    "id": 557367025,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU1NzM2NzAyNQ==",
    "user": {
      "login": "vbuterin",
      "id": 2230894,
      "node_id": "MDQ6VXNlcjIyMzA4OTQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2230894?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vbuterin",
      "html_url": "https://github.com/vbuterin",
      "followers_url": "https://api.github.com/users/vbuterin/followers",
      "following_url": "https://api.github.com/users/vbuterin/following{/other_user}",
      "gists_url": "https://api.github.com/users/vbuterin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vbuterin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vbuterin/subscriptions",
      "organizations_url": "https://api.github.com/users/vbuterin/orgs",
      "repos_url": "https://api.github.com/users/vbuterin/repos",
      "events_url": "https://api.github.com/users/vbuterin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vbuterin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-11-22T03:02:04Z",
    "updated_at": "2019-11-22T03:02:14Z",
    "author_association": "MEMBER",
    "body": "> Navigate the SMT till you hit the bottom (zero right hand\r\n\r\nAh, are we assuming that the leaf in an SMT is (0, real_leaf)? Then where would the full key go?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/557367025/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/557368043",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1472#issuecomment-557368043",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1472",
    "id": 557368043,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU1NzM2ODA0Mw==",
    "user": {
      "login": "protolambda",
      "id": 19571989,
      "node_id": "MDQ6VXNlcjE5NTcxOTg5",
      "avatar_url": "https://avatars.githubusercontent.com/u/19571989?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/protolambda",
      "html_url": "https://github.com/protolambda",
      "followers_url": "https://api.github.com/users/protolambda/followers",
      "following_url": "https://api.github.com/users/protolambda/following{/other_user}",
      "gists_url": "https://api.github.com/users/protolambda/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/protolambda/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/protolambda/subscriptions",
      "organizations_url": "https://api.github.com/users/protolambda/orgs",
      "repos_url": "https://api.github.com/users/protolambda/repos",
      "events_url": "https://api.github.com/users/protolambda/events{/privacy}",
      "received_events_url": "https://api.github.com/users/protolambda/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-11-22T03:06:56Z",
    "updated_at": "2019-11-22T03:07:20Z",
    "author_association": "MEMBER",
    "body": "I was thinking (and described it in `MerkleMap/MerkleSet`) for a map the bottom would be like `H(H(htr(V), htr(K)), 0)`. First you break traversal on the 0 (as full 0 is not a natural hash of any kv pair). Then you check the key one level deeper (but to the left). And for a set you can say that `H(V)` is the position to check, and you don't need a `K`.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/557368043/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/617163504",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1472#issuecomment-617163504",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1472",
    "id": 617163504,
    "node_id": "MDEyOklzc3VlQ29tbWVudDYxNzE2MzUwNA==",
    "user": {
      "login": "JustinDrake",
      "id": 731743,
      "node_id": "MDQ6VXNlcjczMTc0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/731743?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JustinDrake",
      "html_url": "https://github.com/JustinDrake",
      "followers_url": "https://api.github.com/users/JustinDrake/followers",
      "following_url": "https://api.github.com/users/JustinDrake/following{/other_user}",
      "gists_url": "https://api.github.com/users/JustinDrake/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JustinDrake/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JustinDrake/subscriptions",
      "organizations_url": "https://api.github.com/users/JustinDrake/orgs",
      "repos_url": "https://api.github.com/users/JustinDrake/repos",
      "events_url": "https://api.github.com/users/JustinDrake/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JustinDrake/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-04-21T12:59:32Z",
    "updated_at": "2020-04-21T12:59:32Z",
    "author_association": "MEMBER",
    "body": "@protolambda What's the status on this issue? Do you still want to push it forward?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/617163504/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/617167188",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1472#issuecomment-617167188",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1472",
    "id": 617167188,
    "node_id": "MDEyOklzc3VlQ29tbWVudDYxNzE2NzE4OA==",
    "user": {
      "login": "protolambda",
      "id": 19571989,
      "node_id": "MDQ6VXNlcjE5NTcxOTg5",
      "avatar_url": "https://avatars.githubusercontent.com/u/19571989?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/protolambda",
      "html_url": "https://github.com/protolambda",
      "followers_url": "https://api.github.com/users/protolambda/followers",
      "following_url": "https://api.github.com/users/protolambda/following{/other_user}",
      "gists_url": "https://api.github.com/users/protolambda/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/protolambda/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/protolambda/subscriptions",
      "organizations_url": "https://api.github.com/users/protolambda/orgs",
      "repos_url": "https://api.github.com/users/protolambda/repos",
      "events_url": "https://api.github.com/users/protolambda/events{/privacy}",
      "received_events_url": "https://api.github.com/users/protolambda/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-04-21T13:06:46Z",
    "updated_at": "2020-04-21T13:06:46Z",
    "author_association": "MEMBER",
    "body": "@JustinDrake Yes, but it simply is not required right now for phase0, and not impossible to implement in addition to what we currently have. So I'm alright with keeping this open for now, and focusing on the network/testnet problems. If anyone is not working on testnets and wants to give this another look, maybe a new proposal, I'm happy to review it though.\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/617167188/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/629817410",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1472#issuecomment-629817410",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1472",
    "id": 629817410,
    "node_id": "MDEyOklzc3VlQ29tbWVudDYyOTgxNzQxMA==",
    "user": {
      "login": "farazhaider",
      "id": 3812337,
      "node_id": "MDQ6VXNlcjM4MTIzMzc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3812337?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/farazhaider",
      "html_url": "https://github.com/farazhaider",
      "followers_url": "https://api.github.com/users/farazhaider/followers",
      "following_url": "https://api.github.com/users/farazhaider/following{/other_user}",
      "gists_url": "https://api.github.com/users/farazhaider/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/farazhaider/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/farazhaider/subscriptions",
      "organizations_url": "https://api.github.com/users/farazhaider/orgs",
      "repos_url": "https://api.github.com/users/farazhaider/repos",
      "events_url": "https://api.github.com/users/farazhaider/events{/privacy}",
      "received_events_url": "https://api.github.com/users/farazhaider/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-05-17T15:39:08Z",
    "updated_at": "2020-05-17T15:39:08Z",
    "author_association": "NONE",
    "body": "Hi @protolambda \r\nI am the author of Compact sparse merkle trees (https://ethresear.ch/t/compact-sparse-merkle-trees/3741)\r\nUnfortunately I could not find time for the past 2 years to do some follow up work on this but now I do thanks to the current world situation.\r\nI'm not familiar with Ethereum's internals and what exactly are Ethereum's requirement in relation to this, could you please point me to a document where the broad requirements for using a Sparse merkle tree for Ethereum are listed.\r\nThanks",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/629817410/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
