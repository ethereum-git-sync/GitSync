{
  "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1776",
  "repository_url": "https://api.github.com/repos/ethereum/consensus-specs",
  "labels_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1776/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1776/comments",
  "events_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1776/events",
  "html_url": "https://github.com/ethereum/consensus-specs/issues/1776",
  "id": 609714045,
  "node_id": "MDU6SXNzdWU2MDk3MTQwNDU=",
  "number": 1776,
  "title": "[Bug Bounty] Committee selection can fork leading to multiple concurrent committees",
  "user": {
    "login": "kladkogex",
    "id": 13399135,
    "node_id": "MDQ6VXNlcjEzMzk5MTM1",
    "avatar_url": "https://avatars.githubusercontent.com/u/13399135?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/kladkogex",
    "html_url": "https://github.com/kladkogex",
    "followers_url": "https://api.github.com/users/kladkogex/followers",
    "following_url": "https://api.github.com/users/kladkogex/following{/other_user}",
    "gists_url": "https://api.github.com/users/kladkogex/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/kladkogex/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/kladkogex/subscriptions",
    "organizations_url": "https://api.github.com/users/kladkogex/orgs",
    "repos_url": "https://api.github.com/users/kladkogex/repos",
    "events_url": "https://api.github.com/users/kladkogex/events{/privacy}",
    "received_events_url": "https://api.github.com/users/kladkogex/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 2039931993,
      "node_id": "MDU6TGFiZWwyMDM5OTMxOTkz",
      "url": "https://api.github.com/repos/ethereum/consensus-specs/labels/general:bounty",
      "name": "general:bounty",
      "color": "AF5F3C",
      "default": false,
      "description": ""
    }
  ],
  "state": "open",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 6,
  "created_at": "2020-04-30T08:34:53Z",
  "updated_at": "2020-05-10T21:56:15Z",
  "closed_at": null,
  "author_association": "NONE",
  "active_lock_reason": null,
  "body": "_High-level description of the bug [1 sentence]_\r\n\r\nETH committee selection can fork leading to multiple concurrent committees operating, this needs to be at least addressed and explained in the spec.\r\n\r\n_Attack scenario_\r\n\r\nIn ETH2 committees are selected based on the current state of the chain, which in turn depends \r\non the winning branch of the block tree.  \r\n\r\nThe spec seems to not address the fact that since potentially Casper may not finalize for a long time, the LMD GHOST fork rule can lead to long-time reoderings in the chain.  \r\n\r\nAn attacker can potentially reorder the chain, say, one day back in the past, totally changing committee  assignments.  The committee members that thought they were  validating will be invalidated. \r\n\r\nIt then seems  that new true committees will not be able to operate, since no-one can not respond to changes happening back in time, unless there is a time machine invented.\r\n\r\nIt may be that the spec actually does allow multiple alternative committees operating at the same time, that correspond to alternate branches.  If yes, this needs to be explained in the spec. The way the spec currently is written it seems to state that there is a unique committee at each moment in time, which introduces confusion.\r\n\r\nAs I already mentioned, it may be a documentation issue, but the fact that this is not discussed at all in the spec is not good.\r\n\r\n_Impact: Describe the effect this may have in a production setting [1 to 2 sentences]_\r\n\r\nThe chain may lose consistency and irreparably stall.\r\n\r\n_Components: Point to the files, functions, and/or specific line numbers where the bug occurs [1 to 2 sentences]_\r\n\r\ndef get_committee_assignment(state: BeaconState,\r\n                             epoch: Epoch,\r\n                             validator_index: ValidatorIndex\r\n                             ) -> Optional[Tuple[Sequence[ValidatorIndex], CommitteeIndex, Slot]]:\r\n\r\nCommittee assignment depends on the state of the chain, which is not finalized\r\n\r\nhttps://github.com/ethereum/eth2.0-specs/blob/dev/specs/phase0/validator.md#validator-assignments\r\n\r\n_Reproduction: If used any sort of tools/simulations to find the bug, describe in detail how to reproduce the buggy behavior. Showcasing the bug using the python spec and associated test infrastructure found in the spec repo is preferred!_\r\n\r\n\r\n1. Start the chain.\r\n2. Turn off Casper for a while to simulate LMD Ghost only.\r\n3. Introduce a long-term reorg by  voting to for a very old alternative previously non-winning branch.\r\n\r\n\r\n_Details: Very specific details about the bug. What state must the system be in, what types of messages must be included and in which order, etc_\r\n\r\nI think this is pretty generic, the only condition is a long-term reorg that changes the committees.\r\n\r\nIt may be that the spec provides some type of defense against this, but I was not able to find it after re-reading the spec several times. \r\n\r\nIf some type of protection exist, it needs to be documented. So it may be either a documentation bug or a more fundamental spec issue.\r\n\r\n_Fix: Description of suggested fix if available_\r\n\r\nSeems that committees need to be selected only based on Casper-finalized state.\r\nThis means, that older finalized state needs to be used if newer does not yet exist.\r\n\r\nIt may be that the spec actually does allow multiple alternative committees operating at the same time, that correspond to alternate branches.  If yes, this needs to be explained in the spec.\r\n\r\n\r\nNote: if there is any bounty, please send it to Cancer Discovery fund \r\n\r\nhttp://med.stanford.edu/cancer/about/help/make-a-gift.html\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
  "closed_by": null,
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1776/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1776/timeline",
  "performed_via_github_app": null,
  "state_reason": null
}
[
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/621764087",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1776#issuecomment-621764087",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1776",
    "id": 621764087,
    "node_id": "MDEyOklzc3VlQ29tbWVudDYyMTc2NDA4Nw==",
    "user": {
      "login": "protolambda",
      "id": 19571989,
      "node_id": "MDQ6VXNlcjE5NTcxOTg5",
      "avatar_url": "https://avatars.githubusercontent.com/u/19571989?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/protolambda",
      "html_url": "https://github.com/protolambda",
      "followers_url": "https://api.github.com/users/protolambda/followers",
      "following_url": "https://api.github.com/users/protolambda/following{/other_user}",
      "gists_url": "https://api.github.com/users/protolambda/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/protolambda/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/protolambda/subscriptions",
      "organizations_url": "https://api.github.com/users/protolambda/orgs",
      "repos_url": "https://api.github.com/users/protolambda/repos",
      "events_url": "https://api.github.com/users/protolambda/events{/privacy}",
      "received_events_url": "https://api.github.com/users/protolambda/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-04-30T11:03:04Z",
    "updated_at": "2020-04-30T11:03:04Z",
    "author_association": "MEMBER",
    "body": "This looks more like a misunderstanding than a bug. That said, it's a relevant concern, and has already been raised here: #1523 (Or at least very similar).\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/621764087/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/621843902",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1776#issuecomment-621843902",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1776",
    "id": 621843902,
    "node_id": "MDEyOklzc3VlQ29tbWVudDYyMTg0MzkwMg==",
    "user": {
      "login": "djrtwo",
      "id": 1433595,
      "node_id": "MDQ6VXNlcjE0MzM1OTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1433595?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/djrtwo",
      "html_url": "https://github.com/djrtwo",
      "followers_url": "https://api.github.com/users/djrtwo/followers",
      "following_url": "https://api.github.com/users/djrtwo/following{/other_user}",
      "gists_url": "https://api.github.com/users/djrtwo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/djrtwo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/djrtwo/subscriptions",
      "organizations_url": "https://api.github.com/users/djrtwo/orgs",
      "repos_url": "https://api.github.com/users/djrtwo/repos",
      "events_url": "https://api.github.com/users/djrtwo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/djrtwo/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-04-30T13:32:32Z",
    "updated_at": "2020-04-30T13:32:32Z",
    "author_association": "MEMBER",
    "body": "This is a known feature of the spec.\r\n\r\nWithin the context of the state transition inclusion of attestations, only those from the most recent  and previous epoch wrt the chain in question can be included on chain, and thus from known shufflings.\r\n\r\nWithin the context of the block tree and LMD GHOST fork choice, all valid attestations from all blocks in the fork choice view are considered.\r\n\r\nWithin the context of attester slashings, indices (rather than on-chain calculated shufflings) are used to slash committees from unknown (from the view of the current chain) forks.\r\n\r\n> An attacker can potentially reorder the chain, say, one day back in the past, totally changing committee assignments. The committee members that thought they were validating will be invalidated.\r\n\r\nAn attacker can attempt to create some chain from the past with different committees, but (1) in most contexts this chain will have very little support (even in the context of non-finality) and be unlikely to be reorged to, and (2) the attacker chain would need to advance to a recent slot for considered at which point, it is indeed viable to look at and a node might swap to it if the LMD GHOST says so\r\n\r\n> Seems that committees need to be selected only based on Casper-finalized state.\r\nThis means, that older finalized state needs to be used if newer does not yet exist.\r\n\r\nThis would certainly make shufflings cleaner for client implementations, but would lose the benefit of short lookahead when the chain is not operating optimally, breaking some of the assumptions about randomness and committee selection.\r\n\r\n> The chain may lose consistency and irreparably stall.\r\n\r\nGiven how the state transition and fork choice handle forks, I do not believe that this is the case. The fork choice can generically handle the block tree, and incoming attestations are validated against the \"target\" state of the branch they are attesting to. So weight can be added to branches of the chain, a new head can be found, and state transitions up to this new head are self consistent.\r\n\r\n> It may be that the spec actually does allow multiple alternative committees operating at the same time, that correspond to alternate branches. If yes, this needs to be explained in the spec.\r\n\r\nAs you may have noted, the spec is particularly... terse. The existence of alternate shufflings in alternate branches is a very well known feature for client teams.\r\n\r\nThe concern when you open this up is less about pure consensus and fork choice issues (these structures are designed to handle it) and more about potential DoS issues. There is a tough balance between caching/pre-computing shufflings and being able to re-calculate depending on new information (new chains). In long running times of no finality, the potential DoS vector of an attacker exposing some deep reorg and inducing you to calculate epoch's worth of state transitions is a major concern.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/621843902/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/623402355",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1776#issuecomment-623402355",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1776",
    "id": 623402355,
    "node_id": "MDEyOklzc3VlQ29tbWVudDYyMzQwMjM1NQ==",
    "user": {
      "login": "kladkogex",
      "id": 13399135,
      "node_id": "MDQ6VXNlcjEzMzk5MTM1",
      "avatar_url": "https://avatars.githubusercontent.com/u/13399135?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kladkogex",
      "html_url": "https://github.com/kladkogex",
      "followers_url": "https://api.github.com/users/kladkogex/followers",
      "following_url": "https://api.github.com/users/kladkogex/following{/other_user}",
      "gists_url": "https://api.github.com/users/kladkogex/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kladkogex/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kladkogex/subscriptions",
      "organizations_url": "https://api.github.com/users/kladkogex/orgs",
      "repos_url": "https://api.github.com/users/kladkogex/repos",
      "events_url": "https://api.github.com/users/kladkogex/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kladkogex/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-05-04T11:12:28Z",
    "updated_at": "2020-05-04T11:12:28Z",
    "author_association": "NONE",
    "body": "> \r\nAn attacker can attempt to create some chain from the past with different committees, but (1) in most contexts this chain will have very little support (even in the context of non-finality) and be unlikely to be reorged to, and (2) the attacker chain would need to advance to a recent slot for considered at which point, it is indeed viable to look at and a node might swap to it if the LMD GHOST says so\r\n\r\n\r\nLets imagine that 10% of the stake is malicious.\r\n\r\nThen, isnt it true that malicious validators, without any help from honest validators,  will be able to advance the state of the alternative branch from an old point back in time to the current time?  This branch will be much weaker then the winning branch, but then due to an inactivity leak the alternative branch will be able to finalize, so one will end up with two correctly finalized branches, so one will have to apply LDM rule again, after finalization, to decide the fork.\r\n\r\nHow will the current clients behave if they are faced with two correctly finalized alternative branches?\r\n\r\nWill the following realistic attack work?\r\n\r\n1. Take control of 1% of stake.\r\n2. Recreate an alternative branch, going back 1 year in time and extending to the current time,  where only these 1% nodes participate.\r\n3. Note, that on this branch the good guys are inactive, so they will be leaked out.\r\n4. Finalize this branch using Casper (note that at the current time 1% will turn into 1%).\r\n5. Present the finalized branch to nodes to potentially crash the entire network, since finalization \r\n    is supposed to be final, so presumably nodes are not implemented to deal with two alternative\r\n   Casper-finalized heads, or at they?\r\n\r\nTo rephrase my question, should one conclude that the inactivity leak in the example breaks the mathematical finality Casper finalization, and nodes need to have additional finality mechanisms on top of Casper such as using the LMD rule again?\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/623402355/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/623545468",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1776#issuecomment-623545468",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1776",
    "id": 623545468,
    "node_id": "MDEyOklzc3VlQ29tbWVudDYyMzU0NTQ2OA==",
    "user": {
      "login": "vbuterin",
      "id": 2230894,
      "node_id": "MDQ6VXNlcjIyMzA4OTQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2230894?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vbuterin",
      "html_url": "https://github.com/vbuterin",
      "followers_url": "https://api.github.com/users/vbuterin/followers",
      "following_url": "https://api.github.com/users/vbuterin/following{/other_user}",
      "gists_url": "https://api.github.com/users/vbuterin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vbuterin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vbuterin/subscriptions",
      "organizations_url": "https://api.github.com/users/vbuterin/orgs",
      "repos_url": "https://api.github.com/users/vbuterin/repos",
      "events_url": "https://api.github.com/users/vbuterin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vbuterin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-05-04T15:49:42Z",
    "updated_at": "2020-05-04T15:49:42Z",
    "author_association": "MEMBER",
    "body": "Right, this attack vector does exist, and it _must_ exist because otherwise if 1-p of nodes go offline there is no way to continue the chain and eventually get back to normal. The response is that this attack is one of the two things (the other being validator rotation) that puts an upper bound on the weak subjectivity period of a chain, so the only solution is that clients need to log on often enough that when they see the attacker's chain they must have already seen a finalized block on the good chain after the attacker split off, and so the client will refuse to switch.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/623545468/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/624083056",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1776#issuecomment-624083056",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1776",
    "id": 624083056,
    "node_id": "MDEyOklzc3VlQ29tbWVudDYyNDA4MzA1Ng==",
    "user": {
      "login": "kladkogex",
      "id": 13399135,
      "node_id": "MDQ6VXNlcjEzMzk5MTM1",
      "avatar_url": "https://avatars.githubusercontent.com/u/13399135?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kladkogex",
      "html_url": "https://github.com/kladkogex",
      "followers_url": "https://api.github.com/users/kladkogex/followers",
      "following_url": "https://api.github.com/users/kladkogex/following{/other_user}",
      "gists_url": "https://api.github.com/users/kladkogex/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kladkogex/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kladkogex/subscriptions",
      "organizations_url": "https://api.github.com/users/kladkogex/orgs",
      "repos_url": "https://api.github.com/users/kladkogex/repos",
      "events_url": "https://api.github.com/users/kladkogex/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kladkogex/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-05-05T14:17:25Z",
    "updated_at": "2020-05-05T14:17:25Z",
    "author_association": "NONE",
    "body": "From your explanation it seems that the weak subjectivity period should be less or equal to the inactivity leak time. \r\n\r\nIt is dangerous to accept branches older than inactivity leak time.\r\n\r\nSo, does one need a check in the source code that specifically reject any new incoming branches older than inactivity leak time?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/624083056/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/626395688",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1776#issuecomment-626395688",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1776",
    "id": 626395688,
    "node_id": "MDEyOklzc3VlQ29tbWVudDYyNjM5NTY4OA==",
    "user": {
      "login": "JustinDrake",
      "id": 731743,
      "node_id": "MDQ6VXNlcjczMTc0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/731743?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JustinDrake",
      "html_url": "https://github.com/JustinDrake",
      "followers_url": "https://api.github.com/users/JustinDrake/followers",
      "following_url": "https://api.github.com/users/JustinDrake/following{/other_user}",
      "gists_url": "https://api.github.com/users/JustinDrake/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JustinDrake/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JustinDrake/subscriptions",
      "organizations_url": "https://api.github.com/users/JustinDrake/orgs",
      "repos_url": "https://api.github.com/users/JustinDrake/repos",
      "events_url": "https://api.github.com/users/JustinDrake/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JustinDrake/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-05-10T21:56:14Z",
    "updated_at": "2020-05-10T21:56:14Z",
    "author_association": "MEMBER",
    "body": "> does one need a check in the source code that specifically reject any new incoming branches older than inactivity leak time?\r\n\r\nSee https://github.com/ethereum/eth2.0-specs/issues/1520",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/626395688/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
