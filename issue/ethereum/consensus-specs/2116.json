{
  "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2116",
  "repository_url": "https://api.github.com/repos/ethereum/consensus-specs",
  "labels_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2116/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2116/comments",
  "events_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2116/events",
  "html_url": "https://github.com/ethereum/consensus-specs/issues/2116",
  "id": 732491243,
  "node_id": "MDU6SXNzdWU3MzI0OTEyNDM=",
  "number": 2116,
  "title": "BlocksByRange under WS sync",
  "user": {
    "login": "djrtwo",
    "id": 1433595,
    "node_id": "MDQ6VXNlcjE0MzM1OTU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1433595?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/djrtwo",
    "html_url": "https://github.com/djrtwo",
    "followers_url": "https://api.github.com/users/djrtwo/followers",
    "following_url": "https://api.github.com/users/djrtwo/following{/other_user}",
    "gists_url": "https://api.github.com/users/djrtwo/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/djrtwo/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/djrtwo/subscriptions",
    "organizations_url": "https://api.github.com/users/djrtwo/orgs",
    "repos_url": "https://api.github.com/users/djrtwo/repos",
    "events_url": "https://api.github.com/users/djrtwo/events{/privacy}",
    "received_events_url": "https://api.github.com/users/djrtwo/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 1295438707,
      "node_id": "MDU6TGFiZWwxMjk1NDM4NzA3",
      "url": "https://api.github.com/repos/ethereum/consensus-specs/labels/scope:networking",
      "name": "scope:networking",
      "color": "F596AA",
      "default": false,
      "description": ""
    },
    {
      "id": 2499986208,
      "node_id": "MDU6TGFiZWwyNDk5OTg2MjA4",
      "url": "https://api.github.com/repos/ethereum/consensus-specs/labels/scope:weak-subjectivity",
      "name": "scope:weak-subjectivity",
      "color": "A5DEE4",
      "default": false,
      "description": ""
    }
  ],
  "state": "open",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 7,
  "created_at": "2020-10-29T16:58:50Z",
  "updated_at": "2021-07-05T15:01:32Z",
  "closed_at": null,
  "author_association": "MEMBER",
  "active_lock_reason": null,
  "body": "As brought up by @mbaxter, it is unclear at this moment how to handle `BlocksByRange` requests when a node has synced from a weak subjectivity state.\r\n\r\nA few questions:\r\n1. What minimum block/epoch ranges (wrt current epoch) are expected to baseline be served by all nodes?\r\n2. How does a node know the range a peer will serve?\r\n3. If a `BlocksByRange` request is made to a peer and all or some subset of slots in that range are not in custody of the peer, what should be the response?\r\n\r\n### Question 1\r\n\r\n_What minimum block ranges (wrt current slot) are expected to baseline be served by all nodes?_\r\n\r\nThe spec current says:\r\n\r\n>  Clients MUST keep a record of signed blocks seen since the start of the weak subjectivity period and MUST support serving requests of blocks up to their own `head_block_root`\r\n\r\n\"weak subjectivity period\" is poorly defined in this context. I would suggest that that upper limit of the weak subjectivity period (~5 months at 100% safety decay) is used as a constant in this spec to define the minimum epoch range that a node is expected to backfill and keep around for serving. (The following is adopted from the weak-subjectivity guide):\r\n\r\n```python\r\nMIN_EPOCHS_FOR_BLOCK_REQUESTS = (\r\n    MIN_VALIDATOR_WITHDRAWABILITY_DELAY\r\n    + MAX_SAFETY_DECAY * CHURN_LIMIT_QUOTIENT // (2 * 100)\r\n)\r\n```\r\n\r\nWhere `MAX_SAFETY_DECAY = 100` and thus `MIN_EPOCHS_FOR_BLOCK_REQUESTS = 33024` (~5 months).\r\n\r\nThis could be considered overkill for small validator sets or more aggressive safety decays, but using the maximum here does not put an overly large block storage requirement on honest nodes and provides a higher guarantee in baseline quality of service _without_ trying to integrate dynamic WS period lengths into the assumptions in the networking protocol.\r\n\r\n### Question 2\r\n\r\n_How does a node know the range a peer will serve?_\r\n\r\nBy default, we can assume that all nodes will serve `MIN_EPOCHS_FOR_BLOCK_REQUESTS` worth of blocks from the current epoch. If not, that is grounds for de-scoring. But, many nodes might choose to serve beyond this range (maximally back to genesis).\r\n\r\nThere are two obvious places to publish this info, in `Status` or `MetaData`. `Status` is generally for info on head state of a node to decide if the node is on chains you care about for syncing, while `MetaData` is for more slowly changing information about the node in general.\r\n\r\nI can see the argument for using each\r\n* Put lower bound on block serve epoch in `Status` because `Status` is already used frequently when crafting block sync requests \r\n* Put lower bound on block serve epoch in `MetaData` because it isn't expected to change frequently and can be used to make more static decisions about which peers you want to sync with in general.\r\n\r\nDue to the expected slowly changing nature of the piece of data, I have a slight preference for putting it in `MetaData` but would like to hear the opinions of others.\r\n\r\nFor nodes that are still back-filling blocks from a WS state _or_ are block syncing from genesis, it might be worthwhile to signify this in `MetaData` as well. We can use `FAR_FUTURE_EPOCH` for the earliest block serve epoch to signify this.\r\n\r\n### Question 3\r\n\r\n_If a `BlocksByRange` request is made to a peer and all or some subset of slots in that range are not in the custody of the peer, what should be the response?_\r\n\r\n@mbaxter noted the following options available:\r\n1. Return an error\r\n2. Return an empty response\r\n3. Return any sequence of blocks in the range that are available\r\n\r\nBoth the 2nd and 3rd options provide misleading information about the slot range in question to the requester. \r\n\r\nI lean towards (1) -- return an error.\r\n\r\n",
  "closed_by": null,
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2116/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2116/timeline",
  "performed_via_github_app": null,
  "state_reason": null
}
[
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/718916148",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/2116#issuecomment-718916148",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2116",
    "id": 718916148,
    "node_id": "MDEyOklzc3VlQ29tbWVudDcxODkxNjE0OA==",
    "user": {
      "login": "mbaxter",
      "id": 658601,
      "node_id": "MDQ6VXNlcjY1ODYwMQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/658601?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mbaxter",
      "html_url": "https://github.com/mbaxter",
      "followers_url": "https://api.github.com/users/mbaxter/followers",
      "following_url": "https://api.github.com/users/mbaxter/following{/other_user}",
      "gists_url": "https://api.github.com/users/mbaxter/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mbaxter/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mbaxter/subscriptions",
      "organizations_url": "https://api.github.com/users/mbaxter/orgs",
      "repos_url": "https://api.github.com/users/mbaxter/repos",
      "events_url": "https://api.github.com/users/mbaxter/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mbaxter/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-10-29T17:45:45Z",
    "updated_at": "2020-10-29T17:45:45Z",
    "author_association": "CONTRIBUTOR",
    "body": "### Question 2\r\n> Due to the expected slowly changing nature of the piece of data, I have a slight preference for putting it in `MetaData` but would like to hear the opinions of others.\r\n\r\nOnce a node is fully synced, the earliest block served likely won't change.  But it could be useful to broadcast updates on the earliest block served as the node syncs.  We could then use this more granularly to decide which nodes are capable of serving us the blocks we need.  Whereas if we have a special value to indicate a node is syncing (FAR_FUTURE_EPOCH), we would have to consider any nodes in the process of syncing incapable of serving.  Or else we would have to try requests against syncing nodes expecting that they might fail. \r\n\r\n\r\n\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/718916148/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/718918095",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/2116#issuecomment-718918095",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2116",
    "id": 718918095,
    "node_id": "MDEyOklzc3VlQ29tbWVudDcxODkxODA5NQ==",
    "user": {
      "login": "mbaxter",
      "id": 658601,
      "node_id": "MDQ6VXNlcjY1ODYwMQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/658601?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mbaxter",
      "html_url": "https://github.com/mbaxter",
      "followers_url": "https://api.github.com/users/mbaxter/followers",
      "following_url": "https://api.github.com/users/mbaxter/following{/other_user}",
      "gists_url": "https://api.github.com/users/mbaxter/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mbaxter/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mbaxter/subscriptions",
      "organizations_url": "https://api.github.com/users/mbaxter/orgs",
      "repos_url": "https://api.github.com/users/mbaxter/repos",
      "events_url": "https://api.github.com/users/mbaxter/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mbaxter/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-10-29T17:48:56Z",
    "updated_at": "2020-10-29T17:48:56Z",
    "author_association": "CONTRIBUTOR",
    "body": "### Question 3\r\n\r\nI lean towards returning an error as well, as this is the most explicit option.  Would it make sense to add a new standard error response code for this?  ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/718918095/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/719065985",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/2116#issuecomment-719065985",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2116",
    "id": 719065985,
    "node_id": "MDEyOklzc3VlQ29tbWVudDcxOTA2NTk4NQ==",
    "user": {
      "login": "AgeManning",
      "id": 7454587,
      "node_id": "MDQ6VXNlcjc0NTQ1ODc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7454587?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/AgeManning",
      "html_url": "https://github.com/AgeManning",
      "followers_url": "https://api.github.com/users/AgeManning/followers",
      "following_url": "https://api.github.com/users/AgeManning/following{/other_user}",
      "gists_url": "https://api.github.com/users/AgeManning/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/AgeManning/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/AgeManning/subscriptions",
      "organizations_url": "https://api.github.com/users/AgeManning/orgs",
      "repos_url": "https://api.github.com/users/AgeManning/repos",
      "events_url": "https://api.github.com/users/AgeManning/events{/privacy}",
      "received_events_url": "https://api.github.com/users/AgeManning/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-10-29T22:44:27Z",
    "updated_at": "2020-10-29T22:44:27Z",
    "author_association": "CONTRIBUTOR",
    "body": "Another point we may want to consider is the possibility that a node wants to sync from genesis or an earlier state (I haven't thought about how likely this is going to be). \r\n\r\nBut in this case, when a node starts it will want to find peers that can serve it blocks it needs. It will be inefficient to have to find random peers, get status or metadata and then find out they don't support the block range and repeat. This is why I suggested putting the value in the ENR also, so we can search for peers that support the ranges we need. \r\n\r\nPotentially we won't have many peers doing this and it might not be worth putting it in. Just raising this as something to consider. ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/719065985/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/719495649",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/2116#issuecomment-719495649",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2116",
    "id": 719495649,
    "node_id": "MDEyOklzc3VlQ29tbWVudDcxOTQ5NTY0OQ==",
    "user": {
      "login": "arnetheduck",
      "id": 1382986,
      "node_id": "MDQ6VXNlcjEzODI5ODY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1382986?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/arnetheduck",
      "html_url": "https://github.com/arnetheduck",
      "followers_url": "https://api.github.com/users/arnetheduck/followers",
      "following_url": "https://api.github.com/users/arnetheduck/following{/other_user}",
      "gists_url": "https://api.github.com/users/arnetheduck/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/arnetheduck/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/arnetheduck/subscriptions",
      "organizations_url": "https://api.github.com/users/arnetheduck/orgs",
      "repos_url": "https://api.github.com/users/arnetheduck/repos",
      "events_url": "https://api.github.com/users/arnetheduck/events{/privacy}",
      "received_events_url": "https://api.github.com/users/arnetheduck/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-10-30T11:20:43Z",
    "updated_at": "2020-10-30T11:20:43Z",
    "author_association": "CONTRIBUTOR",
    "body": "> upper limit of the weak subjectivity period\r\n\r\n:+1:, though we should probably extend it \"a little\" to ensure that even when we're at max, we still can sync when considering network delays etc - in the past, we've considered \"double\" or \"a few epochs\" to be \"a little\" and there are arguments for either. it's also good that this is a constant, which makes it easier to reason able upper limits for storage that eth2 \"requires\" - there's already an upper bound on block size.\r\n\r\nanother thing is that we should redefine this to follow the _slot_ rather than the head _block_ since the range request in general works with slots.\r\n\r\nfinally, depending on the outcome of the finalized-vs-wsp discussion, if we decide wsp states are _not_ finalized, we need to ensure that clients can download blocks from `min(finalized, wsp)`, else they can't replay blocks to reach a head that points out the correct checkpoint. It's still possible to put an upper bound on storage in this case, but it becomes more difficult (essentially, the upper bound is now defined by the decay which causes validators to be ejected)\r\n\r\n> Once a node is fully synced, the earliest block served likely won't change. \r\n\r\nwhy is this? generally, a node will want to prune information regardless if it's starting up or running uninterrupted for a long time and thus it will change during the course of a connection - in fact, the expectation would be that the highest quality nodes will be running uninterrupted and will not want to reconnect their \"trusted\" connections or anything like this (unlike us devs that are running and restarting all the time) and if they are to maintain bounds on disk usage etc, they need to prune continuously - in fact, to ensure that we don't have long pruning delays, it makes sense to simply prune on every epoch. \r\n\r\n> metadata vs status\r\n\r\nthese two RPC requests are somewhat ambiguous in how they're supposed to be used as \"often\" vs \"sometimes\" doesn't really have a clear definition, and because they are both tiny, it doesn't really matter that much - either a client has to get them once on connection, or it has to poll for them - if it's polling, the gain from having two different polling frequencies is mostly negligible while adding complexity and confusion.\r\n\r\nSince sync-related data is already in status, it seems more natural to include it there - then we can reframe the raison-d'etre for the messages to be sync and gossip essentially which gives them a better reason to exist separately rather than being combined into one.\r\n\r\n> putting the value in the ENR also\r\n\r\none thing to consider is that once things get optional, they will tend towards the minimum \"allowed\" and the utility of putting them in ENR and similar will go down. what we're basically saying here is that if you want to run an archive node, you may want to announce it, but \"most\" nodes will support the minimum and that's it, as defined by the constant.\r\n\r\n> errors\r\n\r\nwe've avoided error codes so far because they can easily be gamed, misinterpreted or simply wrong due to changing conditions - it turns out that regardless of what error code the client gives you, you need to treat them as dishonest until they're proven to be honest - let's say we introduce an error code, and the peer responds that it won't answer your request - does that mean that the range has blocks or not? you can't trust the one peer so you need to find out by downloading _later blocks_ whose parent field will tell you. ie in all these cases, your behaviour as a downloading client is the same, regardless if they give you an empty range or an error code.\r\n\r\nIn this case, when `MIN_EPOCHS_FOR_BLOCK_REQUESTS` exists and I have a clock, I can compute what horizon I can _expect_ from the client, and penalize them if they don't answer my requests correctly - the situation is equivalent to not responding with blocks in any other range really (in the middle of sync for example) - and the logic for penalizing them is exactly the same: I ask for a range, they give me empty blocks, then I find out (from another peer?) that blocks existed in this range - I can now proceed to penalize the peer that did not follow the protocol. A similar situation exists when the peer announces they have more blocks through status - if they later respond with an empty range that's proven to be non-empty, they're faulty and should be scored accordingly.\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/719495649/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/720161858",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/2116#issuecomment-720161858",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2116",
    "id": 720161858,
    "node_id": "MDEyOklzc3VlQ29tbWVudDcyMDE2MTg1OA==",
    "user": {
      "login": "ajsutton",
      "id": 72675,
      "node_id": "MDQ6VXNlcjcyNjc1",
      "avatar_url": "https://avatars.githubusercontent.com/u/72675?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajsutton",
      "html_url": "https://github.com/ajsutton",
      "followers_url": "https://api.github.com/users/ajsutton/followers",
      "following_url": "https://api.github.com/users/ajsutton/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajsutton/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajsutton/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajsutton/subscriptions",
      "organizations_url": "https://api.github.com/users/ajsutton/orgs",
      "repos_url": "https://api.github.com/users/ajsutton/repos",
      "events_url": "https://api.github.com/users/ajsutton/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajsutton/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-11-01T22:29:47Z",
    "updated_at": "2020-11-01T22:29:47Z",
    "author_association": "CONTRIBUTOR",
    "body": "> let's say we introduce an error code, and the peer responds that it won't answer your request - does that mean that the range has blocks or not? you can't trust the one peer so you need to find out by downloading later blocks whose parent field will tell you. ie in all these cases, your behaviour as a downloading client is the same, regardless if they give you an empty range or an error code\r\n\r\nI don't think this is true.  If the client responds they don't have blocks for that range, you know they're useless to you (since you still need to sync that range) so can disconnect them immediately and find a peer that is useful to you.  If they return an empty range, you have to compare parent roots with other responses and other nodes to see if they're lying. Regardless of what happens though you can never be sure if they just switched forks at an inopportune time or if they're malicious so you wind up down scoring them and have to go through that process a couple of times before they get disconnected.  Worse, you also have to suspect that the slots were empty and other peers were lying so they get down scored as well.\r\n\r\nThe lack of clear information about whether a node is claiming a slot is empty or if it just didn't return the block for some other reason makes ETH2 sync massively more complex than it needs to be.  At least at the moment, if you get an empty response it means the node claims it has no blocks in that range at all. We'd lose that if we don't have a specific error code for this case.\r\n\r\nBasically it's extremely helpful to have a clear indication of what the node is claiming, even if we don't always know whether to believe the claim or not.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/720161858/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/725746554",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/2116#issuecomment-725746554",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2116",
    "id": 725746554,
    "node_id": "MDEyOklzc3VlQ29tbWVudDcyNTc0NjU1NA==",
    "user": {
      "login": "djrtwo",
      "id": 1433595,
      "node_id": "MDQ6VXNlcjE0MzM1OTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1433595?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/djrtwo",
      "html_url": "https://github.com/djrtwo",
      "followers_url": "https://api.github.com/users/djrtwo/followers",
      "following_url": "https://api.github.com/users/djrtwo/following{/other_user}",
      "gists_url": "https://api.github.com/users/djrtwo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/djrtwo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/djrtwo/subscriptions",
      "organizations_url": "https://api.github.com/users/djrtwo/orgs",
      "repos_url": "https://api.github.com/users/djrtwo/repos",
      "events_url": "https://api.github.com/users/djrtwo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/djrtwo/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-11-12T00:40:55Z",
    "updated_at": "2020-11-12T00:40:55Z",
    "author_association": "MEMBER",
    "body": "Thanks for the feedback. I'm working on a PR and will ping the participants here for input",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/725746554/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
