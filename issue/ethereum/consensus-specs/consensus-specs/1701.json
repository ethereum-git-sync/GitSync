{
  "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1701",
  "repository_url": "https://api.github.com/repos/ethereum/consensus-specs",
  "labels_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1701/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1701/comments",
  "events_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1701/events",
  "html_url": "https://github.com/ethereum/consensus-specs/issues/1701",
  "id": 592269340,
  "node_id": "MDU6SXNzdWU1OTIyNjkzNDA=",
  "number": 1701,
  "title": "Clarity on `uint` overflow",
  "user": {
    "login": "paulhauner",
    "id": 6660660,
    "node_id": "MDQ6VXNlcjY2NjA2NjA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6660660?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/paulhauner",
    "html_url": "https://github.com/paulhauner",
    "followers_url": "https://api.github.com/users/paulhauner/followers",
    "following_url": "https://api.github.com/users/paulhauner/following{/other_user}",
    "gists_url": "https://api.github.com/users/paulhauner/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/paulhauner/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/paulhauner/subscriptions",
    "organizations_url": "https://api.github.com/users/paulhauner/orgs",
    "repos_url": "https://api.github.com/users/paulhauner/repos",
    "events_url": "https://api.github.com/users/paulhauner/events{/privacy}",
    "received_events_url": "https://api.github.com/users/paulhauner/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 1725628406,
      "node_id": "MDU6TGFiZWwxNzI1NjI4NDA2",
      "url": "https://api.github.com/repos/ethereum/consensus-specs/labels/phase0",
      "name": "phase0",
      "color": "c2e0c6",
      "default": false,
      "description": ""
    }
  ],
  "state": "open",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 5,
  "created_at": "2020-04-01T23:51:08Z",
  "updated_at": "2020-04-21T08:03:06Z",
  "closed_at": null,
  "author_association": "CONTRIBUTOR",
  "active_lock_reason": null,
  "body": "We (Lighthouse) are interested in building a \"panic-free\" implementation of the state transitions. I think we're fairly close when compiled in Rust's \"release\" mode (optimized, production-ready), however for Rust's \"debug\" mode (slow but useful for troubleshooting) any integer overflow that is not explicitly handled causes a panic.\r\n\r\nWhen it comes to these overflows we have two choices:\r\n\r\n- Indicate that wrapping on overflow is desired behavior (viz., don't raise an exception).\r\n- Return early with an error if an overflow is encountered (viz., raise an exception).\r\n\r\nThe specification uses `uint...` types that, as I understand it, have undefined behavior when it comes to overflow (perhaps this can be derived from the tests, but this doesn't feel authoritative enough to me). From \"common sense\", I would assume that `uint64_max_value() + 1 == 0` and `0 - 1 == uint64_max_value()`. I also note that a few comments that infer `uint64` overflows:\r\n\r\n> Math safe up to ~10B ETH, afterwhich this overflows uint64.\r\n\r\n> Factored out from balance totals to avoid uint64 overflow\r\n\r\n> Factored out from penalty numerator to avoid uint64 overflow\r\n\r\nSo, I'm _inferring_ that uint64 overflows, _assuming_ that it's desired behavior and _assuming_ the specifics of that behavior.\r\n\r\nIt would be nice to have some clarity around this behavior. I understand that there's an idea that \"valid state transitions shouldn't lead to overflows\", but when it comes to things like fuzzing it's nice to have a distinction between \"expected wrapping overflow\" and \"unexpected wrapping overflow\".\r\n\r\nSo in summary, I have a question and a request please:\r\n- Question: is a state transition considered valid if integer arithmetic overflows?\r\n- Request: Make the spec explicit about the behavior of overflows.\r\n\r\nAs always, thanks! :)",
  "closed_by": null,
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1701/reactions",
    "total_count": 3,
    "+1": 3,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1701/timeline",
  "performed_via_github_app": null,
  "state_reason": null
}
[
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/607646884",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1701#issuecomment-607646884",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1701",
    "id": 607646884,
    "node_id": "MDEyOklzc3VlQ29tbWVudDYwNzY0Njg4NA==",
    "user": {
      "login": "JustinDrake",
      "id": 731743,
      "node_id": "MDQ6VXNlcjczMTc0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/731743?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JustinDrake",
      "html_url": "https://github.com/JustinDrake",
      "followers_url": "https://api.github.com/users/JustinDrake/followers",
      "following_url": "https://api.github.com/users/JustinDrake/following{/other_user}",
      "gists_url": "https://api.github.com/users/JustinDrake/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JustinDrake/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JustinDrake/subscriptions",
      "organizations_url": "https://api.github.com/users/JustinDrake/orgs",
      "repos_url": "https://api.github.com/users/JustinDrake/repos",
      "events_url": "https://api.github.com/users/JustinDrake/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JustinDrake/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-04-02T06:25:35Z",
    "updated_at": "2020-04-02T06:25:35Z",
    "author_association": "MEMBER",
    "body": "> So, I'm inferring that uint64 overflows, assuming that it's desired behavior and assuming the specifics of that behavior.\r\n\r\nI'd say the desired outcome is that these overflows are (provably, e.g. using formal verification) not possible. If for some reason we (the spec designers) messed up then overflows should probably trigger an exception.\r\n\r\n> Question: is a state transition considered valid if integer arithmetic overflows?\r\n\r\nI'd say \"no\", this is an invalid state transition.\r\n\r\n> Request: Make the spec explicit about the behavior of overflows.\r\n\r\nAgreed. To the sentence \"State transitions that trigger an unhandled exception (e.g. a failed assert or an out-of-range list access) are considered invalid.\" we could add \"Integer overflows are also considered exceptions.\" Alternatively, I believe we can redefine the behaviour of Python's arithmetic operators (e.g. `+` and `*`) to trigger overflow exceptions.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/607646884/reactions",
      "total_count": 3,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 3,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/608125426",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1701#issuecomment-608125426",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1701",
    "id": 608125426,
    "node_id": "MDEyOklzc3VlQ29tbWVudDYwODEyNTQyNg==",
    "user": {
      "login": "protolambda",
      "id": 19571989,
      "node_id": "MDQ6VXNlcjE5NTcxOTg5",
      "avatar_url": "https://avatars.githubusercontent.com/u/19571989?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/protolambda",
      "html_url": "https://github.com/protolambda",
      "followers_url": "https://api.github.com/users/protolambda/followers",
      "following_url": "https://api.github.com/users/protolambda/following{/other_user}",
      "gists_url": "https://api.github.com/users/protolambda/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/protolambda/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/protolambda/subscriptions",
      "organizations_url": "https://api.github.com/users/protolambda/orgs",
      "repos_url": "https://api.github.com/users/protolambda/repos",
      "events_url": "https://api.github.com/users/protolambda/events{/privacy}",
      "received_events_url": "https://api.github.com/users/protolambda/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-04-02T22:31:19Z",
    "updated_at": "2020-04-02T22:33:46Z",
    "author_association": "MEMBER",
    "body": "> Alternatively, I believe we can redefine the behaviour of Python's arithmetic operators (e.g. + and *) to trigger overflow exceptions.\r\n\r\nThis is already implemented. However, it's difficult to catch the cases where it doesn't go through these checked coercions (a + b returns a python int, which is then coerced safely, checking bounds, back into the spec type). It's difficult because python is very different from rust here, where it accepts everything by default, and doesn't know unsigned integers natively.\r\n\r\nAdding it to the spec as invalid-transition explicitly would be great :+1: ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/608125426/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/609524145",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1701#issuecomment-609524145",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1701",
    "id": 609524145,
    "node_id": "MDEyOklzc3VlQ29tbWVudDYwOTUyNDE0NQ==",
    "user": {
      "login": "michaelsproul",
      "id": 4452260,
      "node_id": "MDQ6VXNlcjQ0NTIyNjA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4452260?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/michaelsproul",
      "html_url": "https://github.com/michaelsproul",
      "followers_url": "https://api.github.com/users/michaelsproul/followers",
      "following_url": "https://api.github.com/users/michaelsproul/following{/other_user}",
      "gists_url": "https://api.github.com/users/michaelsproul/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/michaelsproul/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/michaelsproul/subscriptions",
      "organizations_url": "https://api.github.com/users/michaelsproul/orgs",
      "repos_url": "https://api.github.com/users/michaelsproul/repos",
      "events_url": "https://api.github.com/users/michaelsproul/events{/privacy}",
      "received_events_url": "https://api.github.com/users/michaelsproul/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-04-06T01:36:58Z",
    "updated_at": "2020-04-06T01:36:58Z",
    "author_association": "CONTRIBUTOR",
    "body": "> This is already implemented. However, it's difficult to catch the cases where it doesn't go through these checked coercions (a + b returns a python int, which is then coerced safely, checking bounds, back into the spec type). It's difficult because python is very different from rust here, where it accepts everything by default, and doesn't know unsigned integers natively.\r\n\r\nI'm not a Python expert, but the `uint` types from remerkleable seems to work quite well for checked addition and subtraction. Multiplication of two `uint`s returns an `int` however, which can exceed the bounds. Could we override `__add__`, `__sub__` and `__mul__` on the `uint` types for stronger guarantees? If they are all functions `(uint, uint) -> uint` that raise an exception on overflow, then that should be sufficient.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/609524145/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/609721192",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1701#issuecomment-609721192",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1701",
    "id": 609721192,
    "node_id": "MDEyOklzc3VlQ29tbWVudDYwOTcyMTE5Mg==",
    "user": {
      "login": "MrChico",
      "id": 8930559,
      "node_id": "MDQ6VXNlcjg5MzA1NTk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/8930559?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MrChico",
      "html_url": "https://github.com/MrChico",
      "followers_url": "https://api.github.com/users/MrChico/followers",
      "following_url": "https://api.github.com/users/MrChico/following{/other_user}",
      "gists_url": "https://api.github.com/users/MrChico/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MrChico/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MrChico/subscriptions",
      "organizations_url": "https://api.github.com/users/MrChico/orgs",
      "repos_url": "https://api.github.com/users/MrChico/repos",
      "events_url": "https://api.github.com/users/MrChico/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MrChico/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-04-06T10:50:50Z",
    "updated_at": "2020-04-06T10:50:50Z",
    "author_association": "MEMBER",
    "body": "> It would be nice to have some clarity around this behavior. I understand that there's an idea that \"valid state transitions shouldn't lead to overflows\", but when it comes to things like fuzzing it's nice to have a distinction between \"expected wrapping overflow\" and \"unexpected wrapping overflow\".\r\n\r\nWhile doing [overflow analysis in k](https://github.com/runtimeverification/beacon-chain-spec/pull/152/files) for `get_attestation_deltas`, we defined max and min values for the variables involved, treating overflows happening for input values given within these bounds as \"unexpected\" and overflows happening for values outside of this range as \"expected\" (or maybe, more accurately \"unspecified\" or \"irrelevant\"). It might be valuable to make these sanity bounds explicit in the spec",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/609721192/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/609843435",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/1701#issuecomment-609843435",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/1701",
    "id": 609843435,
    "node_id": "MDEyOklzc3VlQ29tbWVudDYwOTg0MzQzNQ==",
    "user": {
      "login": "protolambda",
      "id": 19571989,
      "node_id": "MDQ6VXNlcjE5NTcxOTg5",
      "avatar_url": "https://avatars.githubusercontent.com/u/19571989?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/protolambda",
      "html_url": "https://github.com/protolambda",
      "followers_url": "https://api.github.com/users/protolambda/followers",
      "following_url": "https://api.github.com/users/protolambda/following{/other_user}",
      "gists_url": "https://api.github.com/users/protolambda/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/protolambda/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/protolambda/subscriptions",
      "organizations_url": "https://api.github.com/users/protolambda/orgs",
      "repos_url": "https://api.github.com/users/protolambda/repos",
      "events_url": "https://api.github.com/users/protolambda/events{/privacy}",
      "received_events_url": "https://api.github.com/users/protolambda/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-04-06T14:52:38Z",
    "updated_at": "2020-04-06T14:52:38Z",
    "author_association": "MEMBER",
    "body": "`uint` base class in remerkleable (the SSZ library backing spec currently) has:\r\n\r\n```python\r\n    def __add__(self, other):\r\n        return self.__class__(super().__add__(self.__class__.coerce_view(other)))\r\n\r\n    def __sub__(self, other):\r\n        return self.__class__(super().__sub__(self.__class__.coerce_view(other)))\r\n```\r\n\r\nAdding these in next release, missed them earlier (thanks @michaelsproul):\r\n```python\r\n    def __mul__(self, other):\r\n        return self.__class__(super().__mul__(self.__class__.coerce_view(other)))\r\n\r\n    def __floordiv__(self, other):  # Better known as \"//\"\r\n        return self.__class__(super().__floordiv__(self.__class__.coerce_view(other)))\r\n```\r\n\r\nThe other value is converted to the same type (raising an exception if the byte length of the types does not match), then the regular python integer operation runs, and then the result is converted into the uint type of the self value (the constructor checks underflows/overflows).\r\n\r\nFormal verification/review are still good to have though, these python checks only help during runtime.\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/609843435/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
