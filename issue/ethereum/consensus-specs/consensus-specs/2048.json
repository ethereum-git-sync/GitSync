{
  "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2048",
  "repository_url": "https://api.github.com/repos/ethereum/consensus-specs",
  "labels_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2048/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2048/comments",
  "events_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2048/events",
  "html_url": "https://github.com/ethereum/consensus-specs/issues/2048",
  "id": 698725989,
  "node_id": "MDU6SXNzdWU2OTg3MjU5ODk=",
  "number": 2048,
  "title": "ENR Client Identifier",
  "user": {
    "login": "jrhea",
    "id": 5555162,
    "node_id": "MDQ6VXNlcjU1NTUxNjI=",
    "avatar_url": "https://avatars.githubusercontent.com/u/5555162?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/jrhea",
    "html_url": "https://github.com/jrhea",
    "followers_url": "https://api.github.com/users/jrhea/followers",
    "following_url": "https://api.github.com/users/jrhea/following{/other_user}",
    "gists_url": "https://api.github.com/users/jrhea/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/jrhea/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/jrhea/subscriptions",
    "organizations_url": "https://api.github.com/users/jrhea/orgs",
    "repos_url": "https://api.github.com/users/jrhea/repos",
    "events_url": "https://api.github.com/users/jrhea/events{/privacy}",
    "received_events_url": "https://api.github.com/users/jrhea/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 1295438707,
      "node_id": "MDU6TGFiZWwxMjk1NDM4NzA3",
      "url": "https://api.github.com/repos/ethereum/consensus-specs/labels/scope:networking",
      "name": "scope:networking",
      "color": "F596AA",
      "default": false,
      "description": ""
    },
    {
      "id": 2342396575,
      "node_id": "MDU6TGFiZWwyMzQyMzk2NTc1",
      "url": "https://api.github.com/repos/ethereum/consensus-specs/labels/scope:privacy",
      "name": "scope:privacy",
      "color": "FCFAF2",
      "default": false,
      "description": ""
    },
    {
      "id": 2349140270,
      "node_id": "MDU6TGFiZWwyMzQ5MTQwMjcw",
      "url": "https://api.github.com/repos/ethereum/consensus-specs/labels/scope:discovery",
      "name": "scope:discovery",
      "color": "91AD70",
      "default": false,
      "description": "Peer discovery protocol"
    }
  ],
  "state": "open",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 8,
  "created_at": "2020-09-11T02:09:56Z",
  "updated_at": "2020-09-15T03:32:52Z",
  "closed_at": null,
  "author_association": "CONTRIBUTOR",
  "active_lock_reason": null,
  "body": "Tracking the distribution of client types/versions is difficult; however, this could be made much easier if we simply added a client identifier field to the ENR.  The benefits mainly fall under the category of network health monitoring and the downside is that this makes it easier for attackers to target nodes by client/version. I am opening this issue so that we can discuss the pros and cons.  \r\n\r\nMy opinion is that this is identifier is probably only advantageous for an attacker targeting a zero-day vulnerability.  If they are targeting a known vulnerability that is fixed in a newer version of the client, then we will also know that there are vulnerable clients on the network and we can campaign to have people update their clients. In other words, i don't think this gives an attacker much (or any) of an edge, but it does give us useful information that we can use to monitor network health.\r\n\r\ncc: @ralexstokes, @dankrad, @djrtwo, @protolambda, @mkalinin, @AgeManning, @arnetheduck, @Nashatyrev",
  "closed_by": null,
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2048/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2048/timeline",
  "performed_via_github_app": null,
  "state_reason": null
}
[
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/690836832",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/2048#issuecomment-690836832",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2048",
    "id": 690836832,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY5MDgzNjgzMg==",
    "user": {
      "login": "ghost",
      "id": 10137,
      "node_id": "MDQ6VXNlcjEwMTM3",
      "avatar_url": "https://avatars.githubusercontent.com/u/10137?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ghost",
      "html_url": "https://github.com/ghost",
      "followers_url": "https://api.github.com/users/ghost/followers",
      "following_url": "https://api.github.com/users/ghost/following{/other_user}",
      "gists_url": "https://api.github.com/users/ghost/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ghost/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ghost/subscriptions",
      "organizations_url": "https://api.github.com/users/ghost/orgs",
      "repos_url": "https://api.github.com/users/ghost/repos",
      "events_url": "https://api.github.com/users/ghost/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ghost/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-09-11T02:33:17Z",
    "updated_at": "2020-09-11T02:33:17Z",
    "author_association": "NONE",
    "body": "Client implementations can always identify themselves _by default_ on the network, but have a `private` sort of flag for the security aware individuals running their clients.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/690836832/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/690851300",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/2048#issuecomment-690851300",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2048",
    "id": 690851300,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY5MDg1MTMwMA==",
    "user": {
      "login": "AgeManning",
      "id": 7454587,
      "node_id": "MDQ6VXNlcjc0NTQ1ODc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7454587?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/AgeManning",
      "html_url": "https://github.com/AgeManning",
      "followers_url": "https://api.github.com/users/AgeManning/followers",
      "following_url": "https://api.github.com/users/AgeManning/following{/other_user}",
      "gists_url": "https://api.github.com/users/AgeManning/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/AgeManning/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/AgeManning/subscriptions",
      "organizations_url": "https://api.github.com/users/AgeManning/orgs",
      "repos_url": "https://api.github.com/users/AgeManning/repos",
      "events_url": "https://api.github.com/users/AgeManning/events{/privacy}",
      "received_events_url": "https://api.github.com/users/AgeManning/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-09-11T03:26:30Z",
    "updated_at": "2020-09-11T03:26:30Z",
    "author_association": "CONTRIBUTOR",
    "body": "I've also thought about this. I'm leaning to there's more risk than reward here. \r\n\r\nJust to add potential cons to the list: \r\n- Attacks can then target peers via client - Maybe not a zero-day, but things like DoS all nodes of one client. \r\n  If there is a vulnerability in one client, an attacker would now to easily find all the peers of the effected version and perform the attack (it would be much harder to find these (especially we disable identify) without id'ing nodes in ENRs). \r\n- It opens the chance of implementers to skew discovery. For example, I might like a particular client because of its rpc response times or larger rate limits (making my client sync faster) and then favour a particular client in discovery (which at large scale may skew/partition networks). \r\n\r\nI've also be considering disabling identify in Lighthouse for mainnet. We didn't spec it, and originally it was used to to help for debugging etc. Was thinking it could be nice to have anonymous clients (terrible for debugging tho), \r\n\r\nIf we want metrics and health, would it be better to get users to optionally subscribe to ethstats? I guess the participation is low and sample sizes could be small to use that. \r\n\r\nDo we know how Eth1 monitors this?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/690851300/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/690870176",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/2048#issuecomment-690870176",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2048",
    "id": 690870176,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY5MDg3MDE3Ng==",
    "user": {
      "login": "nisdas",
      "id": 33201827,
      "node_id": "MDQ6VXNlcjMzMjAxODI3",
      "avatar_url": "https://avatars.githubusercontent.com/u/33201827?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/nisdas",
      "html_url": "https://github.com/nisdas",
      "followers_url": "https://api.github.com/users/nisdas/followers",
      "following_url": "https://api.github.com/users/nisdas/following{/other_user}",
      "gists_url": "https://api.github.com/users/nisdas/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/nisdas/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/nisdas/subscriptions",
      "organizations_url": "https://api.github.com/users/nisdas/orgs",
      "repos_url": "https://api.github.com/users/nisdas/repos",
      "events_url": "https://api.github.com/users/nisdas/events{/privacy}",
      "received_events_url": "https://api.github.com/users/nisdas/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-09-11T04:43:54Z",
    "updated_at": "2020-09-11T04:43:54Z",
    "author_association": "CONTRIBUTOR",
    "body": "> Attacks can then target peers via client - Maybe not a zero-day, but things like DoS all nodes of one client.\r\nIf there is a vulnerability in one client, an attacker would now to easily find all the peers of the effected version and perform the attack (it would be much harder to find these (especially we disable identify) without id'ing nodes in ENRs).\r\n\r\nHow realistic would a threat like something like this be in practice ? Assuming the threat is known before time, we would release the patch and only disclose the actual issue after a certain amount of time so that all live nodes can be updated with the fix. Even if we did remove all identifying client information outdated nodes would still be at risk as an attacker could just randomly ping nodes in the network until they find a vulnerable one.\r\n\r\nIn all the current live networks(ex: bitcoin, ethereum 1), client data is baked into the node's identity. \r\n\r\nhttps://github.com/bitcoin/bitcoin/blob/fc895d7700f9092d519b43000f412c1283e44d25/src/clientversion.cpp#L15\r\nhttps://github.com/ethereum/devp2p/blob/master/rlpx.md#hello-0x00 \r\n\r\nand hasn't had any adverse effect as far as I know. \r\n\r\n> If we want metrics and health, would it be better to get users to optionally subscribe to ethstats? I guess the participation is low and sample sizes could be small to use that.\r\n\r\nThis might be too low to get any valuable data from. Also users who do run ethstats are more likely to keep their nodes up to date and may not be an accurate gauge of the network. \r\n\r\nIf we do go with the anonymity option for all clients, along with removing any identifying client/version information we would\r\nneed to come to consensus on the common ports to be used by all clients here. As in the current state it is pretty easy to identify a client based on their default ports. \r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/690870176/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/690881537",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/2048#issuecomment-690881537",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2048",
    "id": 690881537,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY5MDg4MTUzNw==",
    "user": {
      "login": "jrhea",
      "id": 5555162,
      "node_id": "MDQ6VXNlcjU1NTUxNjI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5555162?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jrhea",
      "html_url": "https://github.com/jrhea",
      "followers_url": "https://api.github.com/users/jrhea/followers",
      "following_url": "https://api.github.com/users/jrhea/following{/other_user}",
      "gists_url": "https://api.github.com/users/jrhea/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jrhea/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jrhea/subscriptions",
      "organizations_url": "https://api.github.com/users/jrhea/orgs",
      "repos_url": "https://api.github.com/users/jrhea/repos",
      "events_url": "https://api.github.com/users/jrhea/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jrhea/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-09-11T05:23:19Z",
    "updated_at": "2020-09-11T05:23:56Z",
    "author_association": "CONTRIBUTOR",
    "body": "> It opens the chance of implementers to skew discovery. For example, I might like a particular client because of its rpc response times or larger rate limits (making my client sync faster) and then favour a particular client in discovery (which at large scale may skew/partition networks).\r\n\r\nI hear what you are saying, but wouldn't this require a deliberate modification?  I doubt it would be worth the effort.  if I was that desperate for faster syncing, then I'd look into possibly bootstrapping my database similar to how people do with Bitcoin.\r\n\r\nConsider this, with eth1 we essentially have 1 client.  if we can't encourage and monitor client diversity, then we are in the same situation as eth1.  we will have a single client dominating the network and people won't have to guess what client type it is bc everyone is using the same one.  so what's the harm? ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/690881537/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/690883748",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/2048#issuecomment-690883748",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2048",
    "id": 690883748,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY5MDg4Mzc0OA==",
    "user": {
      "login": "arnetheduck",
      "id": 1382986,
      "node_id": "MDQ6VXNlcjEzODI5ODY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1382986?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/arnetheduck",
      "html_url": "https://github.com/arnetheduck",
      "followers_url": "https://api.github.com/users/arnetheduck/followers",
      "following_url": "https://api.github.com/users/arnetheduck/following{/other_user}",
      "gists_url": "https://api.github.com/users/arnetheduck/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/arnetheduck/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/arnetheduck/subscriptions",
      "organizations_url": "https://api.github.com/users/arnetheduck/orgs",
      "repos_url": "https://api.github.com/users/arnetheduck/repos",
      "events_url": "https://api.github.com/users/arnetheduck/events{/privacy}",
      "received_events_url": "https://api.github.com/users/arnetheduck/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-09-11T05:29:36Z",
    "updated_at": "2020-09-11T05:29:36Z",
    "author_association": "CONTRIBUTOR",
    "body": "I'd generally not want to have this in discovery - it is not essential information for discovery to function correctly and comes at a cost - discovery tables get larger, bandwidth usage increases, there's less space in the ENR record for more valuable information.\r\n\r\nWhen clients talk to each other directly, such as when setting up a p2p connection, this cost doesn't multiply over the network, but with discovery it does: all nodes must now keep track of the field while not deriving any functional benefit.\r\n\r\nAs is, it's possible to build a libp2p crawler that connects to the client and runs identify - for those clients that want to participate, they can support identify and the burden is correctly placed on them, and on whoever is interested in these statistics.\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/690883748/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/690889381",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/2048#issuecomment-690889381",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2048",
    "id": 690889381,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY5MDg4OTM4MQ==",
    "user": {
      "login": "jrhea",
      "id": 5555162,
      "node_id": "MDQ6VXNlcjU1NTUxNjI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5555162?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jrhea",
      "html_url": "https://github.com/jrhea",
      "followers_url": "https://api.github.com/users/jrhea/followers",
      "following_url": "https://api.github.com/users/jrhea/following{/other_user}",
      "gists_url": "https://api.github.com/users/jrhea/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jrhea/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jrhea/subscriptions",
      "organizations_url": "https://api.github.com/users/jrhea/orgs",
      "repos_url": "https://api.github.com/users/jrhea/repos",
      "events_url": "https://api.github.com/users/jrhea/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jrhea/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-09-11T05:47:19Z",
    "updated_at": "2020-09-11T05:47:19Z",
    "author_association": "CONTRIBUTOR",
    "body": "> As is, it's possible to build a libp2p crawler that connects to the client and runs identify\r\n\r\nThere are was to make the client identifier small enough in size to make it a trivial matter\r\n\r\nI have crawled the network a fair amount and fed the crawls to rumor to connect to and call identify on... this isn't exactly free bandwidth wise and has led to many more unanswered questions. ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/690889381/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/691081332",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/2048#issuecomment-691081332",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2048",
    "id": 691081332,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY5MTA4MTMzMg==",
    "user": {
      "login": "mkalinin",
      "id": 1892772,
      "node_id": "MDQ6VXNlcjE4OTI3NzI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1892772?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mkalinin",
      "html_url": "https://github.com/mkalinin",
      "followers_url": "https://api.github.com/users/mkalinin/followers",
      "following_url": "https://api.github.com/users/mkalinin/following{/other_user}",
      "gists_url": "https://api.github.com/users/mkalinin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mkalinin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mkalinin/subscriptions",
      "organizations_url": "https://api.github.com/users/mkalinin/orgs",
      "repos_url": "https://api.github.com/users/mkalinin/repos",
      "events_url": "https://api.github.com/users/mkalinin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mkalinin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-09-11T13:02:05Z",
    "updated_at": "2020-09-11T13:02:05Z",
    "author_association": "MEMBER",
    "body": "> In all the current live networks(ex: bitcoin, ethereum 1), client data is baked into the node's identity.\r\n>\r\n> https://github.com/bitcoin/bitcoin/blob/fc895d7700f9092d519b43000f412c1283e44d25/src/clientversion.cpp#L15\r\n> https://github.com/ethereum/devp2p/blob/master/rlpx.md#hello-0x00\r\n>\r\n> and hasn't had any adverse effect as far as I know.\r\n\r\nI tend to agree. But these are PoW networks where knocking out particular node doesn't matter that much for network liveness wrt PoS where a node could serve a validator that is about to produce a block. This fact worth considering.\r\n\r\n> discovery tables get larger, bandwidth usage increases, there's less space in the ENR record for more valuable information.\r\n\r\nENR is not supposed to be updated frequently, thus not supposed to be exchanged frequently as well, we can set the max size for client id field to take a control over table size. But then updating a client version will cause an update of ENR, though it should not happen too often.\r\n\r\nAs @jrhea said otherwise you will have to crawl DHT and make a trial connection with a peer to read its client id which causes more network traffic than extra piece of data in ENR (If there is an option to get this info anyhow)\r\n\r\nI think, first of all, we should decide whether reading remote client id is safe in Eth2. On one hand we can justify on the health of the network, on the other, particular peer can be knocked out if its version contains a vulnerability.\r\n\r\nBtw, will client id be valuable if it cut to the client name only with no particular version in it?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/691081332/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/691748170",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/2048#issuecomment-691748170",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2048",
    "id": 691748170,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY5MTc0ODE3MA==",
    "user": {
      "login": "AgeManning",
      "id": 7454587,
      "node_id": "MDQ6VXNlcjc0NTQ1ODc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7454587?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/AgeManning",
      "html_url": "https://github.com/AgeManning",
      "followers_url": "https://api.github.com/users/AgeManning/followers",
      "following_url": "https://api.github.com/users/AgeManning/following{/other_user}",
      "gists_url": "https://api.github.com/users/AgeManning/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/AgeManning/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/AgeManning/subscriptions",
      "organizations_url": "https://api.github.com/users/AgeManning/orgs",
      "repos_url": "https://api.github.com/users/AgeManning/repos",
      "events_url": "https://api.github.com/users/AgeManning/events{/privacy}",
      "received_events_url": "https://api.github.com/users/AgeManning/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-09-14T00:20:09Z",
    "updated_at": "2020-09-14T00:29:10Z",
    "author_association": "CONTRIBUTOR",
    "body": "> How realistic would a threat like something like this be in practice ? Assuming the threat is known before time, we would release the patch and only disclose the actual issue after a certain amount of time so that all live nodes can be updated with the fix. Even if we did remove all identifying client information outdated nodes would still be at risk as an attacker could just randomly ping nodes in the network until they find a vulnerable one.\r\n\r\nI think it is very realistic. I think your assumption here is that we find bugs before attackers (which isn't necessarily true). \r\n\r\n> I hear what you are saying, but wouldn't this require a deliberate modification? I doubt it would be worth the effort. if I was that desperate for faster syncing, then I'd look into possibly bootstrapping my database similar to how people do with Bitcoin.\r\n\r\nI was thinking more generally. Like parity introduced warp sync and supported different protocols. In these cases a client would want to find more of itself to perform some extra-spec protocol. Maybe a client introduces an extra layer to gossip slashings amongst itself, or faster/extra attestation propagation etc. I think Prysm use relays, so (if I understand correctly) its probably better for a prysm peer to find and connect more Prysm relay peers for connectivity).  \r\nEDIT: I realise my point here is moot. If a client wants to do this, they can just add their own field into their ENR to discover themselves. Ignore me on this one :). \r\n\r\nAs it stands, with enough effort, someone can crawl through the DHT and identify peers (with or without identify). I think this just alleviates some of the hurdle of doing this. \r\n\r\nI agree with @mkalinin that we should first decide whether this knowledge is considered safe. And even so, having a difficult barrier to obtain the knowledge isn't really securing it, but I guess its a slight deterrent. ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/691748170/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
