{
  "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2182",
  "repository_url": "https://api.github.com/repos/ethereum/consensus-specs",
  "labels_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2182/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2182/comments",
  "events_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2182/events",
  "html_url": "https://github.com/ethereum/consensus-specs/issues/2182",
  "id": 785077667,
  "node_id": "MDU6SXNzdWU3ODUwNzc2Njc=",
  "number": 2182,
  "title": "Light client reorg mechanism",
  "user": {
    "login": "hwwhww",
    "id": 9263930,
    "node_id": "MDQ6VXNlcjkyNjM5MzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/9263930?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/hwwhww",
    "html_url": "https://github.com/hwwhww",
    "followers_url": "https://api.github.com/users/hwwhww/followers",
    "following_url": "https://api.github.com/users/hwwhww/following{/other_user}",
    "gists_url": "https://api.github.com/users/hwwhww/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/hwwhww/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/hwwhww/subscriptions",
    "organizations_url": "https://api.github.com/users/hwwhww/orgs",
    "repos_url": "https://api.github.com/users/hwwhww/repos",
    "events_url": "https://api.github.com/users/hwwhww/events{/privacy}",
    "received_events_url": "https://api.github.com/users/hwwhww/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 1137720193,
      "node_id": "MDU6TGFiZWwxMTM3NzIwMTkz",
      "url": "https://api.github.com/repos/ethereum/consensus-specs/labels/general:discussion",
      "name": "general:discussion",
      "color": "F17C67",
      "default": false,
      "description": ""
    },
    {
      "id": 1244766996,
      "node_id": "MDU6TGFiZWwxMjQ0NzY2OTk2",
      "url": "https://api.github.com/repos/ethereum/consensus-specs/labels/scope:light-clients",
      "name": "scope:light-clients",
      "color": "211E55",
      "default": false,
      "description": ""
    },
    {
      "id": 2789549886,
      "node_id": "MDU6TGFiZWwyNzg5NTQ5ODg2",
      "url": "https://api.github.com/repos/ethereum/consensus-specs/labels/Altair",
      "name": "Altair",
      "color": "FB966E",
      "default": false,
      "description": "aka HF1"
    }
  ],
  "state": "open",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 5,
  "created_at": "2021-01-13T12:50:15Z",
  "updated_at": "2021-03-15T10:49:54Z",
  "closed_at": null,
  "author_association": "MEMBER",
  "active_lock_reason": null,
  "body": "Follow-up of https://github.com/ethereum/eth2.0-specs/pull/2147#discussion_r555010707:\r\n\r\n@vbuterin:\r\n\r\nI think the light client being capable of reorging is reasonable. Definitely an okay response especially in cases of high network latency.\r\n\r\nThis is making me realize that it would take some cleverness to make light clients capable of reorging. Here is one rough proposal. The LightClientStore keeps track of a _series_ of heads, which must always satisfy the following invariants:\r\n\r\n* `store.heads[0]` must be finalized (if we want, if a block has been part of `store.heads` for >= 24 hours we can \"finalize\" it locally)\r\n* `store.heads[n+1]` must be a descendant of `store.heads[n]`\r\n* `vote_count(store.heads[n+1]) < vote_count(store.heads[n])`\r\n\r\nEssentially, it is the client's best guess of the current chain, with confidence naturally decreasing as you get closer to the tip.\r\n\r\nWhen a client receives a light client update, the update must reference an ancestor that is in `store.heads`. The update must satisfy the properties:\r\n\r\n1. `votes(update.block) < votes(update.ancestor)`\r\n2. `update.ancestor == store.heads[-1] or votes(update.block) > votes(store.heads[store.heads.index(update.ancestor) + 1])`\r\n\r\nIn other words, it must be a better alternative than whatever block it is replacing. If the update is accepted, then all elements from `store.heads` after `update.ancestor` are removed, and `update.block` is added to the end.\r\n",
  "closed_by": null,
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2182/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2182/timeline",
  "performed_via_github_app": null,
  "state_reason": null
}
[
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/759565957",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/2182#issuecomment-759565957",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2182",
    "id": 759565957,
    "node_id": "MDEyOklzc3VlQ29tbWVudDc1OTU2NTk1Nw==",
    "user": {
      "login": "ralexstokes",
      "id": 3113781,
      "node_id": "MDQ6VXNlcjMxMTM3ODE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3113781?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ralexstokes",
      "html_url": "https://github.com/ralexstokes",
      "followers_url": "https://api.github.com/users/ralexstokes/followers",
      "following_url": "https://api.github.com/users/ralexstokes/following{/other_user}",
      "gists_url": "https://api.github.com/users/ralexstokes/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ralexstokes/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ralexstokes/subscriptions",
      "organizations_url": "https://api.github.com/users/ralexstokes/orgs",
      "repos_url": "https://api.github.com/users/ralexstokes/repos",
      "events_url": "https://api.github.com/users/ralexstokes/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ralexstokes/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-01-13T16:30:40Z",
    "updated_at": "2021-01-13T16:30:40Z",
    "author_association": "MEMBER",
    "body": "I think it is fine (as I believe @djrtwo mentioned) we can make a note in the current doc that this version of the light client prefers to track the finalized chain (at the cost of having the most up-to-date chain state). And then in another PR, we can add an extension to the light client that implements the the ability to track the best head seen -- the above sketch from @vbuterin seems like a great place to start!",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/759565957/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/759834338",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/2182#issuecomment-759834338",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2182",
    "id": 759834338,
    "node_id": "MDEyOklzc3VlQ29tbWVudDc1OTgzNDMzOA==",
    "user": {
      "login": "djrtwo",
      "id": 1433595,
      "node_id": "MDQ6VXNlcjE0MzM1OTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1433595?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/djrtwo",
      "html_url": "https://github.com/djrtwo",
      "followers_url": "https://api.github.com/users/djrtwo/followers",
      "following_url": "https://api.github.com/users/djrtwo/following{/other_user}",
      "gists_url": "https://api.github.com/users/djrtwo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/djrtwo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/djrtwo/subscriptions",
      "organizations_url": "https://api.github.com/users/djrtwo/orgs",
      "repos_url": "https://api.github.com/users/djrtwo/repos",
      "events_url": "https://api.github.com/users/djrtwo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/djrtwo/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-01-14T00:00:29Z",
    "updated_at": "2021-01-14T00:03:14Z",
    "author_association": "MEMBER",
    "body": "Yeah, so I think we should have two types of light clients (at least) -- one that is very simple and just follows finality updates, and one that can follow the head and reorg if needed. The former would likely be what we'd see in cross-chain bridges and/or the eth1 beacon chain light client contract.\r\n\r\n---------\r\n\r\nIs `votes` the LMD-GHOST vote count? I assume so because of `vote_count(store.heads[n+1]) < vote_count(store.heads[n])`.\r\n\r\nNow that I think about it, I'm worried the algorithm proposed above can get stuck (until new finalized). \r\n\r\n* light client sees block P with ~100% sync committee vote\r\n* then sees block A (child of P) with ~33% sync committee vote [new head]\r\n* then sees block B (also child of P) with ~66% sync committee vote [new head]\r\n* then block A' (child of A) is built and begins to win favor over B with normal fork choice, so sync committee moves back and is near 100% on it. If A' is given to the light client, it can't switch back to this branch because it would first have to switch to A which can't beat out B. That is unless A and A' can be batch updated to show a cumulative higher weight. Even then you would definitely need to bring in a notion of LMD or it could still get stuck on the orphaned side of two equal branches.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/759834338/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/759851623",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/2182#issuecomment-759851623",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2182",
    "id": 759851623,
    "node_id": "MDEyOklzc3VlQ29tbWVudDc1OTg1MTYyMw==",
    "user": {
      "login": "ralexstokes",
      "id": 3113781,
      "node_id": "MDQ6VXNlcjMxMTM3ODE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3113781?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ralexstokes",
      "html_url": "https://github.com/ralexstokes",
      "followers_url": "https://api.github.com/users/ralexstokes/followers",
      "following_url": "https://api.github.com/users/ralexstokes/following{/other_user}",
      "gists_url": "https://api.github.com/users/ralexstokes/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ralexstokes/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ralexstokes/subscriptions",
      "organizations_url": "https://api.github.com/users/ralexstokes/orgs",
      "repos_url": "https://api.github.com/users/ralexstokes/repos",
      "events_url": "https://api.github.com/users/ralexstokes/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ralexstokes/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-01-14T00:49:16Z",
    "updated_at": "2021-01-14T00:49:16Z",
    "author_association": "MEMBER",
    "body": "I interpret both `vote_count` and `votes` above as just the sum of the `sync_committee_bits` in a given block.\r\n\r\nYeah, it does seem that the light client would get stuck under the scenario you give under the above rules.\r\n\r\nI see two options:\r\n\r\n1. Add some interactive protocol at the network level to let a light client fetch missing ancestors. In this case, the light client above would fetch A upon receiving the majority update to A' and not finding A in its store. It could then compute the higher weight and switch to A'.\r\n2. Provide a sync committee proof from the finalized block (as we know the light client trusts this one) to the new head, in the event of a re-org. This route is non-interactive but implies efficient light client servers will be tracking which light clients have seen which states of the chain (as you can get away w/ the above rules if there is no re-org).\r\n\r\nSome variation here involves the light server providing an update to a block (A') with an unknown ancestor (A) and then upon getting an error response from the light client, turn around and serve the proof of the full chain like in (2). Much like a \"force push\" in `git`.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/759851623/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/759896189",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/2182#issuecomment-759896189",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2182",
    "id": 759896189,
    "node_id": "MDEyOklzc3VlQ29tbWVudDc1OTg5NjE4OQ==",
    "user": {
      "login": "vbuterin",
      "id": 2230894,
      "node_id": "MDQ6VXNlcjIyMzA4OTQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2230894?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vbuterin",
      "html_url": "https://github.com/vbuterin",
      "followers_url": "https://api.github.com/users/vbuterin/followers",
      "following_url": "https://api.github.com/users/vbuterin/following{/other_user}",
      "gists_url": "https://api.github.com/users/vbuterin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vbuterin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vbuterin/subscriptions",
      "organizations_url": "https://api.github.com/users/vbuterin/orgs",
      "repos_url": "https://api.github.com/users/vbuterin/repos",
      "events_url": "https://api.github.com/users/vbuterin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vbuterin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-01-14T03:09:49Z",
    "updated_at": "2021-01-14T03:09:49Z",
    "author_association": "MEMBER",
    "body": "> then block A' (child of A) is built and begins to win favor over B with normal fork choice, so sync committee moves back and is near 100% on it. If A' is given to the light client, it can't switch back to this branch because it would first have to switch to A which can't beat out B.\r\n\r\nAh, maybe I was not being clear enough. A' would be able to compete with B directly. There's no requirement that `heads[n+1]` must be a _direct_ child of `heads[n]`.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/759896189/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/762847757",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/2182#issuecomment-762847757",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/2182",
    "id": 762847757,
    "node_id": "MDEyOklzc3VlQ29tbWVudDc2Mjg0Nzc1Nw==",
    "user": {
      "login": "djrtwo",
      "id": 1433595,
      "node_id": "MDQ6VXNlcjE0MzM1OTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1433595?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/djrtwo",
      "html_url": "https://github.com/djrtwo",
      "followers_url": "https://api.github.com/users/djrtwo/followers",
      "following_url": "https://api.github.com/users/djrtwo/following{/other_user}",
      "gists_url": "https://api.github.com/users/djrtwo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/djrtwo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/djrtwo/subscriptions",
      "organizations_url": "https://api.github.com/users/djrtwo/orgs",
      "repos_url": "https://api.github.com/users/djrtwo/repos",
      "events_url": "https://api.github.com/users/djrtwo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/djrtwo/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-01-19T13:44:42Z",
    "updated_at": "2021-01-19T13:46:02Z",
    "author_association": "MEMBER",
    "body": "Yeah okay, I missed that.\r\n\r\nOne complication in a server being able to serve such requests is that they need to know two things\r\n1. That light-client is on another branch and thus need to generate a proof from some prior block\r\n2. To know at least a single block in lightclient's tree so that they may construct a proof from it (thus convince you that they are sending an ancestor for your local view)\r\n\r\n(1) can be satisfied with some sort of `Status` network message saying the light-client's head.\r\n\r\nAs for (2), a simple `Status` saying the head wouldn't suffice because it doesn't give the server info on which prior block in the chain it can make a fork proof on. It could say or imply what your latest finalized root is. The server could construct the reorg proof(s) from there. It would be a single proof if it didn't need to walk through a committee update(s) in the middle. Otherwise would need to be one per committee update.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/762847757/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
