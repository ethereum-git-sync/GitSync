{
  "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/701",
  "repository_url": "https://api.github.com/repos/ethereum/consensus-specs",
  "labels_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/701/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/701/comments",
  "events_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/701/events",
  "html_url": "https://github.com/ethereum/consensus-specs/issues/701",
  "id": 415440777,
  "node_id": "MDU6SXNzdWU0MTU0NDA3Nzc=",
  "number": 701,
  "title": "CBCification",
  "user": {
    "login": "vbuterin",
    "id": 2230894,
    "node_id": "MDQ6VXNlcjIyMzA4OTQ=",
    "avatar_url": "https://avatars.githubusercontent.com/u/2230894?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/vbuterin",
    "html_url": "https://github.com/vbuterin",
    "followers_url": "https://api.github.com/users/vbuterin/followers",
    "following_url": "https://api.github.com/users/vbuterin/following{/other_user}",
    "gists_url": "https://api.github.com/users/vbuterin/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/vbuterin/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/vbuterin/subscriptions",
    "organizations_url": "https://api.github.com/users/vbuterin/orgs",
    "repos_url": "https://api.github.com/users/vbuterin/repos",
    "events_url": "https://api.github.com/users/vbuterin/events{/privacy}",
    "received_events_url": "https://api.github.com/users/vbuterin/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 1063052501,
      "node_id": "MDU6TGFiZWwxMDYzMDUyNTAx",
      "url": "https://api.github.com/repos/ethereum/consensus-specs/labels/general:RFC",
      "name": "general:RFC",
      "color": "00D1B2",
      "default": false,
      "description": "Request for Comments"
    },
    {
      "id": 1252242617,
      "node_id": "MDU6TGFiZWwxMjUyMjQyNjE3",
      "url": "https://api.github.com/repos/ethereum/consensus-specs/labels/phase2",
      "name": "phase2",
      "color": "90B44B",
      "default": false,
      "description": ""
    },
    {
      "id": 1252249432,
      "node_id": "MDU6TGFiZWwxMjUyMjQ5NDMy",
      "url": "https://api.github.com/repos/ethereum/consensus-specs/labels/phase3+",
      "name": "phase3+",
      "color": "FBE251",
      "default": false,
      "description": ""
    }
  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 6,
  "created_at": "2019-02-28T04:21:30Z",
  "updated_at": "2020-04-21T12:56:58Z",
  "closed_at": "2020-04-21T12:56:57Z",
  "author_association": "MEMBER",
  "active_lock_reason": null,
  "body": "This issue is intended as an illustration of the concrete spec changes that would be required to transition the beacon chain from its current FFG-based spec (see [the mini-spec](https://ethresear.ch/t/beacon-chain-casper-mini-spec/2760)) to CBC (reading material [here](https://vitalik.ca/general/2018/12/05/cbc_casper.html) [here](https://medium.com/@aditya.asgaonkar/casper-cbc-simplified-2370922f9aa6) [here](https://ethresear.ch/t/beacon-chain-friendly-cbc-casper/4710) and [here](https://ethresear.ch/t/bitwise-lmd-ghost/4749)).\r\n\r\nThis is still a work in progress, though it is much more concrete than previous versions of this doc.\r\n\r\n### Fork choice rule changes\r\n\r\nThe fork choice rule changes from the current \"favor the highest justified checkpoint then use LMD GHOST\" to \"use bitwise LMD GHOST\", but using the balances at each epoch during each epoch.\r\n\r\nA new helper:\r\n\r\n```python\r\ndef get_updated_bitfield(bitfield: bytes, position: int, bit: bool) -> bytes:\r\n    bytepos, bitmask = position // 8, 2**(position % 8)\r\n    if bit:\r\n        return bitfield[:bytepos] + bytes([bitfield[bytepos] | bitmask]) + bitfield[bytepos+1:]\r\n    else:\r\n        return bitfield[:bytepos] + bytes([bitfield[bytepos] & (255 - bitmask)]) + bitfield[bytepos+1:]\r\n```\r\n\r\nHere is the new fork choice rule:\r\n\r\n```python\r\ndef lmd_ghost(store: Store, start_block: BeaconBlock) -> BeaconBlock:\r\n    \"\"\"\r\n    Execute the LMD-GHOST algorithm to find the head ``BeaconBlock``.\r\n    \"\"\"\r\n    head = start_block\r\n    def get_vote_count(block: BeaconBlock) -> int:\r\n        return sum(\r\n            get_effective_balance(head_state.validator_balances[validator_index]) // FORK_CHOICE_BALANCE_INCREMENT\r\n            for validator_index, target in attestation_targets\r\n            if get_ancestor(store, target, block.slot) == block\r\n        )\r\n\r\n    while 1:\r\n        head_state = get_post_state(head)\r\n        children = get_children(store, head)\r\n        if len(children) == 0:\r\n            return head\r\n        prefix_bit = 0\r\n        while len(children) > 1:\r\n            children_0 = [c for c in children if get_bitfield_bit(c, prefix_bit) == 0]\r\n            children_1 = [c for c in children if get_bitfield_bit(c, prefix_bit) == 1]\r\n            bit_0_votes = sum([get_vote_count(c) for c in children_0])\r\n            bit_1_votes = sum([get_vote_count(c) for c in children_1])\r\n            if bit_0_votes > bit_1_votes:\r\n                children = children_0\r\n            else:\r\n                children = children_1\r\n            prefix_bit += 1\r\n        head = children[0]\r\n```\r\n\r\n\r\nBut for CBC purposes, we need to have LMD GHOST not just be a suggestion, but rather an enforced rule; that is, _a block is not valid unless its parent is the result of executing the LMD GHOST fork choice rule given all the evidence the block knows about_. We need to keep track of some extra data to make it possible to verify this.\r\n\r\n### State changes\r\n\r\nIn the state, we make the following changes:\r\n\r\n* Replace the `validator_balances` list with a `validator_volatile_data` list consisting of an object `ValidatorVolatileData = {fractional_balance: uint32, last_agreement_height: uint32, last_agreement_bits: uint8, last_at_height: uint32}`.\r\n* Extend `latest_block_roots` to last one year (ie. ~`2**22` entries).\r\n* Add a list `off_chain_block_hashes = List[HashRecord]` where `HashRecord = {\"hash\": \"bytes32\", \"agreement_height\": \"uint32\", \"agreement_bits\": \"uint8\"}`.\r\n* Add a list `balance_agreeing_upto: List[List[int]]`, initialized as `[[] for _ in range(LMD_GHOST_LOOKBACK)]`\r\n* Add a list `balance_at: List[int]`, initialized as `[0 for _ in range(LMD_GHOST_LOOKBACK)]`\r\n* To each `ValidatorRecord`, add: `activation_init_epoch` and `exit_init_epoch` (both initialized to `FAR_FUTURE_EPOCH`), and remove `exit_initiated`.\r\n\r\nWe add a new helper:\r\n\r\n```python\r\ndef get_agreeing_bits(hash1: bytes32, hash2: bytes32) -> int:\r\n    i = 0\r\n    while i < 256:\r\n        if get_bitfield_bit(hash1, i) != get_bitfield_bit(hash2, i):\r\n            return i\r\n        i += 1\r\n    return 256\r\n```\r\n\r\nWe add a new method for submitting an off-chain block header:\r\n\r\n```python\r\ndef submit_offchain_block_header(header: Proposal, state: BeaconState):\r\n    if header.parent_root in state.latest_block_roots:\r\n        state.off_chain_block_hashes.append(HashRecord(\r\n            hash=tree_hash_root(header),\r\n            agreement_height=header.slot - 1,\r\n            agreement_bits=get_agreeing_bits(get_block_root(parent_slot + 1),\r\n                                             tree_hash_root(header))\r\n        ))\r\n    else:\r\n        for rec in state.off_chain_block_hashes:\r\n            if rec.hash == header.parent_root:\r\n                state.off_chain_block_hashes.append(HashRecord(\r\n                    hash=tree_hash_root(header),\r\n                    agreement_height=rec.agreement_height\r\n                    agreement_bits=rec.agreement_bits\r\n                ))\r\n                return\r\n        raise Exception(\"Could not find parent\")\r\n```\r\n\r\n`off_chain_block_hashes` are removed if their agreement height // 256 is < current slot - 2**22 (ie. after ~1 year).\r\n\r\nWe add three helpers:\r\n\r\n```python\r\ndef two_d_array_get(array, x, y):\r\n    return array[x][y] if y < len(array[x]) else 0\r\n\r\ndef two_d_array_set(array, x, y, value):\r\n    if value != 0 and y >= len(array[x]):\r\n        array[x] += [0] * (y - len(array[x]) + 1)\r\n    if y < len(array[x]):\r\n        array[x] = y\r\n    while len(array[x]) > 0 and array[x][-1] == 0:\r\n        array[x].pop()\r\n``` \r\n\r\n```python\r\ndef adjust_deltas(state: BeaconState, agreement_balance_deltas: Dict[Int -> Int], at_balance_deltas: Dict[Int -> Int]):\r\n    for (slot, bits), delta_balance in agreement_balance_deltas.items():\r\n        existing_balance = two_d_array_get(state.balance_agreeing_upto,\r\n                                           slot % LMD_GHOST_LOOKBACK,\r\n                                           bits)\r\n        two_d_array_set(state.balance_agreeing_upto,\r\n                        slot % LMD_GHOST_LOOKBACK,\r\n                        bits,\r\n                        delta_balance + existing_balance)\r\n    for slot, delta_balance in at_balance_deltas.items():\r\n        state.balance_at[slot % LMD_GHOST_LOOKBACK] += delta_balance\r\n```\r\n\r\nHere is the function for processing a set of attestations:\r\n\r\n```python\r\ndef process_attestations(state: BeaconState, attestations: List[Attestation]):\r\n    # Map of virtual agreement height -> balance delta (validators that will newly have that VAH\r\n    # minus validators that will no longer have that VAH)\r\n    agreement_balance_deltas = {}\r\n    # Map of virtual at height -> balance delta (same logic)\r\n    at_balance_deltas = {}\r\n    # For each attestation...\r\n    for attestation in attestations:\r\n        verify_attestation(state, attestation)\r\n        # For each participant in the attestation....\r\n        for validator_index in get_attestation_participants(state, attestation.data, attestation.aggregation_bitfield):\r\n            validator = state.validator_registry[validator_index]\r\n            # Previous agreement height and implied at height\r\n            previous_agreement_height = validator.last_agreement_height\r\n            previous_agreement_bits = validator.last_agreement_bits\r\n            previous_at_height = validator.last_at_height\r\n            # New attestation is on this chain\r\n            if attestation.data.beacon_block_root in state.latest_block_roots:\r\n                next_agreement_height = next_at_height\r\n                next_agreement_bits = 0\r\n                next_at_height = attestation.data.slot * 256\r\n            # New attestation is not on this chain\r\n            else:\r\n                found = False\r\n                for rec in state.off_chain_block_hashes:\r\n                    if attestation.data.beacon_block_root == rec.hash:\r\n                        next_agreement_height = rec.virtual_agreement_height\r\n                        next_agreement_bits = rec.virtual_agreement_bits\r\n                        next_at_height = attestation.slot\r\n                        found = True\r\n                if not found:\r\n                    raise Exception(\"Attestation on an unknown hash\")\r\n            # Adjust the validator data\r\n            validator.last_agreement_height = next_agreement_height\r\n            validator.last_agreement_bits = next_agreement_bits\r\n            validator.last_at_height = next_at_height\r\n            # Use rounded balance for fork choice rule (as it adjusts infrequently)\r\n            balance = validator.rounded_balance\r\n            # Adjust the delta maps\r\n            prev_key = (previous_agreement_height, previous_agreement_bits)\r\n            next_key = (next_agreement_height, next_agreement_bits)\r\n            agreement_balance_deltas[prev_key] = agreement_balance_deltas.get(prev_key, 0) - balance\r\n            agreement_balance_deltas[next_key] = agreement_balance_deltas.get(next_key, 0) + balance\r\n            at_balance_deltas[previous_at_height] = at_balance_deltas.get(previous_at_height, 0) - balance\r\n            at_balance_deltas[next_at_height] = at_balance_deltas.get(next_at_height, 0) + balance\r\n    adjust_deltas(state, agreement_balance_deltas, at_balance_deltas)\r\n```\r\n\r\nHere is the function to call every slot for every validator whose rounded balance gets adjusted:\r\n\r\n```python\r\ndef process_balance_updates(state: BeaconState, prev_balances: List[int]):\r\n    # New validator rounded balances\r\n    new_balances = [v.rounded_balance for v in state.validator_registry]\r\n    # Map of agreement/at height -> balance delta\r\n    agreement_deltas = {}\r\n    at_deltas = {}\r\n    for i in range(len(prev_balances)):\r\n        # If the rounded balance changed....\r\n        if prev_balances[i] != new_balances[i]:\r\n            # Agreement height and implied at height\r\n            agreement_key = (validator.last_agreement_height, validator.last_agreement_bits)\r\n            at_height = validator.last_at_height\r\n            # Round balance delta\r\n            balance_delta = new_balances[i] - prev_balances[i]\r\n            # Adjust the delta maps\r\n            agreement_deltas[agreement_key] = agreement_deltas.get(agreement_key, 0) + balance_delta\r\n            at_deltas[at_height] = at_deltas.get(at_height, 0) + balance_delta\r\n    adjust_deltas(state, agreement_deltas, at_deltas)\r\n```\r\n\r\nHere is the function to check if a block is valid under the CBC validity condition; this should be run after processing attestations:\r\n\r\n```python\r\ndef verify_cbc(state: BeaconState) -> bool:\r\n    pivot = state.slot % LMD_GHOST_LOOKBACK\r\n    balance_agreeing = state.balance_agreeing_upto[pivot:] + state.balance_agreeing_upto[:pivot]\r\n    balance_at = state.balance_at[pivot:] + state.balance_at[:pivot]\r\n    flattened_balance_agreeing = [\r\n        two_d_array_get(balance_agreeing, i // 256, i % 256) for i in range(LMD_GHOST_LOOKBACK * 256)\r\n    ]\r\n    for i in range(LMD_GHOST_LOOKBACK * 256):\r\n        balance_at_this_point = balance_at[i // 256] if i % 256 == 0 else 0\r\n        assert (\r\n            sum(flattened_balance_agreeing[i+1:]) >=\r\n             (flattened_balance_agreeing[i] - balance_at_this_point) * (i / (LMD_GHOST_LOOKBACK * 256)) // 2\r\n        )\r\n```\r\n\r\nFor example, suppose `LMD_GHOST_LOOKBACK = 4` and `block.slot % LMD_GHOST_LOOKBACK = 1` and `agreement_height = [[10, 20], [30, 80, 50], [], [40]]`, where instead of 256 bits every hash has three bits.\r\n\r\nThen, `agreement_height` rotated would be `[[30, 80, 50], [], [40], [10, 20]`, the flattened version is `[30, 80, 50, 0, 0, 0, 40, 0, 0, 10, 20, 0]` and the partial sums are `[230, 200, 120, 70, 70, 70, 70, 30, 30, 30, 20, 0]` - which may be invalid unless at least there are >= 10 votes `at` the same position as the 40.\r\n\r\nNote that as a matter of efficient implementation, the sums need not be recalculated each time; nodes can maintain a sum tree locally (see description of sum trees in https://ethresear.ch/t/bitwise-lmd-ghost/4749) and use the binary search algorithm to verify correctness. One can compute a rotated sumtree from an unrotated sumtree in real time as follows: for a rotation by `r` of a list of length `L`, `rotated_sum[i] = sum[i] - sum[r] if i <= r else sum[i] + sum[0] -sum[r]`. One can also generally avoid storing most of the zeroes in high-order bits of each set of 256, and one can avoid a linear pass to verify compliance by doing a repeated binary search to find each position where the remaining sum drops below half of the previous remaining sum.\r\n\r\n### Slashing condition enforcement\r\n\r\nWe only need two slashing conditions, for these two cases:\r\n\r\n* A validator signs two different blocks in the same epoch\r\n* A validator signs a block with a slot number of C, in which their `last_at_height` is A, and they also sign a block with a slot number B, with A < B < C\r\n\r\nFor the first slashing condition, we can reuse code from the FFG beacon chain as is. For the second, we need to create a SlashingProof object which contains the parameters:\r\n\r\n```python\r\n{\r\n    index: uint64,\r\n    data1: SlashableAttestationData,\r\n    data2: SlashableAttestationData,\r\n    merkle_branch_bottom: ValidatorVolatileData,\r\n    merkle_branch_in_volatile_data_tree: [hash32],\r\n    block_header_1: BlockHeader,\r\n    block_header_2: BlockHeader,\r\n}\r\n```\r\n\r\nSee [here](https://github.com/ethereum/eth2.0-specs/blob/master/specs/core/0_beacon-chain.md#slashablevotedata) for the definition of `SlashableVoteData`. Verifying this would entail verifying:\r\n\r\n* Both `SlashableVoteData` objects pass a `verify_slashable_vote_data` check\r\n* `index` is part of `intersection(union(data1.custody_bit_0_indices, data1.custody_bit_1_indices), union(data2.custody_bit_0_indices, data2.custody_bit_1_indices))`\r\n* `verify_merkle_branch(leaf=proof.merkle_branch_bottom, branch=proof.merkle_branch_in_volatile_data_tree`, index=proof.index, root=proof.block_header_1.validator_volatile_data_root)`\r\n* `hash(block_header_1) == data1.data` and `hash(block_header_2) == data2.data`\r\n* `block_header_1.slot // EPOCH_LENGTH > block_header_2.slot // EPOCH_LENGTH > merkle_branch_bottom.last_at_height // EPOCH_LENGTH`\r\n\r\nNote that this is almost but not quite sufficient. The reason is that an attacker could make a signature on the main chain at height H1, then sign on a fake off-chain block _that only has a header_ at height H2, include that signature in the main chain and sign at height H3, then keep signing on the main chain, and then sign a message on another chain at a height between H2 and H3. The fact that the Merkle branch for height H2 is absent means that there is no way to catch and penalize the validator. We can solve this in two ways:\r\n\r\n1. Add an additional challenge-response game where anyone can require any validator to publish the Merkle root for their own index for any signature that they participated in\r\n2. Require clients to actually verify the off-chain blocks before they accept any chain that references them, and make this a validity rule for the chain\r\n\r\n(1) could be extended into a general \"proof of custody of beacon chain state\" mechanism, which may also be useful for other reasons.\r\n\r\n### Changes to deposit/withdraw logic\r\n\r\nWe remove the exit queue and replace it with a (deposit+withdrawal) queue. That is, we set `MAX_BALANCE_CHURN_QUOTIENT` to equal `LMD_GHOST_LOOKBACK`, and instead of running through validators in order, we pre-sort the indices:\r\n\r\n```python\r\n    # Sort validators by time they've been waiting for a transition\r\n    def get_time_waiting(index):\r\n        if state.validator_registry[index].activation_epoch == FAR_FUTURE_EPOCH:\r\n            return get_current_epoch(state) - state.validator_registry[index].activation_init_epoch\r\n        elif state.exit_epoch == FAR_FUTURE_EPOCH:\r\n            return get_current_epoch(state) - state.validator_registry[index].exit_init_epoch\r\n        else:\r\n            return -1\r\n    # Admit and exit validators within the allowable balance churn\r\n    balance_churn = 0\r\n    sorted_indices = sorted(list(range(len(state.validator_registry))), key=lambda index: -get_time_waiting(index))\r\n    for index in sorted_indices:\r\n        validator = state.validator_registry[index]\r\n        if validator.activation_epoch == FAR_FUTURE_EPOCH and state.activation_init_epoch < FAR_FUTURE_EPOCH:\r\n            # Check the balance churn would be within the allowance\r\n            balance_churn += get_effective_balance(state, index)\r\n            if balance_churn > max_balance_churn:\r\n                break\r\n            # Activate validator\r\n            activate_validator(state, index, is_genesis=False)\r\n        elif validator.activation_epoch == FAR_FUTURE_EPOCH and state.exit_init_epoch < FAR_FUTURE_EPOCH:\r\n            # Check the balance churn would be within the allowance\r\n            balance_churn += get_effective_balance(state, index)\r\n            if balance_churn > max_balance_churn:\r\n                break\r\n            # Exit validator\r\n            exit_validator(state, index)\r\n```\r\n \r\nReplace `exit_initiated = True` with `exit_init_epoch = get_current_epoch(state)`.\r\n\r\n### Sections to remove\r\n\r\n* The exit mechanism (instead, `process_exit_queue` simply runs `prepare_validator_for_withdrawal` on all validators that pass the `eligible` check)\r\n* Justification\r\n* Finalization",
  "closed_by": {
    "login": "JustinDrake",
    "id": 731743,
    "node_id": "MDQ6VXNlcjczMTc0Mw==",
    "avatar_url": "https://avatars.githubusercontent.com/u/731743?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/JustinDrake",
    "html_url": "https://github.com/JustinDrake",
    "followers_url": "https://api.github.com/users/JustinDrake/followers",
    "following_url": "https://api.github.com/users/JustinDrake/following{/other_user}",
    "gists_url": "https://api.github.com/users/JustinDrake/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/JustinDrake/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/JustinDrake/subscriptions",
    "organizations_url": "https://api.github.com/users/JustinDrake/orgs",
    "repos_url": "https://api.github.com/users/JustinDrake/repos",
    "events_url": "https://api.github.com/users/JustinDrake/events{/privacy}",
    "received_events_url": "https://api.github.com/users/JustinDrake/received_events",
    "type": "User",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/701/reactions",
    "total_count": 4,
    "+1": 4,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/701/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/490843525",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/701#issuecomment-490843525",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/701",
    "id": 490843525,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ5MDg0MzUyNQ==",
    "user": {
      "login": "nrryuya",
      "id": 22876645,
      "node_id": "MDQ6VXNlcjIyODc2NjQ1",
      "avatar_url": "https://avatars.githubusercontent.com/u/22876645?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/nrryuya",
      "html_url": "https://github.com/nrryuya",
      "followers_url": "https://api.github.com/users/nrryuya/followers",
      "following_url": "https://api.github.com/users/nrryuya/following{/other_user}",
      "gists_url": "https://api.github.com/users/nrryuya/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/nrryuya/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/nrryuya/subscriptions",
      "organizations_url": "https://api.github.com/users/nrryuya/orgs",
      "repos_url": "https://api.github.com/users/nrryuya/repos",
      "events_url": "https://api.github.com/users/nrryuya/events{/privacy}",
      "received_events_url": "https://api.github.com/users/nrryuya/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-05-09T10:10:26Z",
    "updated_at": "2019-05-09T10:10:26Z",
    "author_association": "CONTRIBUTOR",
    "body": "Thank you for writing this! This is a really beautiful proposal. \r\nI'd like to ask a few questions.\r\n\r\n(1) About  `LMD_GHOST_LOOKBACK`, these are correct?\r\n- Execute the fork-choice from the block at `LMD_GHOST_LOOKBACK`-th slot from the current slot\r\n    - This basically corresponds to the weakly subjective checkpointing which is usual for chain-based PoS\r\n    - Hence, `LMD_GHOST_LOOKBACK` is 2**22, which is equal to the lifespan of `latest_block_roots` and `off_chain_block_hashes`\r\n- About validator rotation, allow exits up to `1/LMD_GHOST_LOOKBACK` (in balance) for every slot\r\n  - Therefore, it takes `1/LMD_GHOST_LOOKBACK` slot at least for a validator set to change completely\r\n\r\n(2) About bitwise LMD GHOST under validator rotation, what is the rationale of the `(i / (LMD_GHOST_LOOKBACK * 256))` slacking (which seems to be modified from your [previous proposal](https://github.com/ethereum/eth2.0-specs/issues/433)) and how it affects safety argument? \r\nAlso, how do you think the approach where exits are allowed only at every N block-heights and bitwise LMD GHOST is executed several times without slacking?\r\n\r\n(3) About slashing, \r\n>Note that this is almost but not quite sufficient\r\n\r\nI don't understand the problem here. The `last_virtual_at_height` of the attacker is H2 in the block which he attests to at H3 so we can create the slashing proof with the attestation at the slot between H2 and H3?\r\n\r\nAlso, In `verify_cbc`, I guess these are typos:\r\n- `two_d_array_get(agreement_balance_deltas` -> `two_d_array_get(balance_agreeing`\r\n- `flattened_balance_agreeing[i]` -> `sum(flattened_balance_agreeing[i:])`\r\n\r\nThank you in advance :pray:",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/490843525/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/493409463",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/701#issuecomment-493409463",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/701",
    "id": 493409463,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ5MzQwOTQ2Mw==",
    "user": {
      "login": "vbuterin",
      "id": 2230894,
      "node_id": "MDQ6VXNlcjIyMzA4OTQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2230894?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vbuterin",
      "html_url": "https://github.com/vbuterin",
      "followers_url": "https://api.github.com/users/vbuterin/followers",
      "following_url": "https://api.github.com/users/vbuterin/following{/other_user}",
      "gists_url": "https://api.github.com/users/vbuterin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vbuterin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vbuterin/subscriptions",
      "organizations_url": "https://api.github.com/users/vbuterin/orgs",
      "repos_url": "https://api.github.com/users/vbuterin/repos",
      "events_url": "https://api.github.com/users/vbuterin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vbuterin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-05-17T10:41:45Z",
    "updated_at": "2019-05-17T10:41:45Z",
    "author_association": "MEMBER",
    "body": "> This basically corresponds to the weakly subjective checkpointing which is usual for chain-based PoS\r\n\r\nYes.\r\n\r\n> Hence, LMD_GHOST_LOOKBACK is 2**22, which is equal to the lifespan of latest_block_roots and off_chain_block_hashes\r\n\r\nYes.\r\n\r\n>    About validator rotation, allow exits up to 1/LMD_GHOST_LOOKBACK (in balance) for every slot . Therefore, it takes 1/LMD_GHOST_LOOKBACK slot at least for a validator set to change completely\r\n\r\nI think you mean LMD_GHOST_LOOKBACK slots, not 1/LMD_GHOST_LOOKBACK slots. But yes.\r\n\r\n> (2) About bitwise LMD GHOST under validator rotation, what is the rationale of the (i / (LMD_GHOST_LOOKBACK * 256)) slacking (which seems to be modified from your previous proposal) and how it affects safety argument?\r\n\r\nThe rationale for having the slacking is the same as it was before: to account for the possibility that the ancestor of a block is actually valid even if it does not look valid from the point of view of the current validator set, because the validator set changed in the meantime. The // 256 is there to account for the fact that the data structure above uses 256 items per block height.\r\n\r\n>  Also, how do you think the approach where exits are allowed only at every N block-heights and bitwise LMD GHOST is executed several times without slacking?\r\n\r\nDefinitely an interesting idea! Though the \"several\" would be big; eg. if N = 1 day (probably the best we can do for usability reasons) and LMD_GHOST_LOOKBACK = 8 months that's still ~240 times.\r\n\r\n> The last_virtual_at_height of the attacker is H2 in the block which he attests to at H3 so we can create the slashing proof with the attestation at the slot between H2 and H3?\r\n\r\nThe problem is that it's not guaranteed that the block at H2 is fully available. The body of that particular block could be missing, making the slashing unprovable, as the information of the `last_virtual_at_height` in the block would not be there to be put into the slashing proof.\r\n\r\n> two_d_array_get(agreement_balance_deltas -> two_d_array_get(balance_agreeing\r\n\r\nYep! Typo\r\n\r\n> flattened_balance_agreeing[i] -> sum(flattened_balance_agreeing[i:])\r\n\r\nI think that actually does need to be [i]. The idea is that we are checking that the balance that forks off from the chain at exactly height i does not exceed the balance that stays in the chain at height i+1.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/493409463/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/493845251",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/701#issuecomment-493845251",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/701",
    "id": 493845251,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ5Mzg0NTI1MQ==",
    "user": {
      "login": "nrryuya",
      "id": 22876645,
      "node_id": "MDQ6VXNlcjIyODc2NjQ1",
      "avatar_url": "https://avatars.githubusercontent.com/u/22876645?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/nrryuya",
      "html_url": "https://github.com/nrryuya",
      "followers_url": "https://api.github.com/users/nrryuya/followers",
      "following_url": "https://api.github.com/users/nrryuya/following{/other_user}",
      "gists_url": "https://api.github.com/users/nrryuya/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/nrryuya/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/nrryuya/subscriptions",
      "organizations_url": "https://api.github.com/users/nrryuya/orgs",
      "repos_url": "https://api.github.com/users/nrryuya/repos",
      "events_url": "https://api.github.com/users/nrryuya/events{/privacy}",
      "received_events_url": "https://api.github.com/users/nrryuya/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-05-20T05:38:51Z",
    "updated_at": "2019-05-20T05:38:51Z",
    "author_association": "CONTRIBUTOR",
    "body": "Thank you for replying!\r\n\r\n>I think you mean LMD_GHOST_LOOKBACK slots, not 1/LMD_GHOST_LOOKBACK slots. But yes.\r\n\r\nYeah, thanks.\r\n\r\n>The problem is that it's not guaranteed that the block at H2 is fully available. The body of that particular block could be missing, making the slashing unprovable, as the information of the last_virtual_at_height in the block would not be there to be put into the slashing proof.\r\n\r\nAh, so I assumed the second approach you described: a block is not valid at the moment unless the referenced (\"justified\") blocks are fully available. Is there any advantage to the challenge-response scheme?\r\n\r\nIn the first place, I'm also assuming that every block includes attestations for off-chain blocks or points to off-chain blocks themselves as CBC's \"justification\" so that receivers can verify `validator_volatile_data_root`. Is it correct?\r\n\r\n>I think that actually does need to be [i]. The idea is that we are checking that the balance that forks off from the chain at exactly height i does not exceed the balance that stays in the chain at height i+1.\r\n\r\nHmm, so I assumed that `sum(flattened_balance_agreeing[i:])` is `Agreeing[h]`,  `balance_at_this_point`is`at[h]` and `i` is `h` in [your post](https://ethresear.ch/t/bitwise-lmd-ghost/4749) so the validity condition `Agreeing[h + 1] >= (Agreeing[h] - at[h]) * 1/2` is `sum(flattened_balance_agreeing[h + 1:]) >= (sum(flattened_balance_agreeing[h:]) - balance_at_this_point) / 2`  but it's not correct? (From `process_attestations`, `balance_at[i]` seems to be the weight of validators whose latest attestation is at `i` regardless of whether the validator is agreeing or not.)\r\n\r\nOther minor corrections:\r\n- In `adjust_deltas`, the names of variables `agreement_delta_map` and `at_delta_map` should be  `agreement_balance_deltas` and `at_balance_deltas` respectively.\r\n- Since `ValidatorVolatileData` only has `last_at_height` instead of `last_virtual_at_height`, the second slashing condition should be \"A validator signs a block with a slot number of C, in which their *last_at_height* is A, and...\"\r\n- Also, the last validity condition of `SlashingProof` should be `block_header_2.slot // EPOCH_LENGTH > merkle_branch_bottom.last_at_height // EPOCH_LENGTH`  (I'm not sure why there are `// EPOCH_LENGTH`)",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/493845251/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/495628558",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/701#issuecomment-495628558",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/701",
    "id": 495628558,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ5NTYyODU1OA==",
    "user": {
      "login": "vbuterin",
      "id": 2230894,
      "node_id": "MDQ6VXNlcjIyMzA4OTQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2230894?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vbuterin",
      "html_url": "https://github.com/vbuterin",
      "followers_url": "https://api.github.com/users/vbuterin/followers",
      "following_url": "https://api.github.com/users/vbuterin/following{/other_user}",
      "gists_url": "https://api.github.com/users/vbuterin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vbuterin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vbuterin/subscriptions",
      "organizations_url": "https://api.github.com/users/vbuterin/orgs",
      "repos_url": "https://api.github.com/users/vbuterin/repos",
      "events_url": "https://api.github.com/users/vbuterin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vbuterin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-05-24T13:29:26Z",
    "updated_at": "2019-05-24T13:29:26Z",
    "author_association": "MEMBER",
    "body": "> Ah, so I assumed the second approach you described: a block is not valid at the moment unless the referenced (\"justified\") blocks are fully available. Is there any advantage to the challenge-response scheme?\r\n\r\nThe challenge response scheme approach allows us to keep the changes to purely within block validation rules, not changing the block acceptance rules at all. Not sure how valuable this is though.\r\n\r\n> In the first place, I'm also assuming that every block includes attestations for off-chain blocks or points to off-chain blocks themselves as CBC's \"justification\" so that receivers can verify validator_volatile_data_root\r\n\r\nEven in the current ethereum, every block includes attestations for off-chain blocks.\r\n\r\n> Hmm, so I assumed that sum(flattened_balance_agreeing[i:]) is Agreeing[h], balance_at_this_pointisat[h] and i is h in your post so the validity condition Agreeing[h + 1] >= (Agreeing[h] - at[h]) * 1/2 is sum(flattened_balance_agreeing[h + 1:]) >= (sum(flattened_balance_agreeing[h:]) - balance_at_this_point) / 2 but it's not correct? (From process_attestations, balance_at[i] seems to be the weight of validators whose latest attestation is at i regardless of whether the validator is agreeing or not.)\r\n\r\n`flattened_balance_agreeing` is derived from `balance_agreeing_upto`, which is an array that stores the total ETH of validators whose latest message _forked off_ from the current chain at a given slot. Updating `balance_agreeing_upto` is done by `process_attestations` and `adjust_deltas`.\r\n\r\nAnother way to look at the problem is, suppose `balance_at_this_point` and the slack are both zero. Then, the desired goal is to check the total agreeing balance _after_ the current point (ie. attestations that don't fork off at the current point) exceeds the balance that _does_ fork off at the current point. Hence `sum(flattened_balance_agreeing[i+1:]) >= flattened_balance_agreeing[i]` in the case where those other two terms are zero.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/495628558/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/520212799",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/701#issuecomment-520212799",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/701",
    "id": 520212799,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUyMDIxMjc5OQ==",
    "user": {
      "login": "nrryuya",
      "id": 22876645,
      "node_id": "MDQ6VXNlcjIyODc2NjQ1",
      "avatar_url": "https://avatars.githubusercontent.com/u/22876645?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/nrryuya",
      "html_url": "https://github.com/nrryuya",
      "followers_url": "https://api.github.com/users/nrryuya/followers",
      "following_url": "https://api.github.com/users/nrryuya/following{/other_user}",
      "gists_url": "https://api.github.com/users/nrryuya/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/nrryuya/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/nrryuya/subscriptions",
      "organizations_url": "https://api.github.com/users/nrryuya/orgs",
      "repos_url": "https://api.github.com/users/nrryuya/repos",
      "events_url": "https://api.github.com/users/nrryuya/events{/privacy}",
      "received_events_url": "https://api.github.com/users/nrryuya/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-08-11T09:16:08Z",
    "updated_at": "2019-08-11T09:16:08Z",
    "author_association": "CONTRIBUTOR",
    "body": "@vbuterin \r\nIn the ETH2.0 spec, every block can only include attestations within 1 epoch.\r\n\r\nSource: in [`process_attestation`](https://github.com/ethereum/eth2.0-specs/blob/dev/specs/core/0_beacon-chain.md#attestations)\r\n```\r\nassert attestation_slot + MIN_ATTESTATION_INCLUSION_DELAY <= state.slot <= attestation_slot + SLOTS_PER_EPOCH\r\n```\r\n\r\nWithout modifying this, liveness will be lost in a case when some protocol-following validators end up in a situation where their previous attestations are not included in the main chain for 1 epoch  (due to adaptive corruption on block proposer or temporal network failure) and hence they can not justify their previous attestations.\r\n\r\nIn the first place, the rationale of the limit of attestation inclusion is to set the upper bound of the cost of block verification, right?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/520212799/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/617162132",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/701#issuecomment-617162132",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/701",
    "id": 617162132,
    "node_id": "MDEyOklzc3VlQ29tbWVudDYxNzE2MjEzMg==",
    "user": {
      "login": "JustinDrake",
      "id": 731743,
      "node_id": "MDQ6VXNlcjczMTc0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/731743?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JustinDrake",
      "html_url": "https://github.com/JustinDrake",
      "followers_url": "https://api.github.com/users/JustinDrake/followers",
      "following_url": "https://api.github.com/users/JustinDrake/following{/other_user}",
      "gists_url": "https://api.github.com/users/JustinDrake/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JustinDrake/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JustinDrake/subscriptions",
      "organizations_url": "https://api.github.com/users/JustinDrake/orgs",
      "repos_url": "https://api.github.com/users/JustinDrake/repos",
      "events_url": "https://api.github.com/users/JustinDrake/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JustinDrake/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-04-21T12:56:57Z",
    "updated_at": "2020-04-21T12:56:57Z",
    "author_association": "MEMBER",
    "body": "Closing this issue because the details are becoming increasingly staleâ€”the discussion can continue on ethresear.ch or hackmd. CBCfication is still part of [the 5-10 year roadmap](https://twitter.com/VitalikButerin/status/1240365047421054976) likely after we've nailed the execution model in phase 2.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/617162132/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
