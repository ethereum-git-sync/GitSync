{
  "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/702",
  "repository_url": "https://api.github.com/repos/ethereum/consensus-specs",
  "labels_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/702/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/702/comments",
  "events_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/702/events",
  "html_url": "https://github.com/ethereum/consensus-specs/issues/702",
  "id": 415449555,
  "node_id": "MDU6SXNzdWU0MTU0NDk1NTU=",
  "number": 702,
  "title": "Things to decide for phase 2",
  "user": {
    "login": "vbuterin",
    "id": 2230894,
    "node_id": "MDQ6VXNlcjIyMzA4OTQ=",
    "avatar_url": "https://avatars.githubusercontent.com/u/2230894?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/vbuterin",
    "html_url": "https://github.com/vbuterin",
    "followers_url": "https://api.github.com/users/vbuterin/followers",
    "following_url": "https://api.github.com/users/vbuterin/following{/other_user}",
    "gists_url": "https://api.github.com/users/vbuterin/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/vbuterin/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/vbuterin/subscriptions",
    "organizations_url": "https://api.github.com/users/vbuterin/orgs",
    "repos_url": "https://api.github.com/users/vbuterin/repos",
    "events_url": "https://api.github.com/users/vbuterin/events{/privacy}",
    "received_events_url": "https://api.github.com/users/vbuterin/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 1063052501,
      "node_id": "MDU6TGFiZWwxMDYzMDUyNTAx",
      "url": "https://api.github.com/repos/ethereum/consensus-specs/labels/general:RFC",
      "name": "general:RFC",
      "color": "00D1B2",
      "default": false,
      "description": "Request for Comments"
    },
    {
      "id": 1252242617,
      "node_id": "MDU6TGFiZWwxMjUyMjQyNjE3",
      "url": "https://api.github.com/repos/ethereum/consensus-specs/labels/phase2",
      "name": "phase2",
      "color": "90B44B",
      "default": false,
      "description": ""
    }
  ],
  "state": "open",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 8,
  "created_at": "2019-02-28T05:06:46Z",
  "updated_at": "2021-07-05T15:07:41Z",
  "closed_at": null,
  "author_association": "MEMBER",
  "active_lock_reason": null,
  "body": "* **Virtual machine**\r\n  * Decide definitely doing EWASM (default)?\r\n  * What does the FFI look like?\r\n  * How is code serialized? Doing any fancy AST merklization?\r\n* **Cross-shard message structure**.\r\n  * Here is a possible design with some details: https://ethresear.ch/t/phase-2-pre-spec-cross-shard-mechanics/4970\r\n  * Mechanics: cross-shard messages, contract yanking\r\n  * Decide we're not doing layer 1 synchronous cross-shard calls and leaving it to layer 2 (default) or do something else?\r\n* **Contract storage structure**\r\n  * Linear code, linear storage, max combined size 12kb (to fit a yank into a single block) ?\r\n* **Contract addressing**\r\n  * Default approach: CREATE2 for everything\r\n  * Possible alternative: optional sequential addresses for contract creation (rationale: with much smaller addresses, using libraries may be much more efficient)\r\n* **Access lists**\r\n  * Total (must specify all addresses) vs partial (can specify prefixes) vs none at all\r\n* **Account abstraction model**\r\n  * https://ethresear.ch/t/tradeoffs-in-account-abstraction-proposals/263\r\n  * https://ethresear.ch/t/maximally-simple-account-abstraction-without-gas-refunds/5007\r\n  * Major tradeoff: do we abstract nonces or not? That is, do we keep in-protocol nonce-checking of transactions or do we leave that to the contract code?\r\n    * Rationale for abstraction: simpler protocol; also prevents complexities arising from interaction between multiple users attempting withdrawal from one contract at the same time, where N-1 of them must resend with a higher nonce, also removes need to worry about replay prevention in the hibernation/waking cases in-protocol\r\n    * Rationale for non-abstraction: potential for more guarantees for network peers; preserves invariant that any given txhash appears only once in a chain\r\n* **Gas cost model**\r\n  * Computation\r\n  * Data\r\n  * Access: charge per Merkle branch, don't charge if the Merkle branch has already been used in that block?\r\n  * Adopt fee market reform proposal from https://ethresear.ch/t/draft-position-paper-on-resource-pricing/2838 ?\r\n* **Storage fees**\r\n  * https://ethresear.ch/t/a-minimal-state-execution-proposal/4445\r\n  * https://ethresear.ch/t/state-fees-formerly-state-rent-pre-eip-proposal-version-3/4996\r\n  * Hibernation and waking: https://ethresear.ch/t/cross-shard-receipt-and-hibernation-waking-anti-double-spending/4748 (referenced in https://ethresear.ch/t/phase-2-pre-spec-cross-shard-mechanics/4970)\r\n  * Decide on fixed fee?\r\n    * Note: even with a fixed fee, there is an implied cap on the storage size of each shard because of gas limits (at least, this is if we charge a gas cost that scales linearly with TTL extension)\r\n\r\nWhat is the above missing?",
  "closed_by": null,
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/702/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/702/timeline",
  "performed_via_github_app": null,
  "state_reason": null
}
[
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/468248233",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/702#issuecomment-468248233",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/702",
    "id": 468248233,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2ODI0ODIzMw==",
    "user": {
      "login": "axic",
      "id": 20340,
      "node_id": "MDQ6VXNlcjIwMzQw",
      "avatar_url": "https://avatars.githubusercontent.com/u/20340?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/axic",
      "html_url": "https://github.com/axic",
      "followers_url": "https://api.github.com/users/axic/followers",
      "following_url": "https://api.github.com/users/axic/following{/other_user}",
      "gists_url": "https://api.github.com/users/axic/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/axic/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/axic/subscriptions",
      "organizations_url": "https://api.github.com/users/axic/orgs",
      "repos_url": "https://api.github.com/users/axic/repos",
      "events_url": "https://api.github.com/users/axic/events{/privacy}",
      "received_events_url": "https://api.github.com/users/axic/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-02-28T12:03:37Z",
    "updated_at": "2019-02-28T12:03:37Z",
    "author_association": "MEMBER",
    "body": "I think this looks like a great list to start the discussion!\r\n\r\nWe have already started collecting ideas regarding ewasm here: https://github.com/ewasm/design/issues. I think some of these can be applied to the \"Eth1.x\" version of ewasm, but definitely don't see any reason they couldn't be applied to Eth2.0.\r\n\r\nRegarding contract addressing:\r\n> * Possible alternative: optional sequential addresses for contract creation (rationale: with much smaller addresses, using libraries may be much more efficient)\r\n\r\nWe are exploring \"contract linking\" in its various forms as an alternative to this. That would eliminate \"calls\" needed to interact with libraries.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/468248233/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/468261519",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/702#issuecomment-468261519",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/702",
    "id": 468261519,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2ODI2MTUxOQ==",
    "user": {
      "login": "vbuterin",
      "id": 2230894,
      "node_id": "MDQ6VXNlcjIyMzA4OTQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2230894?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vbuterin",
      "html_url": "https://github.com/vbuterin",
      "followers_url": "https://api.github.com/users/vbuterin/followers",
      "following_url": "https://api.github.com/users/vbuterin/following{/other_user}",
      "gists_url": "https://api.github.com/users/vbuterin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vbuterin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vbuterin/subscriptions",
      "organizations_url": "https://api.github.com/users/vbuterin/orgs",
      "repos_url": "https://api.github.com/users/vbuterin/repos",
      "events_url": "https://api.github.com/users/vbuterin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vbuterin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-02-28T12:52:37Z",
    "updated_at": "2019-02-28T12:52:37Z",
    "author_association": "MEMBER",
    "body": "> That would eliminate \"calls\" needed to interact with libraries.\r\n\r\nInteresting! Though this still seems like it would not remove the need for blocks with transactions using that library to need to provide a merkle branch of the code to prove execution statelessly. \r\n\r\nMore broadly, I feel like one question that the EWASM team could help a lot by figuring out is, what kind of an interface would EWASM have with respect to the wider system? The simplest possible interface for example would be the ability to run `execute_code(code, data)`, with the ability to escape internally with `call(address, data)` and `ffi(data)`; then everything else (eg. providing environment variables, reading/writing storage) can be done at the outside level with the FFI.\r\n\r\nIf the interface is settled, then work on everything-outside-the-VM and everything-inside-the-VM could just proceed separately.\r\n\r\nHow far away is the EWASM team from being able to lay down an opinion on this?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/468261519/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/472491881",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/702#issuecomment-472491881",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/702",
    "id": 472491881,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ3MjQ5MTg4MQ==",
    "user": {
      "login": "lrettig",
      "id": 3316532,
      "node_id": "MDQ6VXNlcjMzMTY1MzI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3316532?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/lrettig",
      "html_url": "https://github.com/lrettig",
      "followers_url": "https://api.github.com/users/lrettig/followers",
      "following_url": "https://api.github.com/users/lrettig/following{/other_user}",
      "gists_url": "https://api.github.com/users/lrettig/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/lrettig/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/lrettig/subscriptions",
      "organizations_url": "https://api.github.com/users/lrettig/orgs",
      "repos_url": "https://api.github.com/users/lrettig/repos",
      "events_url": "https://api.github.com/users/lrettig/events{/privacy}",
      "received_events_url": "https://api.github.com/users/lrettig/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-03-13T16:11:31Z",
    "updated_at": "2019-03-13T16:11:31Z",
    "author_association": "NONE",
    "body": "> what kind of an interface would EWASM have with respect to the wider system? The simplest possible interface for example would be the ability to run execute_code(code, data), with the ability to escape internally with call(address, data) and ffi(data)\r\n\r\nIt just struck me that this configuration feels a lot like an operating system with a kernel mode and a user mode--where, in this case, Ewasm contract code is running in user mode and has one or more system calls it can make which switch the context back to \"kernel\" (EEI) mode. I wonder if we shouldn't take design cues from existing operating system design. @axic, @jakelang and others know way more about this topic than I do.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/472491881/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/475978655",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/702#issuecomment-475978655",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/702",
    "id": 475978655,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ3NTk3ODY1NQ==",
    "user": {
      "login": "axic",
      "id": 20340,
      "node_id": "MDQ6VXNlcjIwMzQw",
      "avatar_url": "https://avatars.githubusercontent.com/u/20340?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/axic",
      "html_url": "https://github.com/axic",
      "followers_url": "https://api.github.com/users/axic/followers",
      "following_url": "https://api.github.com/users/axic/following{/other_user}",
      "gists_url": "https://api.github.com/users/axic/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/axic/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/axic/subscriptions",
      "organizations_url": "https://api.github.com/users/axic/orgs",
      "repos_url": "https://api.github.com/users/axic/repos",
      "events_url": "https://api.github.com/users/axic/events{/privacy}",
      "received_events_url": "https://api.github.com/users/axic/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-03-24T17:05:11Z",
    "updated_at": "2019-03-24T18:03:07Z",
    "author_association": "MEMBER",
    "body": "> The simplest possible interface for example would be the ability to run execute_code(code, data), with the ability to escape internally with call(address, data) and ffi(data)\r\n\r\nI am not sure I understand what these functions would do. Is `execute_code` an API for the client to execute contract code? Is it an API exposed to contracts?\r\n\r\nFrom my personal perspective I have two goals:\r\n1) reduce the opportunity for contracts to deal with raw code\r\n2) make use of webassembly imports/exports and reduce the need to come up with arbitrary ABI encoding\r\n\r\nThe main reason for 1) is to simplify the points in the system where code validation must occur.\r\n\r\nWhile I would wish to create really nice high level abstractions with 2), this may be limited by execution overhead that we must also take into consideration.\r\n\r\nDid a semi-long write up of a potential async interface here: https://github.com/ewasm/design/issues/185",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/475978655/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/475983439",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/702#issuecomment-475983439",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/702",
    "id": 475983439,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ3NTk4MzQzOQ==",
    "user": {
      "login": "cdetrio",
      "id": 997681,
      "node_id": "MDQ6VXNlcjk5NzY4MQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/997681?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cdetrio",
      "html_url": "https://github.com/cdetrio",
      "followers_url": "https://api.github.com/users/cdetrio/followers",
      "following_url": "https://api.github.com/users/cdetrio/following{/other_user}",
      "gists_url": "https://api.github.com/users/cdetrio/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cdetrio/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cdetrio/subscriptions",
      "organizations_url": "https://api.github.com/users/cdetrio/orgs",
      "repos_url": "https://api.github.com/users/cdetrio/repos",
      "events_url": "https://api.github.com/users/cdetrio/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cdetrio/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-03-24T17:58:36Z",
    "updated_at": "2019-03-24T17:58:36Z",
    "author_association": "MEMBER",
    "body": "\r\n> what kind of an interface would EWASM have with respect to the wider system? The simplest possible interface for example would be the ability to run execute_code(code, data), with the ability to escape internally with call(address, data) and ffi(data); then everything else (eg. providing environment variables, reading/writing storage) can be done at the outside level with the FFI.\r\n\r\nEwasm is just wasm (it works on any generic wasm engine). It looks like this:\r\n\r\n```\r\nMemory = new WebAssembly.Memory({initial: 10}) // 10 pages at 64kb each\r\nGas = new WebAssembly.Global({value:'i32', mutable:true}, 3141590);\r\nImports = { Memory, \"ethereum\": { Gas, callDataCopy, storageLoad, storageWrite, callToContract, returnDataCopy, finish, revert, useGas } }\r\n\r\ncode = db.get(address) // code has useGas statements that were injected at deployment time\r\ncontractModule = new WebAssembly.instantiate(code, imports).\r\ncontractModule.run(\"main\") // execute_code(code, data)\r\n\r\n// Ewasm host functions implemented here\r\nfunction useGas(amount) {\r\n  Gas.value -= amount\r\n  if (Gas.value < 0) throw \"OOG\"\r\n}\r\nfunction callDataCopy(offset) {\r\n  Memory.set(\"0x00000calldata\", offset)\r\n}\r\nfunction finish(resultOffset) {\r\n  console.log(\"contract call returned data:\", Memory.get(resultOffset))\r\n}\r\nfunction storageLoad() {}\r\nfunction callToContract() {} // call(address, data)\r\n...\r\n```\r\n\r\n> If the interface is settled, then work on everything-outside-the-VM and everything-inside-the-VM could just proceed separately. How far away is the EWASM team from being able to lay down an opinion on this?\r\n\r\nWell the _wasm interface_ is settled (for wasm 1.0). You can do `ret = ffi(data)`, where ret and data are one of four types: i32, i64, f32, f64. In Ewasm (a subset of wasm) you're restricted to i32 and i64. Also, you can pass multiple arguments `ffi(data1, data2, ...)`, but only one return value (wasm 2.0 might support multiple return values). If you want to pass an argument that is more than 32 bits of data, you pass a pointer to a memory location.\r\n\r\nThe _Ewasm interface_ is the set of FFI functions (\"host functions\" in webassembly docs). For Ewasm 1.0, the host functions basically mirror those EVM opcodes that can't be reduced to pure wasm instructions. There's like 32 of them, so the Ewasm 1.0 interface is 32 host functions minus a couple redundancies (e.g. `CALLDATACOPY` => `callDataCopy(resultOffset, dataOffset, size)` and `CALLDATALOAD` => `callDataCopy(resultOffset, dataOffset, 32)`).\r\n\r\nFor Ewasm 2.0, the set of FFI/host-functions would depend on how phase 2 works. Personally, I consider the host functions as outside-the-VM (i.e. host functions are a part of the client, not a part of the VM).\r\n\r\nThen what falls inside-the-VM that can proceed separately? Mainly just making code run faster (optimizing interpreters, making compilers robust) and making sure that code terminates (metering, and reducing the slowdown between metered and unmetered code).",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/475983439/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/486772387",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/702#issuecomment-486772387",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/702",
    "id": 486772387,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ4Njc3MjM4Nw==",
    "user": {
      "login": "benjaminion",
      "id": 20796281,
      "node_id": "MDQ6VXNlcjIwNzk2Mjgx",
      "avatar_url": "https://avatars.githubusercontent.com/u/20796281?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/benjaminion",
      "html_url": "https://github.com/benjaminion",
      "followers_url": "https://api.github.com/users/benjaminion/followers",
      "following_url": "https://api.github.com/users/benjaminion/following{/other_user}",
      "gists_url": "https://api.github.com/users/benjaminion/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/benjaminion/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/benjaminion/subscriptions",
      "organizations_url": "https://api.github.com/users/benjaminion/orgs",
      "repos_url": "https://api.github.com/users/benjaminion/repos",
      "events_url": "https://api.github.com/users/benjaminion/events{/privacy}",
      "received_events_url": "https://api.github.com/users/benjaminion/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-04-25T17:48:16Z",
    "updated_at": "2019-04-25T17:48:16Z",
    "author_association": "CONTRIBUTOR",
    "body": "A relatively minor issue, but learning lessons from Eth 1, how about a mandatory checksum for Eth 2.0 addresses?\r\n\r\n[EIP55](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-55.md) retro-fitted a checksum format to Eth 1, but this is still not fully adopted/enforced. Including a checksum as part of the protocol would be a step forward for user safety. I realise that the Eth 2 address format is not yet specified, [this](https://ethresear.ch/t/phase-2-pre-spec-cross-shard-mechanics/4970) notwithstanding.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/486772387/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/486982861",
    "html_url": "https://github.com/ethereum/consensus-specs/issues/702#issuecomment-486982861",
    "issue_url": "https://api.github.com/repos/ethereum/consensus-specs/issues/702",
    "id": 486982861,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ4Njk4Mjg2MQ==",
    "user": {
      "login": "cdetrio",
      "id": 997681,
      "node_id": "MDQ6VXNlcjk5NzY4MQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/997681?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cdetrio",
      "html_url": "https://github.com/cdetrio",
      "followers_url": "https://api.github.com/users/cdetrio/followers",
      "following_url": "https://api.github.com/users/cdetrio/following{/other_user}",
      "gists_url": "https://api.github.com/users/cdetrio/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cdetrio/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cdetrio/subscriptions",
      "organizations_url": "https://api.github.com/users/cdetrio/orgs",
      "repos_url": "https://api.github.com/users/cdetrio/repos",
      "events_url": "https://api.github.com/users/cdetrio/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cdetrio/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-04-26T08:58:10Z",
    "updated_at": "2019-04-26T08:58:10Z",
    "author_association": "MEMBER",
    "body": "I would argue that Eth2 validator addresses at phase 0 should have mandatory checksums, and the checksum should be verified by the Eth1 deposit contract.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/consensus-specs/issues/comments/486982861/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
