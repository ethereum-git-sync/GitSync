{
  "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/1871",
  "repository_url": "https://api.github.com/repos/ethereum/go-ethereum",
  "labels_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/1871/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/1871/comments",
  "events_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/1871/events",
  "html_url": "https://github.com/ethereum/go-ethereum/issues/1871",
  "id": 109592744,
  "node_id": "MDU6SXNzdWUxMDk1OTI3NDQ=",
  "number": 1871,
  "title": "Streamline API & simplify node setup",
  "user": {
    "login": "obscuren",
    "id": 6264126,
    "node_id": "MDQ6VXNlcjYyNjQxMjY=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6264126?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/obscuren",
    "html_url": "https://github.com/obscuren",
    "followers_url": "https://api.github.com/users/obscuren/followers",
    "following_url": "https://api.github.com/users/obscuren/following{/other_user}",
    "gists_url": "https://api.github.com/users/obscuren/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/obscuren/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/obscuren/subscriptions",
    "organizations_url": "https://api.github.com/users/obscuren/orgs",
    "repos_url": "https://api.github.com/users/obscuren/repos",
    "events_url": "https://api.github.com/users/obscuren/events{/privacy}",
    "received_events_url": "https://api.github.com/users/obscuren/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [

  ],
  "state": "closed",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 2,
  "created_at": "2015-10-03T00:18:48Z",
  "updated_at": "2016-02-10T06:40:17Z",
  "closed_at": "2016-02-10T06:40:13Z",
  "author_association": "MEMBER",
  "active_lock_reason": null,
  "body": "The current design for setting up a node is non-trivial and requires you to\nwrite a lot of custom startup code (e.g. setting up node configuration, gas,\nverbosity, port, etc). I suggest that we allow custom configuration but set any\ndefault value to those that aren't set (e.g. data dir, name, networking, keys).\n\nI suggest we also split out the RPC, IPC and Whisper from the `eth.Backend`\ninterface and move those secondary interface and startup code to a `eth/utility`\npackage which can handle most of the domain specific code.\n\nThe node should also contain a `Com`munication interface that, depending on the\nnode type (i.e. full, light), returns a type allowing you to communicate and\ninterface with the ethereum network and allows you to filter for specific\nethereum related events (i.e. block, log).\n\nCurrently the `eth.Ethereum` is responsibly for just about anything, managing\nkeys, managing whisper, starting stopping filtering system, etc. Most of this\nlogic should instead by moved to the binary implementing the client. For example\nthe `KeyManager` shouldn't be managed by the `Ethereum` node but instead should\nbe managed by the client code. There needs to be a clear separation between\n**client** and **node**.\n### Node\n\nA `Node` is responsible for allowing access to the ethereum state and management\nthereof, setting up the P2P stack (arguable) and allowing direct access to the\nthe higher level `Com` object while keeping its integrity and allow direct\naccess to the lower level APIs of the node.\n\nIt can be argued that the P2P extensions (e.g. Ethereum, Whisper) should not be\nintegrated directly in to the node but instead should be offered to the node as\nservice. \n### Client\n\nA `Client` is what wraps up the node, offers several services to the `Node` and\npossibly allows some level of interaction with the system. An example of a client\nwould be `geth`. While the node offers little flexibility in terms of signing\ntransactions, allowing user confirmations and accesses to the Ethereum internal\nstate due to lack of interfacing, the client should fill that gap by tying the\nseveral systems together and providing the user the need and tools. Managing the\nuser's keys, setting up a REPS and confirmation dialogs are all examples of\ntasks the client should be managing.\n### Comms\n\nInterfacing with the ethereum node can be done in 2 ways; direct interfacing\n(e.g. `TxPool().Add(...)`) or through the `Com`s object (e.g.\n`com.SubmitTransaction(...)`). This will allow for neat portability once we've\nreached stage of full interfacing over IPC.\n\nThe comms object is a wrapper object, an API, over the more complicated \nimplementation specific communication layer. For example direct interfacing\n(offered by the `Node` itself) or IPC. The comms object doesn't need to know how\ndata is offered back and how the internals work, it simply expects data to be\ncommunicated as dictated by the internal protocol (**clarification required**).\n\nPlease see the **Interfacing** section and the **Example** transaction code for\nexamples on how this portability will look like.\n\n```\n[ethereum]--[comms]--[client code]\n```\n\n---\n\nI'll continue to update this issue and in the meantime I recommend anyone to\ncomment on this issue with ideas and suggestions.\n#### Example\n\n``` go\npackage main\n\nimport (\n    \"fmt\"\n    \"math/big\"\n    \"os\"\n\n    \"github.com/ethereum/go-ethereum/common\"\n    \"github.com/ethereum/go-ethereum/core/types\"\n    \"github.com/ethereum/go-ethereum/core/vm\"\n    \"github.com/ethereum/go-ethereum/eth\"\n)\n\nfunc main() {\n    // setup ethereum. the rest of the defaults will be picked for us\n    // (port, host, ipc, etc). Second argument is the type of node; full/light\n    node, err := eth.New(eth.Config{\n        Name:    \"My ethereum node\",\n        Datadir: \"/tmp/001\",\n    }, eth.Light)\n    if err != nil {\n        logger.Fatalln(err)\n    }\n\n    // communication interface. `com` is an interface and depends on the\n    // node type given to `eth.New`. `com` is the basic state accessor\n    com := node.Com()\n    // state interfacing\n    com.GetBalance(common.Address{})\n    com.SetBalance(common.Address{}, big.NewInt(1))\n    com.SetAccountStorage(common.Address{}, common.Hash{}, common.Hash{})\n    // and allow filtering\n    id := com.Filters().AddLogFilter(filters.Log{FromBlock: 0, ToBlock: -1}, func(logs vm.Logs) {\n        fmt.Println(\"get log event\")\n    })\n    id = com.Filters().AddBlockFilter(filters.BlockAny|filters.BlockFork, func(typ filter.BlockEvent, block *types.Block) {\n        fmt.Println(\"block event:\", typ)\n    })\n    // send transactions\n    tx := types.NewTransaction(common.Address{/* to */, big.NewInt(1), big.NewInt(1), []byte{1,2,3})\n    tx = tx.WithSignECDSA(privateKey)\n    com.SubmitTransaction(tx)\n    // or\n    node.TxPool().Add(tx)\n\n    // setup service\n    // HTTP RPC\n    http, err := util.RPCServer(com, remote.Http{\":0\"})\n    if err != nil {\n        logger.Fatalln(err)\n    }\n    rpc.EnableAPIs(remote.APIs{remote.Web3})\n    // IPC RPC\n    ipc, err := util.RPCServer(com, remote.Ipc{\"/path/to\"})\n    if err != nil {\n        logger.Fatalln(err)\n    }\n    ipc.EnableAPIs(remote.APIs{remote.Web3, remote.Admin, remote.Personal})\n\n    // start up whisper\n    whisper, err := util.StartWhisper(node.Net())\n    if err != nil {\n        logger.Fatalln(err)\n    }\n    whisper.Post(\"stuff\")\n\n    swarm, err := util.StartSwarm(com, ipfs.Provider())\n    if err != nil {\n        logger.Fatalln(err)\n    }\n\n    in, err := os.Open(\"/path/to/source\")\n    if err != nil {\n        logger.Fatalln(err)\n    }\n    defer in.Close()\n\n    hash, size := swarm.Copy(swarm, in)\n\n    // get default eventer\n    eventer := node.DefaultEventer()\n    eventer.Post(struct{ T string }{\"my async event\"})\n    eventer.PostSync(struct{ T string }{\"my sync event\"})\n\n    // let eth handle shutdowns\n    eth.WaitForShutdown()\n}\n```\n#### Interfacing\n\n``` go\npackage main\n\nimport (\n    \"github.com/ethereum/go-ethereum/eth/coms\"\n    \"github.com/ethereum/go-ethereum/eth/utility\"\n)\n\nfunc main() {\n    ipc, err := util.RPCClient(com, remote.Ipc{ /* optional path */ })\n    if err != nil {\n        logger.Fatalln(err)\n    }\n    com := coms.New(ipc)\n\n    tx := types.NewTransaction(common.Address{/* to */, big.NewInt(1), big.NewInt(1), []byte{1,2,3})\n    tx = tx.WithSignECDSA(privateKey)\n    com.SubmitTransaction(tx)\n}\n```\n",
  "closed_by": {
    "login": "zelig",
    "id": 769725,
    "node_id": "MDQ6VXNlcjc2OTcyNQ==",
    "avatar_url": "https://avatars.githubusercontent.com/u/769725?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/zelig",
    "html_url": "https://github.com/zelig",
    "followers_url": "https://api.github.com/users/zelig/followers",
    "following_url": "https://api.github.com/users/zelig/following{/other_user}",
    "gists_url": "https://api.github.com/users/zelig/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/zelig/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/zelig/subscriptions",
    "organizations_url": "https://api.github.com/users/zelig/orgs",
    "repos_url": "https://api.github.com/users/zelig/repos",
    "events_url": "https://api.github.com/users/zelig/events{/privacy}",
    "received_events_url": "https://api.github.com/users/zelig/received_events",
    "type": "User",
    "site_admin": false
  },
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/1871/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/1871/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
[
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/145490541",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/1871#issuecomment-145490541",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/1871",
    "id": 145490541,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE0NTQ5MDU0MQ==",
    "user": {
      "login": "Gustav-Simonsson",
      "id": 293096,
      "node_id": "MDQ6VXNlcjI5MzA5Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/293096?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Gustav-Simonsson",
      "html_url": "https://github.com/Gustav-Simonsson",
      "followers_url": "https://api.github.com/users/Gustav-Simonsson/followers",
      "following_url": "https://api.github.com/users/Gustav-Simonsson/following{/other_user}",
      "gists_url": "https://api.github.com/users/Gustav-Simonsson/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Gustav-Simonsson/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Gustav-Simonsson/subscriptions",
      "organizations_url": "https://api.github.com/users/Gustav-Simonsson/orgs",
      "repos_url": "https://api.github.com/users/Gustav-Simonsson/repos",
      "events_url": "https://api.github.com/users/Gustav-Simonsson/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Gustav-Simonsson/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-10-05T10:33:29Z",
    "updated_at": "2015-10-05T10:33:29Z",
    "author_association": "NONE",
    "body": "By default `Node` could setup the P2P stack, and if explicitly given P2P can be skipped (useful for tests) or a custom P2P interface given.\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/145490541/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/182228117",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/1871#issuecomment-182228117",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/1871",
    "id": 182228117,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE4MjIyODExNw==",
    "user": {
      "login": "zelig",
      "id": 769725,
      "node_id": "MDQ6VXNlcjc2OTcyNQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/769725?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/zelig",
      "html_url": "https://github.com/zelig",
      "followers_url": "https://api.github.com/users/zelig/followers",
      "following_url": "https://api.github.com/users/zelig/following{/other_user}",
      "gists_url": "https://api.github.com/users/zelig/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/zelig/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/zelig/subscriptions",
      "organizations_url": "https://api.github.com/users/zelig/orgs",
      "repos_url": "https://api.github.com/users/zelig/repos",
      "events_url": "https://api.github.com/users/zelig/events{/privacy}",
      "received_events_url": "https://api.github.com/users/zelig/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-02-10T06:40:13Z",
    "updated_at": "2016-02-10T06:40:13Z",
    "author_association": "MEMBER",
    "body": "I believe this was implemented by #1970 and subsequent improvements\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/182228117/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
