{
  "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/21337",
  "repository_url": "https://api.github.com/repos/ethereum/go-ethereum",
  "labels_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/21337/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/21337/comments",
  "events_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/21337/events",
  "html_url": "https://github.com/ethereum/go-ethereum/issues/21337",
  "id": 658871683,
  "node_id": "MDU6SXNzdWU2NTg4NzE2ODM=",
  "number": 21337,
  "title": "LES checkpoint question",
  "user": {
    "login": "sidhujag",
    "id": 6238042,
    "node_id": "MDQ6VXNlcjYyMzgwNDI=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6238042?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/sidhujag",
    "html_url": "https://github.com/sidhujag",
    "followers_url": "https://api.github.com/users/sidhujag/followers",
    "following_url": "https://api.github.com/users/sidhujag/following{/other_user}",
    "gists_url": "https://api.github.com/users/sidhujag/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/sidhujag/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/sidhujag/subscriptions",
    "organizations_url": "https://api.github.com/users/sidhujag/orgs",
    "repos_url": "https://api.github.com/users/sidhujag/repos",
    "events_url": "https://api.github.com/users/sidhujag/events{/privacy}",
    "received_events_url": "https://api.github.com/users/sidhujag/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 841716348,
      "node_id": "MDU6TGFiZWw4NDE3MTYzNDg=",
      "url": "https://api.github.com/repos/ethereum/go-ethereum/labels/area:les",
      "name": "area:les",
      "color": "c2e0c6",
      "default": false,
      "description": null
    }
  ],
  "state": "open",
  "locked": false,
  "assignee": {
    "login": "rjl493456442",
    "id": 5959481,
    "node_id": "MDQ6VXNlcjU5NTk0ODE=",
    "avatar_url": "https://avatars.githubusercontent.com/u/5959481?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/rjl493456442",
    "html_url": "https://github.com/rjl493456442",
    "followers_url": "https://api.github.com/users/rjl493456442/followers",
    "following_url": "https://api.github.com/users/rjl493456442/following{/other_user}",
    "gists_url": "https://api.github.com/users/rjl493456442/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/rjl493456442/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/rjl493456442/subscriptions",
    "organizations_url": "https://api.github.com/users/rjl493456442/orgs",
    "repos_url": "https://api.github.com/users/rjl493456442/repos",
    "events_url": "https://api.github.com/users/rjl493456442/events{/privacy}",
    "received_events_url": "https://api.github.com/users/rjl493456442/received_events",
    "type": "User",
    "site_admin": false
  },
  "assignees": [
    {
      "login": "rjl493456442",
      "id": 5959481,
      "node_id": "MDQ6VXNlcjU5NTk0ODE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5959481?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/rjl493456442",
      "html_url": "https://github.com/rjl493456442",
      "followers_url": "https://api.github.com/users/rjl493456442/followers",
      "following_url": "https://api.github.com/users/rjl493456442/following{/other_user}",
      "gists_url": "https://api.github.com/users/rjl493456442/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/rjl493456442/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/rjl493456442/subscriptions",
      "organizations_url": "https://api.github.com/users/rjl493456442/orgs",
      "repos_url": "https://api.github.com/users/rjl493456442/repos",
      "events_url": "https://api.github.com/users/rjl493456442/events{/privacy}",
      "received_events_url": "https://api.github.com/users/rjl493456442/received_events",
      "type": "User",
      "site_admin": false
    }
  ],
  "milestone": null,
  "comments": 15,
  "created_at": "2020-07-17T05:13:29Z",
  "updated_at": "2020-12-29T03:33:07Z",
  "closed_at": null,
  "author_association": "NONE",
  "active_lock_reason": null,
  "body": "Hello,\r\n\r\nIn Syscoin we run a light geth mode to verify Eth SPV proofs by pulling in reciept and tx roots directly into Syscoin (fork of Bitcoin).\r\n\r\nWe ensure that roots are available (~3 weeks worth or 150000 blocks minimum) before validating transactions with SPV proofs. Does LES client for Geth ensure that checkpoint are always atleast a certain age? Is there a policy you have to ensure checkpoints don't get put in that are newer? This would help I think.\r\n\r\nThanks!",
  "closed_by": null,
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/21337/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/21337/timeline",
  "performed_via_github_app": null,
  "state_reason": null
}
[
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/660760505",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/21337#issuecomment-660760505",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/21337",
    "id": 660760505,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY2MDc2MDUwNQ==",
    "user": {
      "login": "rjl493456442",
      "id": 5959481,
      "node_id": "MDQ6VXNlcjU5NTk0ODE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5959481?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/rjl493456442",
      "html_url": "https://github.com/rjl493456442",
      "followers_url": "https://api.github.com/users/rjl493456442/followers",
      "following_url": "https://api.github.com/users/rjl493456442/following{/other_user}",
      "gists_url": "https://api.github.com/users/rjl493456442/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/rjl493456442/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/rjl493456442/subscriptions",
      "organizations_url": "https://api.github.com/users/rjl493456442/orgs",
      "repos_url": "https://api.github.com/users/rjl493456442/repos",
      "events_url": "https://api.github.com/users/rjl493456442/events{/privacy}",
      "received_events_url": "https://api.github.com/users/rjl493456442/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-07-20T02:12:05Z",
    "updated_at": "2020-07-20T02:12:05Z",
    "author_association": "MEMBER",
    "body": "> Does LES client for Geth ensure that checkpoint are always atleast a certain age?\r\n\r\nI guess your question is: can we use the latest checkpoint for verifying the old data(receipts, txs, etc).\r\nYes, In LES the checkpoint is cumulative, the latest checkpoint can cover all past data.\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/660760505/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/661255692",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/21337#issuecomment-661255692",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/21337",
    "id": 661255692,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY2MTI1NTY5Mg==",
    "user": {
      "login": "sidhujag",
      "id": 6238042,
      "node_id": "MDQ6VXNlcjYyMzgwNDI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6238042?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sidhujag",
      "html_url": "https://github.com/sidhujag",
      "followers_url": "https://api.github.com/users/sidhujag/followers",
      "following_url": "https://api.github.com/users/sidhujag/following{/other_user}",
      "gists_url": "https://api.github.com/users/sidhujag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sidhujag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sidhujag/subscriptions",
      "organizations_url": "https://api.github.com/users/sidhujag/orgs",
      "repos_url": "https://api.github.com/users/sidhujag/repos",
      "events_url": "https://api.github.com/users/sidhujag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sidhujag/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-07-20T18:22:11Z",
    "updated_at": "2020-07-20T18:22:11Z",
    "author_association": "NONE",
    "body": "> > Does LES client for Geth ensure that checkpoint are always atleast a certain age?\r\n> \r\n> I guess your question is: can we use the latest checkpoint for verifying the old data(receipts, txs, etc).\r\n> Yes, In LES the checkpoint is cumulative, the latest checkpoint can cover all past data.\r\n\r\nBasically we run geth nodes to push reciept/tx roots to syscoin so it can validate SPV proofs from eth to sys. So if you run Geth from scratch it will sync up from latest checkpoint right that is the roots that get sent to syscoin. We need atleast 3 weeks of those roots to exist as that is the cutoff for an eth spv proof to become invalid on syscoin (where they can cancel on eth contract to get money back if they couldn't post it on syscoin), so there is risk of double spend if the geth client is not providing adequate data which is why I asked if we can ensure after every upgrade that checkpoints are atleast 3 weeks or more old.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/661255692/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/661595995",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/21337#issuecomment-661595995",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/21337",
    "id": 661595995,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY2MTU5NTk5NQ==",
    "user": {
      "login": "rjl493456442",
      "id": 5959481,
      "node_id": "MDQ6VXNlcjU5NTk0ODE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5959481?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/rjl493456442",
      "html_url": "https://github.com/rjl493456442",
      "followers_url": "https://api.github.com/users/rjl493456442/followers",
      "following_url": "https://api.github.com/users/rjl493456442/following{/other_user}",
      "gists_url": "https://api.github.com/users/rjl493456442/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/rjl493456442/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/rjl493456442/subscriptions",
      "organizations_url": "https://api.github.com/users/rjl493456442/orgs",
      "repos_url": "https://api.github.com/users/rjl493456442/repos",
      "events_url": "https://api.github.com/users/rjl493456442/events{/privacy}",
      "received_events_url": "https://api.github.com/users/rjl493456442/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-07-21T02:57:12Z",
    "updated_at": "2020-07-21T02:57:12Z",
    "author_association": "MEMBER",
    "body": "In Geth, if there are 32768 blocks generated, then a new checkpoint *can* be created. But the checkpoint updating is manual. So usually we only update the checkpoint when we make a new release(~2 weeks).\r\n\r\nBut as I said, the latest checkpoint can cover all historical data. If I understand correctly, You can even use the latest checkpoint but only use it for verifying the `receipt/tx` which is old enough(more than 3 weeks). \r\nIt doesn't matter how old the checkpoint is, it matters how old the data is(right?).\r\n\r\nBut if you really want to \"old enough\" checkpoint, you can check the `checkpoint oracle` which we use to publish the checkpoint. All historical votes will be put in the event. https://github.com/ethereum/go-ethereum/blob/master/contracts/checkpointoracle/contract/oracle.sol#L111",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/661595995/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/661630442",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/21337#issuecomment-661630442",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/21337",
    "id": 661630442,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY2MTYzMDQ0Mg==",
    "user": {
      "login": "sidhujag",
      "id": 6238042,
      "node_id": "MDQ6VXNlcjYyMzgwNDI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6238042?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sidhujag",
      "html_url": "https://github.com/sidhujag",
      "followers_url": "https://api.github.com/users/sidhujag/followers",
      "following_url": "https://api.github.com/users/sidhujag/following{/other_user}",
      "gists_url": "https://api.github.com/users/sidhujag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sidhujag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sidhujag/subscriptions",
      "organizations_url": "https://api.github.com/users/sidhujag/orgs",
      "repos_url": "https://api.github.com/users/sidhujag/repos",
      "events_url": "https://api.github.com/users/sidhujag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sidhujag/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-07-21T04:45:54Z",
    "updated_at": "2020-07-21T04:47:05Z",
    "author_association": "NONE",
    "body": "Our algorithm is as follows:\r\n\r\n1) notice an Ethereum burn transaction, to try to mint on Syscoin. Get the stored Ethereum header data via block height encoded in the transaction payload\r\n2) SPV proof validation of tx root and receipt root\r\n3) validate data inside of Ethereum tx payload\r\n\r\nThe Ethereum header must be atleast 1 hour old and under 3 weeks old for it to be valid.\r\n\r\nHow can the checkpoint help here? keep in mind every Syscoin node does this check independently for longest chain validation. A relayer pushes Ethereum header data using geth light node to Syscoin node via RPC locally.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/661630442/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/661638482",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/21337#issuecomment-661638482",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/21337",
    "id": 661638482,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY2MTYzODQ4Mg==",
    "user": {
      "login": "rjl493456442",
      "id": 5959481,
      "node_id": "MDQ6VXNlcjU5NTk0ODE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5959481?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/rjl493456442",
      "html_url": "https://github.com/rjl493456442",
      "followers_url": "https://api.github.com/users/rjl493456442/followers",
      "following_url": "https://api.github.com/users/rjl493456442/following{/other_user}",
      "gists_url": "https://api.github.com/users/rjl493456442/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/rjl493456442/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/rjl493456442/subscriptions",
      "organizations_url": "https://api.github.com/users/rjl493456442/orgs",
      "repos_url": "https://api.github.com/users/rjl493456442/repos",
      "events_url": "https://api.github.com/users/rjl493456442/events{/privacy}",
      "received_events_url": "https://api.github.com/users/rjl493456442/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-07-21T05:16:35Z",
    "updated_at": "2020-07-21T05:16:35Z",
    "author_association": "MEMBER",
    "body": "The light client can verify any header covered by the checkpoint. Like the `GetHeaderByNumber` API used by light client, https://github.com/ethereum/go-ethereum/blob/master/light/odr_util.go#L36, maybe you can always fetch the corresponding header by number and compare the hash?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/661638482/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/661639604",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/21337#issuecomment-661639604",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/21337",
    "id": 661639604,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY2MTYzOTYwNA==",
    "user": {
      "login": "sidhujag",
      "id": 6238042,
      "node_id": "MDQ6VXNlcjYyMzgwNDI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6238042?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sidhujag",
      "html_url": "https://github.com/sidhujag",
      "followers_url": "https://api.github.com/users/sidhujag/followers",
      "following_url": "https://api.github.com/users/sidhujag/following{/other_user}",
      "gists_url": "https://api.github.com/users/sidhujag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sidhujag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sidhujag/subscriptions",
      "organizations_url": "https://api.github.com/users/sidhujag/orgs",
      "repos_url": "https://api.github.com/users/sidhujag/repos",
      "events_url": "https://api.github.com/users/sidhujag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sidhujag/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-07-21T05:20:33Z",
    "updated_at": "2020-07-21T05:20:33Z",
    "author_association": "NONE",
    "body": "> The light client can verify any header covered by the checkpoint. Like the `GetHeaderByNumber` API used by light client, https://github.com/ethereum/go-ethereum/blob/master/light/odr_util.go#L36, maybe you can always fetch the corresponding header by number and compare the hash?\r\n\r\nWe don't want to query geth at runtime of syscoin consensus, the relayer pushes data and indexes into syscoin from geth node as it syncs up. At runtime we fetch header data by number and verify SPV proof which essentially validates the receipt and tx roots and payload commits to those roots. So maybe you are saying you index the checkpoints instead and use some kind of proof to validate that roots commit to the checkpoint if its older than say 3 weeks?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/661639604/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/662212817",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/21337#issuecomment-662212817",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/21337",
    "id": 662212817,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY2MjIxMjgxNw==",
    "user": {
      "login": "rjl493456442",
      "id": 5959481,
      "node_id": "MDQ6VXNlcjU5NTk0ODE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5959481?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/rjl493456442",
      "html_url": "https://github.com/rjl493456442",
      "followers_url": "https://api.github.com/users/rjl493456442/followers",
      "following_url": "https://api.github.com/users/rjl493456442/following{/other_user}",
      "gists_url": "https://api.github.com/users/rjl493456442/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/rjl493456442/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/rjl493456442/subscriptions",
      "organizations_url": "https://api.github.com/users/rjl493456442/orgs",
      "repos_url": "https://api.github.com/users/rjl493456442/repos",
      "events_url": "https://api.github.com/users/rjl493456442/events{/privacy}",
      "received_events_url": "https://api.github.com/users/rjl493456442/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-07-22T02:57:29Z",
    "updated_at": "2020-07-22T02:57:29Z",
    "author_association": "MEMBER",
    "body": "> So maybe you are saying you index the checkpoints instead and use some kind of proof to validate that roots commit to the checkpoint if its older than say 3 weeks?\r\n\r\nNO, I mean no matter the checkpoint is fresh new or not(even the checkpoint is new, the possibility the checkpoint is invalid is very low seems we have 2048 block confirms), you can use it for proving anyway(prove headers, receipts, txs).\r\n\r\nI don't understand why you have this kind of restriction that the checkpoint should be older than 3 weeks. If you really need this restriction, you can use the latest checkpoint but only use it for verifying the data(headers, receipts, txs) older than 3 weeks. It has the same security guarantee.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/662212817/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/663816529",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/21337#issuecomment-663816529",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/21337",
    "id": 663816529,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY2MzgxNjUyOQ==",
    "user": {
      "login": "sidhujag",
      "id": 6238042,
      "node_id": "MDQ6VXNlcjYyMzgwNDI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6238042?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sidhujag",
      "html_url": "https://github.com/sidhujag",
      "followers_url": "https://api.github.com/users/sidhujag/followers",
      "following_url": "https://api.github.com/users/sidhujag/following{/other_user}",
      "gists_url": "https://api.github.com/users/sidhujag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sidhujag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sidhujag/subscriptions",
      "organizations_url": "https://api.github.com/users/sidhujag/orgs",
      "repos_url": "https://api.github.com/users/sidhujag/repos",
      "events_url": "https://api.github.com/users/sidhujag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sidhujag/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-07-25T06:19:04Z",
    "updated_at": "2020-07-25T06:22:25Z",
    "author_association": "NONE",
    "body": "I am not using checkpoint directly I was just saying that once checkpoint was newer if someone was syncing from scratch they would end up only syncing less than 3 weeks of data and we wanted mroe than 3 weeks of headers in sys chain to allow for eventuality that an eth to sys transactions times out and gets cancelled (extracting erc20 out of our smart contract back to user).. it times out after 3 weeks so its assumed user can get money back (as a result we only need to track a certain number of weeks of eth headers and not more, for faster syncing on sys side but still enough to deal with cancelling). If you can use latest checkpoint to prove an older tx receipt proof and tx root proof somehow then we dont need cancel feature and can just use latest checkpoint for every single proof and do not even need to store eth headers in sys just the latest checkpoints. \r\n\r\nHow do you prove that a transaction was valid at some block X, where checkpoint is on block Y such that Y > X. The transaction commits to tx merkle root and receipt data commits to receipt merkle root in block X, how to prove it against checkpoint of block Y with no knowledge of block X, not even the tx roots, reciept root?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/663816529/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/681304584",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/21337#issuecomment-681304584",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/21337",
    "id": 681304584,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY4MTMwNDU4NA==",
    "user": {
      "login": "sidhujag",
      "id": 6238042,
      "node_id": "MDQ6VXNlcjYyMzgwNDI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6238042?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sidhujag",
      "html_url": "https://github.com/sidhujag",
      "followers_url": "https://api.github.com/users/sidhujag/followers",
      "following_url": "https://api.github.com/users/sidhujag/following{/other_user}",
      "gists_url": "https://api.github.com/users/sidhujag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sidhujag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sidhujag/subscriptions",
      "organizations_url": "https://api.github.com/users/sidhujag/orgs",
      "repos_url": "https://api.github.com/users/sidhujag/repos",
      "events_url": "https://api.github.com/users/sidhujag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sidhujag/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-08-27T02:25:31Z",
    "updated_at": "2020-08-27T02:57:26Z",
    "author_association": "NONE",
    "body": "@rjl49345644 \r\nHow do you check that a block hash X commits to checkpoint Y non-interactively?\r\n\r\nIt looks like a notion of \"section\" is used, I guess there is a way to calculate a block is part of a section and thus therefor connected to a CHT as well?\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/681304584/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/706875407",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/21337#issuecomment-706875407",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/21337",
    "id": 706875407,
    "node_id": "MDEyOklzc3VlQ29tbWVudDcwNjg3NTQwNw==",
    "user": {
      "login": "rjl493456442",
      "id": 5959481,
      "node_id": "MDQ6VXNlcjU5NTk0ODE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5959481?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/rjl493456442",
      "html_url": "https://github.com/rjl493456442",
      "followers_url": "https://api.github.com/users/rjl493456442/followers",
      "following_url": "https://api.github.com/users/rjl493456442/following{/other_user}",
      "gists_url": "https://api.github.com/users/rjl493456442/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/rjl493456442/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/rjl493456442/subscriptions",
      "organizations_url": "https://api.github.com/users/rjl493456442/orgs",
      "repos_url": "https://api.github.com/users/rjl493456442/repos",
      "events_url": "https://api.github.com/users/rjl493456442/events{/privacy}",
      "received_events_url": "https://api.github.com/users/rjl493456442/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-10-12T05:36:57Z",
    "updated_at": "2020-10-12T05:36:57Z",
    "author_association": "MEMBER",
    "body": "@sidhujag Yes, it should be feasible. You can checkout the LES spec here https://github.com/ethereum/devp2p/blob/master/caps/les.md. \r\n\r\nEssentially the CHT root is the root of a merkle tree. The leaves of the merkle tree\r\nis the canonical block hash. So a simple merkle proof should solve your problem.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/706875407/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/707836721",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/21337#issuecomment-707836721",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/21337",
    "id": 707836721,
    "node_id": "MDEyOklzc3VlQ29tbWVudDcwNzgzNjcyMQ==",
    "user": {
      "login": "sidhujag",
      "id": 6238042,
      "node_id": "MDQ6VXNlcjYyMzgwNDI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6238042?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sidhujag",
      "html_url": "https://github.com/sidhujag",
      "followers_url": "https://api.github.com/users/sidhujag/followers",
      "following_url": "https://api.github.com/users/sidhujag/following{/other_user}",
      "gists_url": "https://api.github.com/users/sidhujag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sidhujag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sidhujag/subscriptions",
      "organizations_url": "https://api.github.com/users/sidhujag/orgs",
      "repos_url": "https://api.github.com/users/sidhujag/repos",
      "events_url": "https://api.github.com/users/sidhujag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sidhujag/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-10-13T15:52:04Z",
    "updated_at": "2020-10-13T16:07:28Z",
    "author_association": "NONE",
    "body": "@rjl493456442 thanks, ok so let me see if I can clarify\r\n\r\nSo basically right now we store eth block number, tx root and receipt root in our db, and later checking against them when we get a bridge request from eth to sys we check:\r\n\r\n1) We get the tx root/receipt root info via block number fetch from the db\r\n2) We check the embedded transaction has a receipt root == stored receipt root\r\n3) same for tx root\r\n4) validate the receipt and tx roots via SPV proof data passed along by the user in the syscoin transaction payload\r\n5) Some other specific validations on the values of events logs etc\r\n\r\nso I can instead store all of the CHT's as well as block header data for any new blocks not committed to latest CHT. Is there a way geth can provide this on startup or upon request from a web3 client? I would also need the user to supply some additional tx likely in the payload which makes the payload larger but allows for validation for any commitment we have against CHT.\r\n\r\n1) User provides full block header so client can always validate it against CHT regardless of time.\r\n2) User specified merkle path of block hash committing to the CHT specified in the payload so we can validate via CHT method for any blocks commited to a CHT.\r\n3) Instead of 1 in first scenario we can simply get the CHT from the stored db of CHT's and then do SPV proof of validity of the block header with the transaction in question must be canonical chain. This would apply to any validations where a CHT would cover a block, so perhaps assume that if the block data doesn't exist in db (we always store block headers received by geth light client so likely would be any from latest CHT to tip)\r\n4) We would need a call to be able to receive CHT's right now we simply do web3 calls running on a local relayer which receives block information and then propagate the tx roots/receipt roots and block numbers to syscoin via local RPC call. In the same way we would only receive CHT's or pull CHT's from geth upon startup, but also at runtime as new CHT's are created in a similar way as block callbacks are processed.\r\n\r\nI think the new way of validating only applies to transactions that are in blocks not commited to by a CHT right, so I would need to still do normal validation for anything not in a CHT and then for older ones use CHT to validate the block is part of canonical chain? I can see potentially a few things user would need to provide including a merkle proof of block linked to CHT, if ommitted it is assumed it is not part of a CHT and block header must exist to validate against. I think we also need the block header also provided since locally we will not have the header we will have to have user provide it so we can verify that it can validate the merkle proof of block -> CHT commitment?\r\n\r\nIs this correct?  ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/707836721/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/722267706",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/21337#issuecomment-722267706",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/21337",
    "id": 722267706,
    "node_id": "MDEyOklzc3VlQ29tbWVudDcyMjI2NzcwNg==",
    "user": {
      "login": "rjl493456442",
      "id": 5959481,
      "node_id": "MDQ6VXNlcjU5NTk0ODE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5959481?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/rjl493456442",
      "html_url": "https://github.com/rjl493456442",
      "followers_url": "https://api.github.com/users/rjl493456442/followers",
      "following_url": "https://api.github.com/users/rjl493456442/following{/other_user}",
      "gists_url": "https://api.github.com/users/rjl493456442/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/rjl493456442/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/rjl493456442/subscriptions",
      "organizations_url": "https://api.github.com/users/rjl493456442/orgs",
      "repos_url": "https://api.github.com/users/rjl493456442/repos",
      "events_url": "https://api.github.com/users/rjl493456442/events{/privacy}",
      "received_events_url": "https://api.github.com/users/rjl493456442/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-11-05T09:50:06Z",
    "updated_at": "2020-11-05T09:50:06Z",
    "author_association": "MEMBER",
    "body": "@sidhujag I think it would be more efficient to chat directly? Because I guess you are using the light client heavily, so would you mind joining the geth dicord so that we can understand your problem better?\r\n\r\nThe link https://discord.gg/cb5s8b2t",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/722267706/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/722273157",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/21337#issuecomment-722273157",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/21337",
    "id": 722273157,
    "node_id": "MDEyOklzc3VlQ29tbWVudDcyMjI3MzE1Nw==",
    "user": {
      "login": "zsfelfoldi",
      "id": 9884311,
      "node_id": "MDQ6VXNlcjk4ODQzMTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/9884311?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/zsfelfoldi",
      "html_url": "https://github.com/zsfelfoldi",
      "followers_url": "https://api.github.com/users/zsfelfoldi/followers",
      "following_url": "https://api.github.com/users/zsfelfoldi/following{/other_user}",
      "gists_url": "https://api.github.com/users/zsfelfoldi/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/zsfelfoldi/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/zsfelfoldi/subscriptions",
      "organizations_url": "https://api.github.com/users/zsfelfoldi/orgs",
      "repos_url": "https://api.github.com/users/zsfelfoldi/repos",
      "events_url": "https://api.github.com/users/zsfelfoldi/events{/privacy}",
      "received_events_url": "https://api.github.com/users/zsfelfoldi/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-11-05T10:00:13Z",
    "updated_at": "2020-11-05T10:00:13Z",
    "author_association": "MEMBER",
    "body": "I think there is no security advantage in using an older CHT. CHTs are not trustless, they are announced by the dev team and they are basically just a performance optimization. They do not become safer with time. If you don't want to trust them but want to download and verify all headers, there is no option for that at the moment but it is easy to change in the code:\r\nhttps://github.com/ethereum/go-ethereum/blob/master/les/sync.go#L126\r\nYou have to change the default mode to `lightSync` instead of `checkpointSync`.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/722273157/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/722578357",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/21337#issuecomment-722578357",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/21337",
    "id": 722578357,
    "node_id": "MDEyOklzc3VlQ29tbWVudDcyMjU3ODM1Nw==",
    "user": {
      "login": "sidhujag",
      "id": 6238042,
      "node_id": "MDQ6VXNlcjYyMzgwNDI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6238042?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sidhujag",
      "html_url": "https://github.com/sidhujag",
      "followers_url": "https://api.github.com/users/sidhujag/followers",
      "following_url": "https://api.github.com/users/sidhujag/following{/other_user}",
      "gists_url": "https://api.github.com/users/sidhujag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sidhujag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sidhujag/subscriptions",
      "organizations_url": "https://api.github.com/users/sidhujag/orgs",
      "repos_url": "https://api.github.com/users/sidhujag/repos",
      "events_url": "https://api.github.com/users/sidhujag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sidhujag/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-11-05T19:04:05Z",
    "updated_at": "2020-11-05T19:04:38Z",
    "author_association": "NONE",
    "body": "> I think there is no security advantage in using an older CHT. CHTs are not trustless, they are announced by the dev team and they are basically just a performance optimization. They do not become safer with time. If you don't want to trust them but want to download and verify all headers, there is no option for that at the moment but it is easy to change in the code:\r\n> https://github.com/ethereum/go-ethereum/blob/master/les/sync.go#L126\r\n> You have to change the default mode to `lightSync` instead of `checkpointSync`.\r\n\r\nthe problem with all headers is that it requires alot of storage costs running syscoin storing all headers and time of sync as well.. I set it up so that it would require only a few week or month and then verification will enforce that anything older than a few weeks is not allowed to move over the bridge, so you have say 2 weeks to execute or cancel it (with fraud/availability proof system securing it) on the eth contract side, from 0 is fine but requires more data storage and sync time/bandwidth, whereas we made a tradeoff of 2 weeks to execute and live state validation only so that we only ever need to download say the last 3 or 4 weeks to be safe",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/722578357/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/724768991",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/21337#issuecomment-724768991",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/21337",
    "id": 724768991,
    "node_id": "MDEyOklzc3VlQ29tbWVudDcyNDc2ODk5MQ==",
    "user": {
      "login": "sidhujag",
      "id": 6238042,
      "node_id": "MDQ6VXNlcjYyMzgwNDI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6238042?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sidhujag",
      "html_url": "https://github.com/sidhujag",
      "followers_url": "https://api.github.com/users/sidhujag/followers",
      "following_url": "https://api.github.com/users/sidhujag/following{/other_user}",
      "gists_url": "https://api.github.com/users/sidhujag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sidhujag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sidhujag/subscriptions",
      "organizations_url": "https://api.github.com/users/sidhujag/orgs",
      "repos_url": "https://api.github.com/users/sidhujag/repos",
      "events_url": "https://api.github.com/users/sidhujag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sidhujag/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-11-10T15:17:45Z",
    "updated_at": "2020-11-10T15:17:45Z",
    "author_association": "NONE",
    "body": "Who do I talk to on there I left a message looking for you guys but received no response.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/724768991/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
