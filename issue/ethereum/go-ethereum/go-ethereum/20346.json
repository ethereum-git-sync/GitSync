{
  "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/20346",
  "repository_url": "https://api.github.com/repos/ethereum/go-ethereum",
  "labels_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/20346/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/20346/comments",
  "events_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/20346/events",
  "html_url": "https://github.com/ethereum/go-ethereum/issues/20346",
  "id": 526452179,
  "node_id": "MDU6SXNzdWU1MjY0NTIxNzk=",
  "number": 20346,
  "title": "Idea: Persist dirty trie snapshots into ephemeral files",
  "user": {
    "login": "karalabe",
    "id": 129561,
    "node_id": "MDQ6VXNlcjEyOTU2MQ==",
    "avatar_url": "https://avatars.githubusercontent.com/u/129561?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/karalabe",
    "html_url": "https://github.com/karalabe",
    "followers_url": "https://api.github.com/users/karalabe/followers",
    "following_url": "https://api.github.com/users/karalabe/following{/other_user}",
    "gists_url": "https://api.github.com/users/karalabe/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/karalabe/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/karalabe/subscriptions",
    "organizations_url": "https://api.github.com/users/karalabe/orgs",
    "repos_url": "https://api.github.com/users/karalabe/repos",
    "events_url": "https://api.github.com/users/karalabe/events{/privacy}",
    "received_events_url": "https://api.github.com/users/karalabe/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 1269313112,
      "node_id": "MDU6TGFiZWwxMjY5MzEzMTEy",
      "url": "https://api.github.com/repos/ethereum/go-ethereum/labels/status:backlog",
      "name": "status:backlog",
      "color": "29ceb3",
      "default": false,
      "description": ""
    }
  ],
  "state": "open",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 1,
  "created_at": "2019-11-21T08:58:46Z",
  "updated_at": "2020-07-30T08:39:13Z",
  "closed_at": null,
  "author_association": "MEMBER",
  "active_lock_reason": null,
  "body": "Currently after every hour-worth of processing, we commit the latest state that we have cached up in the trie's dirty cache. The sole purpose of this operation is to be able to recover after a crash and not have to redo more than 1h of number crunching. Unfortunately, once we push something to disk, we don't have the capacity to clean it up, so every time we do this backup persistency, we push junk to the database.\r\n\r\nA better alternative would be to push the dirty cache in its entirety to a flat file into the datadir and keep using it as if nothing happened. In case of a crash, we recover the flat file, if no crash, we just replace it (create new, delete old after). The two benefits are that periodic backups no longer waste space; and that the interval becomes user configurable (e.g. 1h is too steep for home users, maybe 5-10 mins is better, but currently we cannot as higher flush rate is higher junk rate).\r\n\r\nStarted a benchmark, lets see how they fare: https://geth-bench.ethdevops.io/d/Jpk-Be5Wk/dual-geth?orgId=1&var-exp=mon08&var-master=mon09&var-percentile=50&refresh=30s",
  "closed_by": null,
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/20346/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/20346/timeline",
  "performed_via_github_app": null,
  "state_reason": null
}
[
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/559348199",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/20346#issuecomment-559348199",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/20346",
    "id": 559348199,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU1OTM0ODE5OQ==",
    "user": {
      "login": "rjl493456442",
      "id": 5959481,
      "node_id": "MDQ6VXNlcjU5NTk0ODE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5959481?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/rjl493456442",
      "html_url": "https://github.com/rjl493456442",
      "followers_url": "https://api.github.com/users/rjl493456442/followers",
      "following_url": "https://api.github.com/users/rjl493456442/following{/other_user}",
      "gists_url": "https://api.github.com/users/rjl493456442/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/rjl493456442/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/rjl493456442/subscriptions",
      "organizations_url": "https://api.github.com/users/rjl493456442/orgs",
      "repos_url": "https://api.github.com/users/rjl493456442/repos",
      "events_url": "https://api.github.com/users/rjl493456442/events{/privacy}",
      "received_events_url": "https://api.github.com/users/rjl493456442/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-11-28T05:30:49Z",
    "updated_at": "2019-11-28T05:30:49Z",
    "author_association": "MEMBER",
    "body": "Think about the journal based state backup, have a few questions.\r\n\r\nThe main goal of this mechanism is to reduce the junk we push into the database,  So we keep an old version state in the database and keep all newly added trie nodes in the flat file. \r\n\r\nThe newly added trie nodes can be regarded as the diff between the latest version of state and the stale version state in the database. We don't need to care about the deleted trie nodes.\r\n\r\nHowever in order to ensure the diff is completed, we have to merge new diff with file and store the whole thing into the file(replace in an atomic way). When we restart the node, reload the whole thing as the dirty cache.\r\n\r\nBut it also means that the size of the dirty cache will grow very fast. The only way to solve it is by pushing the data into the database so that we can use a normal DB style for retrieval.\r\n\r\nSo finally we still have to push something into the disk, disk pruner is still necessary.\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/559348199/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
