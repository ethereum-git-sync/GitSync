{
  "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/22209",
  "repository_url": "https://api.github.com/repos/ethereum/go-ethereum",
  "labels_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/22209/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/22209/comments",
  "events_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/22209/events",
  "html_url": "https://github.com/ethereum/go-ethereum/issues/22209",
  "id": 791559648,
  "node_id": "MDU6SXNzdWU3OTE1NTk2NDg=",
  "number": 22209,
  "title": "syncing error: header broke chain ordering",
  "user": {
    "login": "ryanschneider",
    "id": 53520,
    "node_id": "MDQ6VXNlcjUzNTIw",
    "avatar_url": "https://avatars.githubusercontent.com/u/53520?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/ryanschneider",
    "html_url": "https://github.com/ryanschneider",
    "followers_url": "https://api.github.com/users/ryanschneider/followers",
    "following_url": "https://api.github.com/users/ryanschneider/following{/other_user}",
    "gists_url": "https://api.github.com/users/ryanschneider/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/ryanschneider/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/ryanschneider/subscriptions",
    "organizations_url": "https://api.github.com/users/ryanschneider/orgs",
    "repos_url": "https://api.github.com/users/ryanschneider/repos",
    "events_url": "https://api.github.com/users/ryanschneider/events{/privacy}",
    "received_events_url": "https://api.github.com/users/ryanschneider/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 72233650,
      "node_id": "MDU6TGFiZWw3MjIzMzY1MA==",
      "url": "https://api.github.com/repos/ethereum/go-ethereum/labels/type:bug",
      "name": "type:bug",
      "color": "FF5E5E",
      "default": false,
      "description": ""
    }
  ],
  "state": "open",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 9,
  "created_at": "2021-01-21T23:11:45Z",
  "updated_at": "2021-01-22T16:05:08Z",
  "closed_at": null,
  "author_association": "CONTRIBUTOR",
  "active_lock_reason": null,
  "body": "#### System information\r\n\r\nGeth version: 1.9.25 \r\nOS & Version: Linux\r\n\r\n#### Expected behaviour\r\n\r\nI was testing something so setup two nodes, node A is peered with the wider devp2p network while node B is started with a fairly recent copy of the chain (maybe an hour old) and is running with the arguments `--nodiscover --netrestrict 10.0.0.0/8`, it's then manually peered with node A via admin_addPeer/addTrustedPeer.\r\n\r\nI would expect this scenario to work and for node B to sync to head from node A (and continue to stay in sync with node A).  I've done this before with more nodes successfully but never limited the process to just two nodes.\r\n\r\n#### Actual behaviour\r\n\r\nHowever, in this case once node B got close to head, it got into a state where it kept rejecting the blocks received from node A:\r\n\r\n```\r\nJan 21 22:38:43 ip-10-0-74-205 geth[12200]: INFO [01-21|22:38:43.239] Imported new chain segment               blocks=16  txs=2635 mgas=199.946 elapsed=3.919s    mgasps=51.017 number=11701582 hash=\"a52330…62f0cc\" age=1m30s    dirty=506.16MiB\r\nJan 21 22:38:48 ip-10-0-74-205 geth[12200]: INFO [01-21|22:38:48.192] Imported new chain segment               blocks=3   txs=381  mgas=37.481  elapsed=644.368ms mgasps=58.167 number=11701585 hash=\"b055c9…48715a\" dirty=506.67MiB\r\nJan 21 22:38:57 ip-10-0-74-205 geth[12200]: INFO [01-21|22:38:57.067] Imported new chain segment               blocks=1   txs=144  mgas=11.983  elapsed=263.178ms mgasps=45.531 number=11701586 hash=\"3e9092…0b6929\" dirty=507.09MiB\r\nJan 21 22:39:13 ip-10-0-74-205 geth[12200]: INFO [01-21|22:39:13.325] Imported new chain segment               blocks=1   txs=189  mgas=12.475  elapsed=309.923ms mgasps=40.253 number=11701587 hash=\"ab97c1…80fc48\" dirty=507.26MiB\r\nJan 21 22:39:33 ip-10-0-74-205 geth[12200]: INFO [01-21|22:39:33.797] Deep froze chain segment                 blocks=21  elapsed=14.074ms  number=11611587 hash=\"d29346…775f81\"\r\nJan 21 22:39:33 ip-10-0-74-205 geth[12200]: WARN [01-21|22:39:33.900] Head headers broke chain ordering        peer=b5d45226ed68e4b8 index=0 requested=11701586 received=11701590\r\nJan 21 22:39:33 ip-10-0-74-205 geth[12200]: WARN [01-21|22:39:33.900] Synchronisation failed, dropping peer    peer=b5d45226ed68e4b8 err=\"retrieved hash chain is invalid: head headers broke chain ordering\"\r\nJan 21 22:39:33 ip-10-0-74-205 geth[12200]: INFO [01-21|22:39:33.901] Looking for peers                        peercount=0 tried=0 static=1\r\nJan 21 22:40:08 ip-10-0-74-205 geth[12200]: INFO [01-21|22:40:08.901] Looking for peers                        peercount=1 tried=1 static=1\r\nJan 21 22:40:14 ip-10-0-74-205 geth[12200]: WARN [01-21|22:40:14.499] Head headers broke chain ordering        peer=b5d45226ed68e4b8 index=0 requested=11701586 received=11701596\r\nJan 21 22:40:14 ip-10-0-74-205 geth[12200]: WARN [01-21|22:40:14.499] Synchronisation failed, dropping peer    peer=b5d45226ed68e4b8 err=\"retrieved hash chain is invalid: head headers broke chain ordering\"\r\nJan 21 22:40:49 ip-10-0-74-205 geth[12200]: INFO [01-21|22:40:49.501] Looking for peers                        peercount=1 tried=1 static=1\r\nJan 21 22:41:21 ip-10-0-74-205 geth[12200]: INFO [01-21|22:41:21.097] Downloader queue stats                   receiptTasks=0 blockTasks=0    itemSize=42.72KiB throttle=1535\r\nJan 21 22:41:21 ip-10-0-74-205 geth[12200]: WARN [01-21|22:41:21.097] Synchronisation failed, dropping peer    peer=b5d45226ed68e4b8 err=\"retrieved hash chain is invalid: no peers available or all tried for download\"\r\nJan 21 22:41:21 ip-10-0-74-205 geth[12200]: INFO [01-21|22:41:21.100] Looking for peers                        peercount=0 tried=0 static=1\r\nJan 21 22:41:44 ip-10-0-74-205 geth[12200]: WARN [01-21|22:41:44.922] Head headers broke chain ordering        peer=b5d45226ed68e4b8 index=0 requested=11701587 received=11701603\r\nJan 21 22:41:44 ip-10-0-74-205 geth[12200]: WARN [01-21|22:41:44.922] Synchronisation failed, dropping peer    peer=b5d45226ed68e4b8 err=\"retrieved hash chain is invalid: head headers broke chain ordering\"\r\n```\r\n\r\nIt tried this several times then eventual seemed to give up:\r\n\r\n```\r\nJan 21 22:47:28 ip-10-0-74-205 geth[12200]: WARN [01-21|22:47:28.550] Header broke chain ancestry              number=11701623 hash=\"459a13…5ddd65\"\r\nJan 21 22:47:28 ip-10-0-74-205 geth[12200]: INFO [01-21|22:47:28.551] Downloader queue stats                   receiptTasks=0 blockTasks=33   itemSize=42.72KiB throttle=1535\r\nJan 21 22:47:28 ip-10-0-74-205 geth[12200]: WARN [01-21|22:47:28.551] Synchronisation failed, dropping peer    peer=b5d45226ed68e4b8 err=\"action from bad peer ignored: stale headers\"\r\nJan 21 22:47:28 ip-10-0-74-205 geth[12200]: INFO [01-21|22:47:28.551] Looking for peers                        peercount=0 tried=0 static=1\r\n```\r\n\r\nRestarting node B seemed to let it progress without hitting this issue again but it did take 5 minutes to sync the missing blocks.\r\n\r\n#### Steps to reproduce the behaviour\r\n\r\n- Start node A and sync to head.\r\n- Make a backup of its chain data\r\n- Restore the backup on a new node B (be sure not to use the same node `key`) that only has network access to node A\r\n- Observe the issue above\r\n\r\n#### Analysis\r\n\r\nWhat I _think_ is happening is that node A is announcing new blocks as they are produced at the same time that node B is catching up to head and thus requesting slightly older headers from A at the same time.\r\n\r\nThus when node B gets the latest header for head while while expecting one of the older ones, the code below causes the downloader to error out: https://github.com/ethereum/go-ethereum/blob/83d317cff937940395fcb7ece29effc9c7779c13/eth/downloader/downloader.go#L846\r\n\r\nIt seems to me like maybe in this scenario is downloader should issue the warn about broken chain ordering but simply ignore the header instead of erring out the download?  Or maybe even resubmit the packet back onto `headerCh` for later processing?",
  "closed_by": null,
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/22209/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/22209/timeline",
  "performed_via_github_app": null,
  "state_reason": null
}
[
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/765008830",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/22209#issuecomment-765008830",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/22209",
    "id": 765008830,
    "node_id": "MDEyOklzc3VlQ29tbWVudDc2NTAwODgzMA==",
    "user": {
      "login": "ryanschneider",
      "id": 53520,
      "node_id": "MDQ6VXNlcjUzNTIw",
      "avatar_url": "https://avatars.githubusercontent.com/u/53520?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanschneider",
      "html_url": "https://github.com/ryanschneider",
      "followers_url": "https://api.github.com/users/ryanschneider/followers",
      "following_url": "https://api.github.com/users/ryanschneider/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanschneider/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanschneider/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanschneider/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanschneider/orgs",
      "repos_url": "https://api.github.com/users/ryanschneider/repos",
      "events_url": "https://api.github.com/users/ryanschneider/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanschneider/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-01-21T23:33:53Z",
    "updated_at": "2021-01-21T23:36:00Z",
    "author_association": "CONTRIBUTOR",
    "body": "So I _think_ the issue is that `downloader.fetchHead`, `.findAncestor` and `.DeliverHeaders` all share the same `headerCh` but `findAncestor` and `.fetchHead` both seem to assume that the next header in the channel is always the one they asked for, even though there's nothing stopping `.DeliverHeaders` from injecting other headers, leading somewhat racy behavior.\r\n\r\nFor example, imagine:\r\n\r\n- findAncestor asks for headers 11701586 to 11701590 on line 820 (notably in a goroutine)\r\n- at roughly the same time node A announces block 11701596 to its peers\r\n- node B receives block 11701596 and it's added to the channel via `DeliverHeaders` (in ethHandler.Handle)\r\n- findAncestor reads from the channel on line 833 but gets the unexpected 11701596 packet instead of 11701586, and cancels downloading\r\n\r\n\r\nedit: `fetchHead` and `fetchHeaders` both seems to ignore any unexpected packets, I think it's only `findAncestor` that returns an error when one is seen.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/765008830/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/765013553",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/22209#issuecomment-765013553",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/22209",
    "id": 765013553,
    "node_id": "MDEyOklzc3VlQ29tbWVudDc2NTAxMzU1Mw==",
    "user": {
      "login": "ryanschneider",
      "id": 53520,
      "node_id": "MDQ6VXNlcjUzNTIw",
      "avatar_url": "https://avatars.githubusercontent.com/u/53520?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanschneider",
      "html_url": "https://github.com/ryanschneider",
      "followers_url": "https://api.github.com/users/ryanschneider/followers",
      "following_url": "https://api.github.com/users/ryanschneider/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanschneider/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanschneider/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanschneider/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanschneider/orgs",
      "repos_url": "https://api.github.com/users/ryanschneider/repos",
      "events_url": "https://api.github.com/users/ryanschneider/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanschneider/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-01-21T23:46:55Z",
    "updated_at": "2021-01-21T23:46:55Z",
    "author_association": "CONTRIBUTOR",
    "body": "Also FWIW I don't think this error is actually related to the network topology above I described, I checked another test node running 1.9.24 (an archive node with \"vanilla\" devp2p network setup), and it seems like it's hit this same \"race\" 15 times in the last month:\r\n\r\n```\r\nJan 08 01:23:37 ip-10-0-67-119 geth[22149]: WARN [01-08|01:23:37.014] Head headers broke chain ordering        peer=adab52156ed1c3a1 index=0 requested=11611002 received=11611005\r\nJan 08 01:23:37 ip-10-0-67-119 geth[22149]: WARN [01-08|01:23:37.014] Synchronisation failed, dropping peer    peer=adab52156ed1c3a1 err=\"retrieved hash chain is invalid: head headers broke chain ordering\"\r\nJan 08 11:32:27 ip-10-0-67-119 geth[22149]: WARN [01-08|11:32:27.400] Head headers broke chain ordering        peer=3648da2b2c589bc9 index=0 requested=11613822 received=11613825\r\nJan 08 11:32:27 ip-10-0-67-119 geth[22149]: WARN [01-08|11:32:27.400] Synchronisation failed, dropping peer    peer=3648da2b2c589bc9 err=\"retrieved hash chain is invalid: head headers broke chain ordering\"\r\nJan 09 06:02:55 ip-10-0-67-119 geth[22149]: WARN [01-09|06:02:55.188] Head headers broke chain ordering        peer=1224967e43246567 index=0 requested=11618863 received=11618867\r\nJan 09 06:02:55 ip-10-0-67-119 geth[22149]: WARN [01-09|06:02:55.188] Synchronisation failed, dropping peer    peer=1224967e43246567 err=\"retrieved hash chain is invalid: head headers broke chain ordering\"\r\nJan 09 19:26:24 ip-10-0-67-119 geth[22149]: WARN [01-09|19:26:24.195] Head headers broke chain ordering        peer=ae0197451c696a6b index=0 requested=11622461 received=11622464\r\nJan 09 19:26:24 ip-10-0-67-119 geth[22149]: WARN [01-09|19:26:24.196] Synchronisation failed, dropping peer    peer=ae0197451c696a6b err=\"retrieved hash chain is invalid: head headers broke chain ordering\"\r\nJan 12 10:25:42 ip-10-0-67-119 geth[22149]: WARN [01-12|10:25:42.615] Head headers broke chain ordering        peer=48784859a08962b0 index=0 requested=11639573 received=11639576\r\nJan 12 10:25:42 ip-10-0-67-119 geth[22149]: WARN [01-12|10:25:42.615] Synchronisation failed, dropping peer    peer=48784859a08962b0 err=\"retrieved hash chain is invalid: head headers broke chain ordering\"\r\nJan 13 01:19:05 ip-10-0-67-119 geth[22149]: WARN [01-13|01:19:05.003] Head headers broke chain ordering        peer=74ca34024782e56e index=0 requested=11643637 received=11643640\r\nJan 13 01:19:05 ip-10-0-67-119 geth[22149]: WARN [01-13|01:19:05.003] Synchronisation failed, dropping peer    peer=74ca34024782e56e err=\"retrieved hash chain is invalid: head headers broke chain ordering\"\r\nJan 13 11:56:02 ip-10-0-67-119 geth[22149]: WARN [01-13|11:56:02.638] Head headers broke chain ordering        peer=74ca34024782e56e index=0 requested=11646438 received=11646441\r\nJan 13 11:56:02 ip-10-0-67-119 geth[22149]: WARN [01-13|11:56:02.638] Synchronisation failed, dropping peer    peer=74ca34024782e56e err=\"retrieved hash chain is invalid: head headers broke chain ordering\"\r\nJan 14 18:02:03 ip-10-0-67-119 geth[22149]: WARN [01-14|18:02:03.232] Head headers broke chain ordering        peer=f10d797a3ec9eb54 index=0 requested=11654710 received=11337727\r\nJan 14 18:02:03 ip-10-0-67-119 geth[22149]: WARN [01-14|18:02:03.232] Synchronisation failed, dropping peer    peer=f10d797a3ec9eb54 err=\"retrieved hash chain is invalid: head headers broke chain ordering\"\r\nJan 15 15:01:40 ip-10-0-67-119 geth[22149]: WARN [01-15|15:01:40.551] Head headers broke chain ordering        peer=12bbc0788e783178 index=0 requested=11660375 received=11660378\r\nJan 15 15:01:40 ip-10-0-67-119 geth[22149]: WARN [01-15|15:01:40.551] Synchronisation failed, dropping peer    peer=12bbc0788e783178 err=\"retrieved hash chain is invalid: head headers broke chain ordering\"\r\nJan 15 17:38:50 ip-10-0-67-119 geth[22149]: WARN [01-15|17:38:50.404] Head headers broke chain ordering        peer=48784859a08962b0 index=0 requested=11337724 received=11661142\r\nJan 15 17:38:50 ip-10-0-67-119 geth[22149]: WARN [01-15|17:38:50.404] Synchronisation failed, dropping peer    peer=48784859a08962b0 err=\"retrieved hash chain is invalid: head headers broke chain ordering\"\r\nJan 18 22:21:20 ip-10-0-67-119 geth[22149]: WARN [01-18|22:21:20.997] Head headers broke chain ordering        peer=12bbc0788e783178 index=0 requested=11681902 received=11681905\r\nJan 18 22:21:20 ip-10-0-67-119 geth[22149]: WARN [01-18|22:21:20.997] Synchronisation failed, dropping peer    peer=12bbc0788e783178 err=\"retrieved hash chain is invalid: head headers broke chain ordering\"\r\nJan 19 02:18:00 ip-10-0-67-119 geth[22149]: WARN [01-19|02:18:00.351] Head headers broke chain ordering        peer=877018c696938d8e index=0 requested=11682961 received=11337727\r\nJan 19 02:18:00 ip-10-0-67-119 geth[22149]: WARN [01-19|02:18:00.351] Synchronisation failed, dropping peer    peer=877018c696938d8e err=\"retrieved hash chain is invalid: head headers broke chain ordering\"\r\nJan 20 05:32:24 ip-10-0-67-119 geth[22149]: WARN [01-20|05:32:24.414] Head headers broke chain ordering        peer=74ca34024782e56e index=0 requested=11690387 received=11337727\r\nJan 20 05:32:24 ip-10-0-67-119 geth[22149]: WARN [01-20|05:32:24.414] Synchronisation failed, dropping peer    peer=74ca34024782e56e err=\"retrieved hash chain is invalid: head headers broke chain ordering\"\r\nJan 20 22:11:27 ip-10-0-67-119 geth[22149]: WARN [01-20|22:11:27.833] Head headers broke chain ordering        peer=207ae0400732475a index=0 requested=11695013 received=11695016\r\nJan 20 22:11:27 ip-10-0-67-119 geth[22149]: WARN [01-20|22:11:27.833] Synchronisation failed, dropping peer    peer=207ae0400732475a err=\"retrieved hash chain is invalid: head headers broke chain ordering\"\r\nJan 21 17:28:38 ip-10-0-67-119 geth[22149]: WARN [01-21|17:28:38.952] Head headers broke chain ordering        peer=239c15d65fb14926 index=0 requested=11700145 received=11337727\r\nJan 21 17:28:38 ip-10-0-67-119 geth[22149]: WARN [01-21|17:28:38.952] Synchronisation failed, dropping peer    peer=239c15d65fb14926 err=\"retrieved hash chain is invalid: head headers broke chain ordering\"\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/765013553/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/765394855",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/22209#issuecomment-765394855",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/22209",
    "id": 765394855,
    "node_id": "MDEyOklzc3VlQ29tbWVudDc2NTM5NDg1NQ==",
    "user": {
      "login": "holiman",
      "id": 142290,
      "node_id": "MDQ6VXNlcjE0MjI5MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/142290?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/holiman",
      "html_url": "https://github.com/holiman",
      "followers_url": "https://api.github.com/users/holiman/followers",
      "following_url": "https://api.github.com/users/holiman/following{/other_user}",
      "gists_url": "https://api.github.com/users/holiman/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/holiman/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/holiman/subscriptions",
      "organizations_url": "https://api.github.com/users/holiman/orgs",
      "repos_url": "https://api.github.com/users/holiman/repos",
      "events_url": "https://api.github.com/users/holiman/events{/privacy}",
      "received_events_url": "https://api.github.com/users/holiman/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-01-22T13:27:51Z",
    "updated_at": "2021-01-22T13:27:51Z",
    "author_association": "MEMBER",
    "body": "I've looked into this a bit now, and experimented a bit. There are two possible cases that I think you are reporting. \r\n\r\n1. Whether a 'spurious' header from some other peer can disrupt the common-ancestor phase of the sync. TLDR; No. \r\n\r\nAt https://github.com/ethereum/go-ethereum/blob/master/eth/downloader/downloader.go#L854, there's this thing which _looks_ like it may cause problems\r\n\r\n```golang\tfor finished := false; !finished; {\r\n\t\tselect {\r\n\t\tcase <-d.cancelCh:\r\n\t\t\treturn 0, errCanceled\r\n\r\n\t\tcase packet := <-d.headerCh:\r\n\t\t\t// Discard anything not from the origin peer\r\n\t\t\tif packet.PeerId() != p.id {\r\n\t\t\t\tlog.Debug(\"Received headers from incorrect peer\", \"peer\", packet.PeerId())\r\n\t\t\t\tbreak\r\n\t\t\t}\r\n\t\t\t\t\r\n```\r\n(there are similar constructs in other places too). \r\nHowever, [Golang spec](https://golang.org/ref/spec#Break_statements) says, about break statements, that \r\n\r\n> A \"break\" statement terminates execution of the innermost \"for\", \"switch\", or \"select\" statement within the same function. \r\n\r\nSo that `break` indeed just ignores the packet (albeit with a debug log) and continues waiting for something from the peer we requested headers from. \r\n\r\n\r\n2. Whether a 'spurious' header from some other peer can disrupt the common-ancestor phase of the sync. TLDR; Yes, probably. \r\n\r\nI think this can happen -- while we're in the phase of querying for headers with `peerA`, and `peerA` decides to send over some header, that would definitely disturb the happenings here. However, I don't see how that can happen -- when new blocks arrive, they're broadcast to some of the peers, but _not as headers_, but as blocks. \r\n\r\nSo I'm still not quite sure of what sequence of events would cause `peerA` to send a header like that (not saying it doesn't happen). \r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/765394855/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/765397624",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/22209#issuecomment-765397624",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/22209",
    "id": 765397624,
    "node_id": "MDEyOklzc3VlQ29tbWVudDc2NTM5NzYyNA==",
    "user": {
      "login": "ryanschneider",
      "id": 53520,
      "node_id": "MDQ6VXNlcjUzNTIw",
      "avatar_url": "https://avatars.githubusercontent.com/u/53520?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanschneider",
      "html_url": "https://github.com/ryanschneider",
      "followers_url": "https://api.github.com/users/ryanschneider/followers",
      "following_url": "https://api.github.com/users/ryanschneider/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanschneider/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanschneider/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanschneider/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanschneider/orgs",
      "repos_url": "https://api.github.com/users/ryanschneider/repos",
      "events_url": "https://api.github.com/users/ryanschneider/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanschneider/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-01-22T13:32:14Z",
    "updated_at": "2021-01-22T13:32:14Z",
    "author_association": "CONTRIBUTOR",
    "body": "I need to review the code again but I thought the block itself was\nbroadcast to the square root of len(peers) but then the header was sent to\nall the other peers (or maybe all peers).\n\nOn Fri, Jan 22, 2021 at 5:28 AM Martin Holst Swende <\nnotifications@github.com> wrote:\n\n> I've looked into this a bit now, and experimented a bit. There are two\n> possible cases that I think you are reporting.\n>\n>    1. Whether a 'spurious' header from some other peer can disrupt the\n>    common-ancestor phase of the sync. TLDR; No.\n>\n> At\n> https://github.com/ethereum/go-ethereum/blob/master/eth/downloader/downloader.go#L854,\n> there's this thing which *looks* like it may cause problems\n>\n> \t\tselect {\n> \t\tcase <-d.cancelCh:\n> \t\t\treturn 0, errCanceled\n>\n> \t\tcase packet := <-d.headerCh:\n> \t\t\t// Discard anything not from the origin peer\n> \t\t\tif packet.PeerId() != p.id {\n> \t\t\t\tlog.Debug(\"Received headers from incorrect peer\", \"peer\", packet.PeerId())\n> \t\t\t\tbreak\n> \t\t\t}\n> \t\t\t\t\n>\n> (there are similar constructs in other places too).\n> However, Golang spec <https://golang.org/ref/spec#Break_statements> says,\n> about break statements, that\n>\n> A \"break\" statement terminates execution of the innermost \"for\", \"switch\",\n> or \"select\" statement within the same function.\n>\n> So that break indeed just ignores the packet (albeit with a debug log)\n> and continues waiting for something from the peer we requested headers from.\n>\n>    1. Whether a 'spurious' header from some other peer can disrupt the\n>    common-ancestor phase of the sync. TLDR; Yes, probably.\n>\n> I think this can happen -- while we're in the phase of querying for\n> headers with peerA, and peerA decides to send over some header, that\n> would definitely disturb the happenings here. However, I don't see how that\n> can happen -- when new blocks arrive, they're broadcast to some of the\n> peers, but *not as headers*, but as blocks.\n>\n> So I'm still not quite sure of what sequence of events would cause peerA\n> to send a header like that (not saying it doesn't happen).\n>\n> —\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/ethereum/go-ethereum/issues/22209#issuecomment-765394855>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AAANCEEYNKPVRHQPLNW45YTS3F4OPANCNFSM4WNURFTQ>\n> .\n>\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/765397624/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/765399871",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/22209#issuecomment-765399871",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/22209",
    "id": 765399871,
    "node_id": "MDEyOklzc3VlQ29tbWVudDc2NTM5OTg3MQ==",
    "user": {
      "login": "holiman",
      "id": 142290,
      "node_id": "MDQ6VXNlcjE0MjI5MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/142290?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/holiman",
      "html_url": "https://github.com/holiman",
      "followers_url": "https://api.github.com/users/holiman/followers",
      "following_url": "https://api.github.com/users/holiman/following{/other_user}",
      "gists_url": "https://api.github.com/users/holiman/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/holiman/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/holiman/subscriptions",
      "organizations_url": "https://api.github.com/users/holiman/orgs",
      "repos_url": "https://api.github.com/users/holiman/repos",
      "events_url": "https://api.github.com/users/holiman/events{/privacy}",
      "received_events_url": "https://api.github.com/users/holiman/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-01-22T13:35:35Z",
    "updated_at": "2021-01-22T13:35:35Z",
    "author_association": "MEMBER",
    "body": "> It seems to me like maybe in this scenario is downloader should issue the warn about broken chain ordering but simply ignore the header instead of erring out the download? Or maybe even resubmit the packet back onto headerCh for later processing?\r\n\r\nI agree -- it seems better to simply wait it out and see if the peer delivers what we asked for (before the timeout triggers), and simply ignore anything else coming in. \r\n\r\nOtherwise, we might end up in the scenario where previous deliveries keep piling up and being mistaken as answers to new queries. ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/765399871/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/765459381",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/22209#issuecomment-765459381",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/22209",
    "id": 765459381,
    "node_id": "MDEyOklzc3VlQ29tbWVudDc2NTQ1OTM4MQ==",
    "user": {
      "login": "holiman",
      "id": 142290,
      "node_id": "MDQ6VXNlcjE0MjI5MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/142290?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/holiman",
      "html_url": "https://github.com/holiman",
      "followers_url": "https://api.github.com/users/holiman/followers",
      "following_url": "https://api.github.com/users/holiman/following{/other_user}",
      "gists_url": "https://api.github.com/users/holiman/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/holiman/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/holiman/subscriptions",
      "organizations_url": "https://api.github.com/users/holiman/orgs",
      "repos_url": "https://api.github.com/users/holiman/repos",
      "events_url": "https://api.github.com/users/holiman/events{/privacy}",
      "received_events_url": "https://api.github.com/users/holiman/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-01-22T14:55:20Z",
    "updated_at": "2021-01-22T14:55:20Z",
    "author_association": "MEMBER",
    "body": "> but then the header was sent to all the other peers (or maybe all peers).\r\n\r\nNope, AFAICT it's not the header, it's the announcement of new `(hash, number)` pairs",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/765459381/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/765497214",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/22209#issuecomment-765497214",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/22209",
    "id": 765497214,
    "node_id": "MDEyOklzc3VlQ29tbWVudDc2NTQ5NzIxNA==",
    "user": {
      "login": "ryanschneider",
      "id": 53520,
      "node_id": "MDQ6VXNlcjUzNTIw",
      "avatar_url": "https://avatars.githubusercontent.com/u/53520?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanschneider",
      "html_url": "https://github.com/ryanschneider",
      "followers_url": "https://api.github.com/users/ryanschneider/followers",
      "following_url": "https://api.github.com/users/ryanschneider/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanschneider/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanschneider/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanschneider/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanschneider/orgs",
      "repos_url": "https://api.github.com/users/ryanschneider/repos",
      "events_url": "https://api.github.com/users/ryanschneider/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanschneider/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-01-22T15:45:54Z",
    "updated_at": "2021-01-22T15:45:54Z",
    "author_association": "CONTRIBUTOR",
    "body": "> > but then the header was sent to all the other peers (or maybe all peers).\r\n> \r\n> Nope, AFAICT it's not the header, it's the announcement of new `(hash, number)` pairs\r\n\r\nHmm, you are 100% correct it is the announcement not the header itself that's sent, my mistake.\r\n\r\nBut.. in response to the announcement if I'm tracing things correctly it's the block _fetcher_ not the _downloader_ that in turn ultimately issues a `GetBlockHeadersMsg` message in response to this announcement via `blockFetcher.Notifty(..., peer.RequestOneHeader, ...)` here:\r\n\r\nhttps://github.com/ethereum/go-ethereum/blob/017831dd5b33a68076aed7c9ff05e62b0dcb5f92/eth/handler_eth.go#L195\r\n\r\nSo while even less likely now, I think it's still _possible_ that in between node B asking for headers N to M and node A replying with those headers that separately node A announces header Z, node B seems that announcement and then the fetcher issues `GetBlockHeadersMsg(Z)` which ends up conflicting with the expected `GetBlockHeadersMsg(N...M)` message.\r\n\r\nHere's a quickly thrown together sequence diagram to (maybe? :) ) help explain what I'm seeing:\r\n\r\nhttps://www.websequencediagrams.com/files/render?link=BFo7YS3IAbAcur7g5oW4yI4WMeQslFNEdgNnLYyIKZty2JgIehVPAWLDhK1xUyhm\r\n\r\n<img src=\"https://www.websequencediagrams.com/files/render?link=BFo7YS3IAbAcur7g5oW4yI4WMeQslFNEdgNnLYyIKZty2JgIehVPAWLDhK1xUyhm\">",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/765497214/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/765500772",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/22209#issuecomment-765500772",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/22209",
    "id": 765500772,
    "node_id": "MDEyOklzc3VlQ29tbWVudDc2NTUwMDc3Mg==",
    "user": {
      "login": "ryanschneider",
      "id": 53520,
      "node_id": "MDQ6VXNlcjUzNTIw",
      "avatar_url": "https://avatars.githubusercontent.com/u/53520?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanschneider",
      "html_url": "https://github.com/ryanschneider",
      "followers_url": "https://api.github.com/users/ryanschneider/followers",
      "following_url": "https://api.github.com/users/ryanschneider/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanschneider/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanschneider/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanschneider/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanschneider/orgs",
      "repos_url": "https://api.github.com/users/ryanschneider/repos",
      "events_url": "https://api.github.com/users/ryanschneider/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanschneider/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-01-22T15:50:39Z",
    "updated_at": "2021-01-22T15:50:39Z",
    "author_association": "CONTRIBUTOR",
    "body": "Anyways I'm very curious what your thoughts are on the idea of reenqueuing the \"unexpected\" messages instead of discarding them or erring out, if I recall correctly I've seen geth take that approach in other parts of the code but am having trouble finding where.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/765500772/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/765512015",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/22209#issuecomment-765512015",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/22209",
    "id": 765512015,
    "node_id": "MDEyOklzc3VlQ29tbWVudDc2NTUxMjAxNQ==",
    "user": {
      "login": "holiman",
      "id": 142290,
      "node_id": "MDQ6VXNlcjE0MjI5MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/142290?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/holiman",
      "html_url": "https://github.com/holiman",
      "followers_url": "https://api.github.com/users/holiman/followers",
      "following_url": "https://api.github.com/users/holiman/following{/other_user}",
      "gists_url": "https://api.github.com/users/holiman/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/holiman/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/holiman/subscriptions",
      "organizations_url": "https://api.github.com/users/holiman/orgs",
      "repos_url": "https://api.github.com/users/holiman/repos",
      "events_url": "https://api.github.com/users/holiman/events{/privacy}",
      "received_events_url": "https://api.github.com/users/holiman/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-01-22T16:05:08Z",
    "updated_at": "2021-01-22T16:05:08Z",
    "author_association": "MEMBER",
    "body": "Yeah, that diagram looks like it could be a potential cause of these types of errors. With eth/66, these types of problems will go away. In the meantime, my fix will improve it a tiny bit, and seems pretty safe. If we instead do some more elaborate pushback/store thingy, that sounds pretty complex if we also want it not to be a DoS vector. I think.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/765512015/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
