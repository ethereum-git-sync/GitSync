{
  "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/23427",
  "repository_url": "https://api.github.com/repos/ethereum/go-ethereum",
  "labels_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/23427/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/23427/comments",
  "events_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/23427/events",
  "html_url": "https://github.com/ethereum/go-ethereum/issues/23427",
  "id": 975587366,
  "node_id": "MDU6SXNzdWU5NzU1ODczNjY=",
  "number": 23427,
  "title": "Trie pruning v9000",
  "user": {
    "login": "karalabe",
    "id": 129561,
    "node_id": "MDQ6VXNlcjEyOTU2MQ==",
    "avatar_url": "https://avatars.githubusercontent.com/u/129561?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/karalabe",
    "html_url": "https://github.com/karalabe",
    "followers_url": "https://api.github.com/users/karalabe/followers",
    "following_url": "https://api.github.com/users/karalabe/following{/other_user}",
    "gists_url": "https://api.github.com/users/karalabe/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/karalabe/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/karalabe/subscriptions",
    "organizations_url": "https://api.github.com/users/karalabe/orgs",
    "repos_url": "https://api.github.com/users/karalabe/repos",
    "events_url": "https://api.github.com/users/karalabe/events{/privacy}",
    "received_events_url": "https://api.github.com/users/karalabe/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 72233652,
      "node_id": "MDU6TGFiZWw3MjIzMzY1Mg==",
      "url": "https://api.github.com/repos/ethereum/go-ethereum/labels/type:feature",
      "name": "type:feature",
      "color": "84b6eb",
      "default": false,
      "description": null
    }
  ],
  "state": "open",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 18,
  "created_at": "2021-08-20T12:58:00Z",
  "updated_at": "2022-06-28T07:03:07Z",
  "closed_at": null,
  "author_association": "MEMBER",
  "active_lock_reason": null,
  "body": "***[Credits: This is a summary of various ideas from @rjl493456442, @fjl and myself]***\r\n\r\nCurrently Geth's trie pruning is based on an in-memory (refcount based) garbage collector. This works well as long as all the freshly inserted dirty nodes fit into memory. When we exceed our dirty cache allowance, we need to overflow trie nodes to disk. To maximize the probability that flushed trie nodes will live long (not pruned), the flush order is older nodes first. The downside is that these nodes often will form dangling subtries (since the roots will get GCd) that are very hard to find and remove from disk.\r\n\r\nIn general, the root cause why pruning is hard is that states belonging to different blocks share almost the same data, so to avoid copying the state for every block, common parts are deduplicated in the database. However, once arbitrarily many and arbitrarily old blocks reference the same data, it becomes extremely expensive to decide when certain trie data becomes unreferenced and can be cleaned up. Historically we've tried various attempts at storing extra metadata (parent links, ref counts, ensuring only full tries are written) and using those to prune, but they all suffered from the same problem: shuffling persistent metadata at our order of magnitude is unfeasible.\r\n\r\nThe theoretical solution for pruning is to ensure that we always know - without computation - which block a certain state (or state portion) belongs to, allowing us to easily delete things that are not referenced any more. Of course, with state tries weighing 90GB, reduplicating trie nodes is out of the question. Retaining our current storage mechanisms, the only way to know exactly which block a state trie belongs to, is to actually only ever store a single state trie.\r\n\r\nThis is not a new concept, we're doing the same thing in the snapshotter: we have a single persistent snapshot on disk at a relatively recent block - but older than reasonable reorg depths - and we have a number of in-memory diff layers that are used for mini reorgs. As the chain progresses, we gradually flatten older diff layers to the persistent disk layer, pushing it forward. But there's always a single state snapshot that corresponds to a well defined block.\r\n\r\nThe proposal is to do the same thing for tries. Instead of maintaining potentially infinite (and potentially dangling) tries in our database that cross link to each other all over the place, we can chose to maintain a single trie persisted to disk (the same as the persistent snapshot layer); and keep all newer tries (the changes) in memory only. Whenever we flush any data into the snapshot layer, we atomically also flush the same data into the trie.\r\n\r\nOf course, the devil's in the details.\r\n\r\n## Reduplicate storage\r\n\r\nCurrently we only ever insert trie data into the database, but we never delete. The idea outlined here - of storing a single trie - however requires deletion (e.g. an account is changed, the old leaf needs to be removed; or a storage a slot is freed up). The problem is, currently storage tries are deduplicated and nodes are stored by hash. This means, figuring out if a storage trie node can be deleted is almost exactly the same pruning problem as we have globally (since storage tries reference each other).\r\n\r\nThe upside is that contract storage is small and mostly unique. As such, the best solution to get rid of the optimization that deduplicated storage tries, and instead make each contract have it's own dedicated namespace on disk. This would end up wasting some disk space, but will allow us to decide if a slot can be deleted with only local information, ignoring that other contracts might or might not store the same data. The namespace would be the contract address hash (i.e. the path in the account trie).\r\n\r\nThis isn't a new idea either, the snapshotter does exactly the same thing for the exact same reasons. The catch with the trie storage is that this new model breaks our capacity to support fast sync. This is because fast sync requires `hash -> trie node` lookups. By reduplicating storage, the added namespace in the database prevents us from finding a node by hash. This is also the main reason why we couldn't do any of these optimizations until now. However, since the introduction of snap sync, the state heal phase uses path based trie node lookups.\r\n\r\nLong story short, maintaining a single trie in the database requires reduplicating the storage trie nodes and storing them under the contract address hash namespace; and doing that requires us to either drop support for serving `GetNodeData` in `eth/66`. Other clients violated this protocol requirement a long time ago, so yeah, YOLO?\r\n\r\n## Super finality\r\n\r\nCurrently Geth has a notion of \"chain immutability threshold\", which is essentially a limit on the number of blocks Geth is willing to reorg. The limit is set so that a malicious node is unable to feed us an alternate chain from the genesis block (which would be easy to mine). Of course an attacker wouldn't be able to feed us a \"better\" chain, but it's also important to prevent them making us do a lot of work before figuring that out.\r\n\r\nThe immutability threshold is set to 3 epochs (~two wooks). This might seem excessive - and indeed Geth is the only client on the network which can do this - but the rationale is that *bugs happen.* In case there's a consensus issue in Geth, it can take a few hours to diagnose and patch, after it can take more hours or days for everyone to upgrade. If both good and bad chains move in the mean time, it can happen that the reorg would become deeper than allowed and clients get stuck on the bad chain. This is indeed what happens on pretty much every other client: they often reqire their users to resync from Geth. Geth until now successfully handled deep reorgs both caused by consensus issues as well as by attacks on testnets. The 2 weeks was chosen as a worst case scenario to fix things.\r\n\r\nBack to the issue at hand, the catch with the long immutability threshold is that Geth needs to retain the ability to do such a deep reorg. Currently our leaky-insert-only-trie implicitly satisfies this, since all that trie data we occasionally write to disk remains on disk, so a deep reorg will eventually find a block that has full state available. If we fix the trie to be singleton, we may also lose the ability to reorg beyond it.\r\n\r\nThings aren't that bad though. A healthy network is never expected to do deeper reorgs than a handful of blocks. This is an important observation, because it means that although we need to retain the capability to do a deep reorg, we can afford to make it arbitrarily expensive (computationally), since it will only happen in exceptional scenarios. Instead of maintaining quickly accessible old state, we only need to have a capacity to regenerate old state.\r\n\r\nThe solution to that is to retain a batch of reverse diffs up to the immutability threshold. These diffs are essentially the same as the snapshot diff layers, the catch is that they can in theory be arbitrarily large (e.g. deleting crypto kitties would make for a hefty diff). As such, the reverse diffs are ought to be stored outside of leveldb in a format where appending to the end and popping of both front (chain moved ahead) and end (chan reorgs) is fast.\r\n\r\nLong story short, we need a reverse diff format and a persistent storage mechanism for it; as well as a way to move both the persistent snapshot and our singleton trie backwards in history based on these reverse diffs; up until the chain immutability threshold.\r\n\r\n*Let's call the `chain immutability threshold` from now on `super finality` to make fun of Eth 2, because they will need the same mechanism to be able to reorg finalized blocks.*\r\n\r\n## Tree of tries\r\n\r\nThe above few sections defined how we can maintain a singleton state trie and how we can manage deep reorgs. The last piece of the puzzle is how to handle shallow reorgs (shorter than the depth of the persistent singleton trie). Snapshots do this via a tree of in-memory diff layers, which are flattened into the persistent disk layer when the chain moves far enough. This model would work for updating the persistent singleton trie, but it does not support calculating root hashes while doing mini reorgs.\r\n\r\nThe current trie dirty cache and in-memory garbage collection could be used to maintain the tree of tries, moving the window forward as the chain progresses, but the question is how to clean up dirty data that we've flattened out of bounds into the persistent trie. Additions are simple, any node added to the singleton trie would be deleted from the dirty cache.The problem arises when an attempt is made to delete a node from the singleton disk trie, but that node is referenced by an in-memory trie later (e.g. a slot is unset and later reset). That would require moving the node deleted from disk back into the dirty cache, which might be both brittle and perhaps even computationally too expensive.\r\n\r\nBefore figuring this part out, an important thing would be to have a clear benchmark that puts a number on the trie nodes added and removed in current mainnet blocks. That could help us figure out what the churn is, and whether we can afford to duplicate some data across tries. Getting rid of the in-memory GC altogether would make everything a lot simpler, as long as we can make it work somehow.\r\n\r\nLong story short: we need to collect some metrics on the trie churn and start monitoring it, then figure out a data model that allows us to cheaply maintain recent state, whilst also supporting pruning it as the chain progresses.\r\n\r\n## Feasibility\r\n\r\nOpposed to the current garbage collection based trie handling, enforcing a persistent singleton trie that follows the chain means that there is a well defined amount of data that needs to be inserted and deleted from the database at a constant rate. This may make or break the entire idea, so we need to benchmark what caching mechanism we could use to try and keep the disk writes low without affecting the general operation of the idea. The snapshots use the bottommost diff layer as an accumulation layer that buffers writes, trying to dedup modifications made to the same slots across multiple blocks. This may or may not work for tries, but it is important to answer the question before investing too much time in implementing everything.\r\n\r\n Attack plan\r\n\r\n- [ ] Spec `eth/67` that removes support for `GetNodeData` (for eventual protocol cleanup)\r\n- [ ] Stop serving `GetNodeData` in `eth/66` (other clients can use `snap/1` to retrieve the same data by path)\r\n- [ ] Reduplicate storage trie nodes under the account hash namespace\r\n- [ ] Define a reverse diff format and an efficient storage mechanism for it outside of leveldb\r\n- [ ] Implement support for applying reverse diffs to snapshots and state tries\r\n- [ ] Benchmark and/or monitor the state churn (additions and removals)\r\n- [ ] Based on how much data we juggle, either use simple duplications or more complex dedups.\r\n- [ ] Benchmark if an accumulation layer could help avoid trashing the db with updates after every block",
  "closed_by": null,
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/23427/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/23427/timeline",
  "performed_via_github_app": null,
  "state_reason": null
}
[
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/902853789",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/23427#issuecomment-902853789",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/23427",
    "id": 902853789,
    "node_id": "IC_kwDOAOvK98410HSd",
    "user": {
      "login": "qianbin",
      "id": 494645,
      "node_id": "MDQ6VXNlcjQ5NDY0NQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/494645?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/qianbin",
      "html_url": "https://github.com/qianbin",
      "followers_url": "https://api.github.com/users/qianbin/followers",
      "following_url": "https://api.github.com/users/qianbin/following{/other_user}",
      "gists_url": "https://api.github.com/users/qianbin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/qianbin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/qianbin/subscriptions",
      "organizations_url": "https://api.github.com/users/qianbin/orgs",
      "repos_url": "https://api.github.com/users/qianbin/repos",
      "events_url": "https://api.github.com/users/qianbin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/qianbin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-08-20T17:43:20Z",
    "updated_at": "2021-08-21T16:58:09Z",
    "author_association": "CONTRIBUTOR",
    "body": "When trying to increase the throughput to flush a MPT into leveldb, I found a nearly perfect way to prune a trie.\r\n\r\nAfter many tries, i realized that there's no much space to increase KV throughput by optimizing a LSM based db. But how if saving trie nodes in order? Then I tried to tweak the trie node persistent KV pair from \r\n\r\n    hash => RLP(node)\r\nto\r\n\r\n    big-endian-uint32(blockNum) || hash => RLP(node) || RLP(child hash node blockNums)\r\n\r\nBy doing so, write throughput is extremely boosted. Every leveldb major compaction finishes immediately, because SSTs are not overlapped.\r\n\r\nHave to sleep. To be continued.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/902853789/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/903085926",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/23427#issuecomment-903085926",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/23427",
    "id": 903085926,
    "node_id": "IC_kwDOAOvK98410_9m",
    "user": {
      "login": "fjl",
      "id": 6915,
      "node_id": "MDQ6VXNlcjY5MTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6915?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fjl",
      "html_url": "https://github.com/fjl",
      "followers_url": "https://api.github.com/users/fjl/followers",
      "following_url": "https://api.github.com/users/fjl/following{/other_user}",
      "gists_url": "https://api.github.com/users/fjl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fjl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fjl/subscriptions",
      "organizations_url": "https://api.github.com/users/fjl/orgs",
      "repos_url": "https://api.github.com/users/fjl/repos",
      "events_url": "https://api.github.com/users/fjl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fjl/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-08-21T09:00:42Z",
    "updated_at": "2021-08-21T09:00:42Z",
    "author_association": "MEMBER",
    "body": "It should not noted that this state storage scheme makes it impossible to perform historical chain tracing.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/903085926/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/903144749",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/23427#issuecomment-903144749",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/23427",
    "id": 903144749,
    "node_id": "IC_kwDOAOvK98411OUt",
    "user": {
      "login": "qianbin",
      "id": 494645,
      "node_id": "MDQ6VXNlcjQ5NDY0NQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/494645?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/qianbin",
      "html_url": "https://github.com/qianbin",
      "followers_url": "https://api.github.com/users/qianbin/followers",
      "following_url": "https://api.github.com/users/qianbin/following{/other_user}",
      "gists_url": "https://api.github.com/users/qianbin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/qianbin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/qianbin/subscriptions",
      "organizations_url": "https://api.github.com/users/qianbin/orgs",
      "repos_url": "https://api.github.com/users/qianbin/repos",
      "events_url": "https://api.github.com/users/qianbin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/qianbin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-08-21T16:57:19Z",
    "updated_at": "2021-08-21T17:07:20Z",
    "author_association": "CONTRIBUTOR",
    "body": "> Have to sleep. To be continued.\r\n\r\nThe key point of my idea is: **Trie nodes with the same path are duplicated, and older ones can be safely deleted**.\r\n\r\nTill now, with blockNum prefix, we know which trie node is older, but have no idea about its position, or say path. Re-tweak the node persistent KV like this:\r\n\r\n     path || big-endian-uint32(blockNum) || hash => RLP(node) || RLP(child hash node blockNums)\r\n\r\nAssume we want to prune duplicated trie nodes between block number [M, N), where N satisfies \"chain immutability threshold\", and there is a node iterator which can filter out trie nodes by block number. The pseudo code will be:\r\n\r\n```go\r\nmask := make(map[string]uint32)\r\n\r\n// filter out trie(N)'s nodes produced after block M, and \r\n// construct the map from path to block number the node belongs to.\r\nit := NewTrie(rootN).NodeIterator(bn => bn > M) \r\nfor it.Next() {\r\n    mask[string(it.Path())] = it.BlockNum()\r\n}\r\n\r\ndbIt := db.NewIterator(trieSpacePrefix)\r\nfor dbIt.Next() {\r\n    key := dbIt.Key()\r\n    path := key[len(key) - 32 - 4:]\r\n    bn := uint32(key[len(path):])\r\n    // the current node is older than N's.\r\n    if bn < mask[path] {\r\n        db.Delete(key)\r\n    }\r\n}\r\n```\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/903144749/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/903316498",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/23427#issuecomment-903316498",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/23427",
    "id": 903316498,
    "node_id": "IC_kwDOAOvK984114QS",
    "user": {
      "login": "jochem-brouwer",
      "id": 29359032,
      "node_id": "MDQ6VXNlcjI5MzU5MDMy",
      "avatar_url": "https://avatars.githubusercontent.com/u/29359032?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jochem-brouwer",
      "html_url": "https://github.com/jochem-brouwer",
      "followers_url": "https://api.github.com/users/jochem-brouwer/followers",
      "following_url": "https://api.github.com/users/jochem-brouwer/following{/other_user}",
      "gists_url": "https://api.github.com/users/jochem-brouwer/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jochem-brouwer/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jochem-brouwer/subscriptions",
      "organizations_url": "https://api.github.com/users/jochem-brouwer/orgs",
      "repos_url": "https://api.github.com/users/jochem-brouwer/repos",
      "events_url": "https://api.github.com/users/jochem-brouwer/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jochem-brouwer/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-08-22T19:10:36Z",
    "updated_at": "2021-08-22T19:10:36Z",
    "author_association": "MEMBER",
    "body": "Will there be an alternative for `GetNodeData` in `eth/67`?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/903316498/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/903398692",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/23427#issuecomment-903398692",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/23427",
    "id": 903398692,
    "node_id": "IC_kwDOAOvK98412MUk",
    "user": {
      "login": "rjl493456442",
      "id": 5959481,
      "node_id": "MDQ6VXNlcjU5NTk0ODE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5959481?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/rjl493456442",
      "html_url": "https://github.com/rjl493456442",
      "followers_url": "https://api.github.com/users/rjl493456442/followers",
      "following_url": "https://api.github.com/users/rjl493456442/following{/other_user}",
      "gists_url": "https://api.github.com/users/rjl493456442/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/rjl493456442/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/rjl493456442/subscriptions",
      "organizations_url": "https://api.github.com/users/rjl493456442/orgs",
      "repos_url": "https://api.github.com/users/rjl493456442/repos",
      "events_url": "https://api.github.com/users/rjl493456442/events{/privacy}",
      "received_events_url": "https://api.github.com/users/rjl493456442/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-08-23T02:39:10Z",
    "updated_at": "2021-08-23T02:39:10Z",
    "author_association": "MEMBER",
    "body": "@jochem-brouwer The path-based trie node retrieval is still available. https://github.com/ethereum/devp2p/blob/master/caps/snap.md#gettrienodes-0x06 ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/903398692/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/903511422",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/23427#issuecomment-903511422",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/23427",
    "id": 903511422,
    "node_id": "IC_kwDOAOvK98412n1-",
    "user": {
      "login": "karalabe",
      "id": 129561,
      "node_id": "MDQ6VXNlcjEyOTU2MQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/129561?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/karalabe",
      "html_url": "https://github.com/karalabe",
      "followers_url": "https://api.github.com/users/karalabe/followers",
      "following_url": "https://api.github.com/users/karalabe/following{/other_user}",
      "gists_url": "https://api.github.com/users/karalabe/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/karalabe/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/karalabe/subscriptions",
      "organizations_url": "https://api.github.com/users/karalabe/orgs",
      "repos_url": "https://api.github.com/users/karalabe/repos",
      "events_url": "https://api.github.com/users/karalabe/events{/privacy}",
      "received_events_url": "https://api.github.com/users/karalabe/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-08-23T07:23:24Z",
    "updated_at": "2021-08-23T07:23:24Z",
    "author_association": "MEMBER",
    "body": "@jochem-brouwer @rjl493456442 I guess the question is whether we should duplicate the same functionality in eth/67 too, or rely only on snap. The latter is cleaner, but more effort for other clients.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/903511422/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/903628296",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/23427#issuecomment-903628296",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/23427",
    "id": 903628296,
    "node_id": "IC_kwDOAOvK98413EYI",
    "user": {
      "login": "karalabe",
      "id": 129561,
      "node_id": "MDQ6VXNlcjEyOTU2MQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/129561?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/karalabe",
      "html_url": "https://github.com/karalabe",
      "followers_url": "https://api.github.com/users/karalabe/followers",
      "following_url": "https://api.github.com/users/karalabe/following{/other_user}",
      "gists_url": "https://api.github.com/users/karalabe/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/karalabe/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/karalabe/subscriptions",
      "organizations_url": "https://api.github.com/users/karalabe/orgs",
      "repos_url": "https://api.github.com/users/karalabe/repos",
      "events_url": "https://api.github.com/users/karalabe/events{/privacy}",
      "received_events_url": "https://api.github.com/users/karalabe/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-08-23T10:08:26Z",
    "updated_at": "2021-08-23T10:08:26Z",
    "author_association": "MEMBER",
    "body": "@qianbin \r\n\r\n> Assume we want to prune duplicated trie nodes between block number [M, N), where N satisfies \"chain immutability threshold\", **and there is a node iterator which can filter out trie nodes by block number**.\r\n\r\nThat's what you can't do :) You can have a state item be deleted in one block, and then recreated some number of blocks later. The recreation would insert the same nodes at the same paths as the initial ones before deletion, but when you're \"pruning\", you wouldn't know there's a later reference to the original data and you'd delete it. The state being 90GB is size, you can't duplicate shared subtries across blocks.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/903628296/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/903729982",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/23427#issuecomment-903729982",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/23427",
    "id": 903729982,
    "node_id": "IC_kwDOAOvK98413dM-",
    "user": {
      "login": "rjl493456442",
      "id": 5959481,
      "node_id": "MDQ6VXNlcjU5NTk0ODE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5959481?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/rjl493456442",
      "html_url": "https://github.com/rjl493456442",
      "followers_url": "https://api.github.com/users/rjl493456442/followers",
      "following_url": "https://api.github.com/users/rjl493456442/following{/other_user}",
      "gists_url": "https://api.github.com/users/rjl493456442/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/rjl493456442/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/rjl493456442/subscriptions",
      "organizations_url": "https://api.github.com/users/rjl493456442/orgs",
      "repos_url": "https://api.github.com/users/rjl493456442/repos",
      "events_url": "https://api.github.com/users/rjl493456442/events{/privacy}",
      "received_events_url": "https://api.github.com/users/rjl493456442/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-08-23T12:43:10Z",
    "updated_at": "2021-08-30T07:35:26Z",
    "author_association": "MEMBER",
    "body": "### Tree of tries\r\n\r\nThe live tries can be organized in the tree model, a base layer with the singleton persisted trie and several layers with the trie diffs introduced in the relevant block.\r\n\r\nIn the persisted trie, all the newly added or updated trie nodes are flushed to the disk, may or may not overwritten the original version with the same trie path. The newly deleted trie nodes will be deleted from the disk. That's say, the persisted trie is supposed to be complete and no dangling trie nodes leak.\r\n\r\n### Deletion detection\r\n\r\nCompared with the trie node addition and updating, deletion is slightly complicated. There are some cases for describing the deletion scenarios:\r\n\r\n- A slot is removed from the contract, which leads to a shortNode deleted from the parent fullNode.\r\n- A slot is removed from the contract, which leads to a shortNode deleted and the parent fullNode is embedded into its parent(shortNode), 2 nodes are deleted.\r\n- The contract is deleted, the entire storage is deleted.\r\n\r\nBut these deletion information are available in the Trie. That's say, for each block, we can obtain a list of deleted trie nodes and mark them as DELETED in the diff layer. These nodes shouldn't be accessed later and eventually get deleted from the disk.\r\n\r\nNote, the correctness won't be affected if the deleted nodes are not removed from the disk, but it's not good to have the dangling trie nodes.\r\n\r\n### The relationship with in-memory pruner\r\n\r\nIn the tries-tree, the bloom diff layer can contain several diff layers by merging the trie node mutations together. It's pretty useful for the top nodes(e.g. root node) seems they are usually modified in each block. Thus the real disk writes are reduced. \r\n\r\nAlthough the bottom diff layer can act as the \"in-memory pruner\" to some extend, but it's still not that efficient like the reference-counter based in-memory pruner, mainly the following points:\r\n- In reference-counter based pruner, if the node is not referenced then it's not persisted. But in the layered tries, the bottom diff layer must be persisted even the data inside is already stale\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/903729982/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/903891734",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/23427#issuecomment-903891734",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/23427",
    "id": 903891734,
    "node_id": "IC_kwDOAOvK98414EsW",
    "user": {
      "login": "qianbin",
      "id": 494645,
      "node_id": "MDQ6VXNlcjQ5NDY0NQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/494645?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/qianbin",
      "html_url": "https://github.com/qianbin",
      "followers_url": "https://api.github.com/users/qianbin/followers",
      "following_url": "https://api.github.com/users/qianbin/following{/other_user}",
      "gists_url": "https://api.github.com/users/qianbin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/qianbin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/qianbin/subscriptions",
      "organizations_url": "https://api.github.com/users/qianbin/orgs",
      "repos_url": "https://api.github.com/users/qianbin/repos",
      "events_url": "https://api.github.com/users/qianbin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/qianbin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-08-23T15:45:55Z",
    "updated_at": "2021-08-23T15:47:10Z",
    "author_association": "CONTRIBUTOR",
    "body": "> @qianbin\r\n> \r\n> > Assume we want to prune duplicated trie nodes between block number [M, N), where N satisfies \"chain immutability threshold\", **and there is a node iterator which can filter out trie nodes by block number**.\r\n> \r\n> That's what you can't do :) You can have a state item be deleted in one block, and then recreated some number of blocks later. The recreation would insert the same nodes at the same paths as the initial ones before deletion, but when you're \"pruning\", you wouldn't know there's a later reference to the original data and you'd delete it. The state being 90GB is size, you can't duplicate shared subtries across blocks.\r\n\r\nYes, the recreation produced the same nodes content, but according to the new storage scheme, these nodes are totally new and have larger block number prefix (larger lexicographical order). So delete older nodes won't break the new trie.\r\n\r\nI forgot to tell the side effect of the new scheme. With path as prefix, trie nodes iteration will be much faster than with bare hash key. With path and block number combined prefix, we can get very high compression ratio ( > 2 in practice).\r\n\r\n ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/903891734/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/904353718",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/23427#issuecomment-904353718",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/23427",
    "id": 904353718,
    "node_id": "IC_kwDOAOvK984151e2",
    "user": {
      "login": "rjl493456442",
      "id": 5959481,
      "node_id": "MDQ6VXNlcjU5NTk0ODE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5959481?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/rjl493456442",
      "html_url": "https://github.com/rjl493456442",
      "followers_url": "https://api.github.com/users/rjl493456442/followers",
      "following_url": "https://api.github.com/users/rjl493456442/following{/other_user}",
      "gists_url": "https://api.github.com/users/rjl493456442/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/rjl493456442/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/rjl493456442/subscriptions",
      "organizations_url": "https://api.github.com/users/rjl493456442/orgs",
      "repos_url": "https://api.github.com/users/rjl493456442/repos",
      "events_url": "https://api.github.com/users/rjl493456442/events{/privacy}",
      "received_events_url": "https://api.github.com/users/rjl493456442/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-08-24T06:14:48Z",
    "updated_at": "2022-06-28T07:03:07Z",
    "author_association": "MEMBER",
    "body": "## Node path encoding\r\n\r\nIn the new state scheme, the trie node key is encoded by node path in order to get rid of data redundancy. Since upgrading state scheme requires a node resync. It's a super hard step for us. We should carefully pick the state scheme. I have a few key format proposals, just list them here for some inputs.\r\n\r\nNote for storage trie, the key is prefixed with an additional 32bytes namespace. It's the corresponding account hash. The reason is described above by Peter. The path discussed here refers to the node path inside the tree.\r\n\r\n### COMPACT encoding\r\n\r\nIn Geth, usually the path is encoded with COMPACT format which is defined by Yellow paper. It puts the flag in the high nibble and put all remaining key bytes in the following position. One proposal is to combine the COMPACT key encoding with a prefix as the trie node key.\r\n\r\nThe key scheme can be defined as this\r\n\r\n```jsx\r\naccount trie node key = Prefix(1byte) || COMPACTED(node_path)\r\nstorage trie node key = Prefix(1byte) || account hash(32byte) || COMPACTed(node_path)\r\n```\r\n\r\n### Reverse COMPACT encoding\r\n\r\nThe drawback of COMPACT encoding is it puts the flag in the high nibble. In the leveldb, the key shared with the previous entry will not be stored. It will break the continuity of database keys. \r\n\r\nFor example, we have two key paths: \r\n\r\n- `hex: []byte{1, 2, 3, 4, 5}` (no terminator)\r\n- `hex: []byte{1, 2, 3, 4, 5, 6}` (no terminator)\r\n\r\nThe COMPACT encoding are:\r\n\r\n- `compact: []byte{0x11, 0x23, 0x45}`\r\n- `compact: []byte{0x00, 0x12, 0x34, 0x56}`\r\n\r\nYou can see these two continuous keys are encoded with totally different result. We lose a lot of nice database properties, like data locality.\r\n\r\nSo we can twist the COMPACT encoding by putting the flag nibble in the end.\r\n\r\n```go\r\n// REVERSE-COMAPCT encoding is used for encoding trie node path in the trie node\r\n// database key. The main difference with COMPACT encoding is that the key flag\r\n// is put in the end of the key.\r\n//\r\n// e.g.\r\n// - the key [] is encoded as [0x00]\r\n// - the key [0x1, 0x2, 0x3] is encoded as [0x12, 0x31]\r\n// - the key [0x1, 0x2, 0x3, 0x0] is encoded as [0x12, 0x30, 0x00]\r\nfunc hexToReverseCompact(hex []byte) []byte {\r\n\tterminator := byte(0)\r\n\tif hasTerm(hex) {\r\n\t\tterminator = 1\r\n\t\thex = hex[:len(hex)-1]\r\n\t}\r\n\tbuf := make([]byte, len(hex)/2+1)\r\n\tbuf[len(buf)-1] = terminator << 1 // the flag byte\r\n\tif len(hex)&1 == 1 {\r\n\t\tbuf[len(buf)-1] |= 1                    // odd flag\r\n\t\tbuf[len(buf)-1] |= hex[len(hex)-1] << 4 // last nibble is contained in the last byte\r\n\t\thex = hex[:len(hex)-1]\r\n\t}\r\n\tdecodeNibbles(hex, buf[:len(buf)-1])\r\n\treturn buf\r\n}\r\n```\r\n\r\nThese two paths in this example will be encoded like this:\r\n\r\n- `reverse-compact: []byte{0x12, 0x34, 0x51}`\r\n- `reverse-compact: []byte{0x12, 0x34, 0x56, 0x00}`\r\n\r\nSo now most of the keys can be shared with each other. A lot of database space can be saved and also data locality is preserved.\r\n\r\n### Right-padding Reverse COMACT encoding\r\n\r\nReverse-COMPACT is still not perfect, since the trie node paths are not sorted strictly by the path. Let's see an example:\r\n\r\n- node A: `hex: []byte{1, 2, 3, 4, 5}` (no terminator)\r\n- node B: `hex: []byte{1, 2, 3, 4, 5, 0}` (no terminator)\r\n\r\nThe encoded key is:\r\n\r\n- node A: `reverse-compact: []byte{0x12, 0x34, 0x51}`\r\n- node B: `reverse-compact: []byte{0x12, 0x34, 0x50, 0x00}`\r\n\r\nThe encoded path A is literally larger than encoded path B, while the raw path is opposite.\r\n\r\nThis encoding format will have these drawback:\r\n\r\n- The ordered node key iteration is not supported\r\n- The key length is dynamic, can mix with legacy node key(32bytes)\r\n\r\nSo another encoding format can be considered, of course with trade-off. It's called right-padding reverse compact encoding.\r\n\r\nThe difference between the reverse-compact encoding is that the path will be right-padding with zero bytes until the fixed length, and the flag will be put in the end. So no matter how long the raw path is, the encoded path will have the fixed size. **But yes, the tradeoff is the encoded key is filled with useless zero bytes**.\r\n\r\nStill, in this example, let's assume the fixed length is 4:\r\n\r\n- node A: `right-padding-reverse-compact: []byte{0x12, 0x34, 0x50, 0x00, 0x05}`\r\n- node B: `right-padding-reverse-compact: []byte{0x12, 0x34, 0x50, 0x00, 0x06}`\r\n\r\nFor node A, the last nibble `byte(5)` concats another padded zero nibble, and the key is filled up to 4 bytes length. The last byte is a flag for indicating the key length.\r\n\r\nFor node B, the raw path `[]byte{1, 2, 3, 4, 5, 0}` is encoded to `[]byte{12, 34, 50}`. The also the last byte is a special flag indicating length information.\r\n\r\nIn ethereum, the path length should be 32. It means we will have countless zero bytes in node key. It's a huge disk space waste. Fortunately, the underlying database help us to compress the key. So in theory, the zero bytes should be compressed well.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/904353718/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/904371936",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/23427#issuecomment-904371936",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/23427",
    "id": 904371936,
    "node_id": "IC_kwDOAOvK9841557g",
    "user": {
      "login": "qianbin",
      "id": 494645,
      "node_id": "MDQ6VXNlcjQ5NDY0NQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/494645?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/qianbin",
      "html_url": "https://github.com/qianbin",
      "followers_url": "https://api.github.com/users/qianbin/followers",
      "following_url": "https://api.github.com/users/qianbin/following{/other_user}",
      "gists_url": "https://api.github.com/users/qianbin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/qianbin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/qianbin/subscriptions",
      "organizations_url": "https://api.github.com/users/qianbin/orgs",
      "repos_url": "https://api.github.com/users/qianbin/repos",
      "events_url": "https://api.github.com/users/qianbin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/qianbin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-08-24T06:53:14Z",
    "updated_at": "2021-08-24T06:53:14Z",
    "author_association": "CONTRIBUTOR",
    "body": "> ## Node path encoding\r\n> In the new state scheme, the trie node key is encoded by node path in order to get rid of data redundancy. Since upgrading state scheme requires a node resync. It's a super hard step for us. We should carefully pick the state scheme. I have a few key format proposals, just list them here for some inputs.\r\n> \r\n> Note for storage trie, the key is prefixed with an additional 32bytes namespace. It's the corresponding account hash. The reason is described above by Peter. The path discussed here refers to the node path inside the tree.\r\n> \r\n> ### COMPACT encoding\r\n> In Geth, usually the path is encoded with COMPACT format which is defined by Yellow paper. It puts the flag in the high nibble and put all remaining key bytes in the following position. One proposal is to combine the COMPACT key encoding with a prefix as the trie node key.\r\n> \r\n> The key scheme can be defined as this\r\n> \r\n> ```js\r\n> account trie node key = Prefix(1byte) || COMPACTED(node_path)\r\n> storage trie node key = Prefix(1byte) || account hash(32byte) || COMPACTed(node_path)\r\n> ```\r\n> \r\n> ### Reverse COMPACT encoding\r\n> The drawback of COMPACT encoding is it puts the flag in the high nibble. In the leveldb, the key shared with the previous entry will not be stored. It will break the continuity of database keys.\r\n> \r\n> For example, we have two key paths:\r\n> \r\n> * `hex: []byte{1, 2, 3, 4, 5}` (no terminator)\r\n> * `hex: []byte{1, 2, 3, 4, 5, 6}` (no terminator)\r\n> \r\n> The COMPACT encoding are:\r\n> \r\n> * `compact: []byte{0x11, 0x23, 0x45}`\r\n> * `compact: []byte{0x00, 0x12, 0x34, 0x56}`\r\n> \r\n> You can see these two continuous keys are encoded with totally different result. We lose a lot of nice database properties, like data locality.\r\n> \r\n> So we can twist the COMPACT encoding by putting the flag nibble in the end.\r\n> \r\n> ```go\r\n> // REVERSE-COMAPCT encoding is used for encoding trie node path in the trie node\r\n> // database key. The main difference with COMPACT encoding is that the key flag\r\n> // is put in the end of the key.\r\n> //\r\n> // e.g.\r\n> // - the key [] is encoded as [0x00]\r\n> // - the key [0x1, 0x2, 0x3] is encoded as [0x12, 0x31]\r\n> // - the key [0x1, 0x2, 0x3, 0x0] is encoded as [0x12, 0x30, 0x00]\r\n> func hexToReverseCompact(hex []byte) []byte {\r\n> \tterminator := byte(0)\r\n> \tif hasTerm(hex) {\r\n> \t\tterminator = 1\r\n> \t\thex = hex[:len(hex)-1]\r\n> \t}\r\n> \tbuf := make([]byte, len(hex)/2+1)\r\n> \tbuf[len(buf)-1] = terminator << 1 // the flag byte\r\n> \tif len(hex)&1 == 1 {\r\n> \t\tbuf[len(buf)-1] |= 1                    // odd flag\r\n> \t\tbuf[len(buf)-1] |= hex[len(hex)-1] << 4 // last nibble is contained in the last byte\r\n> \t\thex = hex[:len(hex)-1]\r\n> \t}\r\n> \tdecodeNibbles(hex, buf[:len(buf)-1])\r\n> \treturn buf\r\n> }\r\n> ```\r\n> \r\n> These two paths in this example will be encoded like this:\r\n> \r\n> * `reverse-compact: []byte{0x12, 0x34, 0x51}`\r\n> * `reverse-compact: []byte{0x12, 0x34, 0x56, 0x00}`\r\n> \r\n> So now most of the keys can be shared with each other. A lot of database space can be saved and also data locality is preserved.\r\n> \r\n> ### Right-padding Reverse COMACT encoding\r\n> Reverse-COMPACT is still not perfect, since the trie node paths are not sorted strictly by the path. Let's see an example:\r\n> \r\n> * node A: `hex: []byte{1, 2, 3, 4, 5}` (no terminator)\r\n> * node B: `hex: []byte{1, 2, 3, 4, 5, 0}` (no terminator)\r\n> \r\n> The encoded key is:\r\n> \r\n> * node A: `reverse-compact: []byte{0x12, 0x34, 0x51}`\r\n> * node B: `reverse-compact: []byte{0x12, 0x34, 0x50, 0x00}`\r\n> \r\n> The encoded path A is literally larger than encoded path B, while the raw path is opposite.\r\n> \r\n> This encoding format will have these drawback:\r\n> \r\n> * The ordered node key iteration is not supported\r\n> * To-be-filled\r\n> \r\n> So another encoding format can be considered, of course with trade-off. It's called right-padding reverse compact encoding.\r\n> \r\n> The difference between the reverse-compact encoding is that the path will be right-padding with zero bytes until the fixed length, and the flag will be put in the end. So no matter how long the raw path is, the encoded path will have the fixed size. **But yes, the tradeoff is the encoded key is filled with useless zero bytes**.\r\n> \r\n> Still, in this example, let's assume the fixed length is 4:\r\n> \r\n> * node A: `right-padding-reverse-compact: []byte{0x12, 0x34, 0x50, 0x00, 0x05}`\r\n> * node B: `right-padding-reverse-compact: []byte{0x12, 0x34, 0x50, 0x00, 0x06}`\r\n> \r\n> For node A, the last nibble `byte(5)` concats another padded zero nibble, and the key is filled up to 4 bytes length. The last byte is a flag for indicating the key length.\r\n> \r\n> For node B, the raw path `[]byte{1, 2, 3, 4, 5, 0}` is encoded to `[]byte{12, 34, 50}`. The also the last byte is a special flag indicating length information.\r\n> \r\n> In ethereum, the path length should be 32. It means we will have countless zero bytes in node key. It's a huge disk space waste. Fortunately, the underlying database help us to compress the key. So in theory, the zero bytes should be compressed well.\r\n\r\nI have another fixed-length scheme suggestion which was applied in my project. \r\nIt compact node path into uint64 (8 bytes). The first 60 bits is filled up to 15 nibbles and the rest 4 bits indicates path length. \r\n```go\r\n// path64 uses uint64 to present the trie node path and follows the order of trie node iteration.\r\n// Paths longer than 15 will be trimmed to 15.\r\ntype path64 uint64\r\n\r\n// newPath64 convert the trie node path into path64.\r\nfunc newPath64(path []byte) path64 {\r\n\tn := len(path)\r\n\tif n > 15 {\r\n\t\tn = 15\r\n\t}\r\n\r\n\tvar p path64\r\n\tfor i := 0; i < 15; i++ {\r\n\t\tif i < n {\r\n\t\t\tp |= path64(path[i])\r\n\t\t}\r\n\t\tp <<= 4\r\n\t}\r\n\treturn p | path64(n)\r\n}\r\n```\r\n For those nodes with path length > 15, we can alloc a new space for  them. 16 ^ 15 is big, so there won't be many long path nodes .",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/904371936/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/904393087",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/23427#issuecomment-904393087",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/23427",
    "id": 904393087,
    "node_id": "IC_kwDOAOvK98415_F_",
    "user": {
      "login": "rjl493456442",
      "id": 5959481,
      "node_id": "MDQ6VXNlcjU5NTk0ODE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5959481?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/rjl493456442",
      "html_url": "https://github.com/rjl493456442",
      "followers_url": "https://api.github.com/users/rjl493456442/followers",
      "following_url": "https://api.github.com/users/rjl493456442/following{/other_user}",
      "gists_url": "https://api.github.com/users/rjl493456442/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/rjl493456442/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/rjl493456442/subscriptions",
      "organizations_url": "https://api.github.com/users/rjl493456442/orgs",
      "repos_url": "https://api.github.com/users/rjl493456442/repos",
      "events_url": "https://api.github.com/users/rjl493456442/events{/privacy}",
      "received_events_url": "https://api.github.com/users/rjl493456442/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-08-24T07:27:18Z",
    "updated_at": "2021-08-24T07:27:18Z",
    "author_association": "MEMBER",
    "body": "@qianbin It's worthwhile for experiments. Thanks for sharing.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/904393087/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/905738323",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/23427#issuecomment-905738323",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/23427",
    "id": 905738323,
    "node_id": "IC_kwDOAOvK9841_HhT",
    "user": {
      "login": "axic",
      "id": 20340,
      "node_id": "MDQ6VXNlcjIwMzQw",
      "avatar_url": "https://avatars.githubusercontent.com/u/20340?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/axic",
      "html_url": "https://github.com/axic",
      "followers_url": "https://api.github.com/users/axic/followers",
      "following_url": "https://api.github.com/users/axic/following{/other_user}",
      "gists_url": "https://api.github.com/users/axic/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/axic/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/axic/subscriptions",
      "organizations_url": "https://api.github.com/users/axic/orgs",
      "repos_url": "https://api.github.com/users/axic/repos",
      "events_url": "https://api.github.com/users/axic/events{/privacy}",
      "received_events_url": "https://api.github.com/users/axic/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-08-25T17:37:24Z",
    "updated_at": "2021-08-25T17:38:04Z",
    "author_association": "MEMBER",
    "body": "This may have been considered while drafting up the above plan, but if not, I'd suggest for consideration the key encoding scheme presented in https://notes.ethereum.org/@vbuterin/verkle_tree_eip#Specification.  I know this is work in progress (and cannot be used as-is because it changes other assumptions) and potentially under redesign currently, but if these schemes could be somewhat aligned, that could save some headache (recoding / resyncing) down the line.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/905738323/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/906903762",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/23427#issuecomment-906903762",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/23427",
    "id": 906903762,
    "node_id": "IC_kwDOAOvK9842DkDS",
    "user": {
      "login": "rjl493456442",
      "id": 5959481,
      "node_id": "MDQ6VXNlcjU5NTk0ODE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5959481?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/rjl493456442",
      "html_url": "https://github.com/rjl493456442",
      "followers_url": "https://api.github.com/users/rjl493456442/followers",
      "following_url": "https://api.github.com/users/rjl493456442/following{/other_user}",
      "gists_url": "https://api.github.com/users/rjl493456442/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/rjl493456442/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/rjl493456442/subscriptions",
      "organizations_url": "https://api.github.com/users/rjl493456442/orgs",
      "repos_url": "https://api.github.com/users/rjl493456442/repos",
      "events_url": "https://api.github.com/users/rjl493456442/events{/privacy}",
      "received_events_url": "https://api.github.com/users/rjl493456442/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-08-27T03:51:14Z",
    "updated_at": "2021-08-27T03:52:02Z",
    "author_association": "MEMBER",
    "body": "@axic thanks for remaining. The key encoding scheme I proposed here is for database key. It's also suitable for verkle tree.\r\n\r\nTo be more precise, there are two \"keys\": the node path in trie and the database key for storing the trie node. \r\nFor the former one, MPT uses the account address hash or storage address hash as the node path, Verkle tree uses the new scheme. It's OK to design various schemes.  \r\nFor the latter one, previously in Geth we use the hash of the trie node content as the database key, so we will have huge data redundancy. Now in order to remove these redundancy we want to change the database key scheme which is path based. So whenever we update the trie, all the nodes are updated in place and there is only a single trie persisted in the database.\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/906903762/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/916685974",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/23427#issuecomment-916685974",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/23427",
    "id": 916685974,
    "node_id": "IC_kwDOAOvK9842o4SW",
    "user": {
      "login": "rjl493456442",
      "id": 5959481,
      "node_id": "MDQ6VXNlcjU5NTk0ODE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5959481?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/rjl493456442",
      "html_url": "https://github.com/rjl493456442",
      "followers_url": "https://api.github.com/users/rjl493456442/followers",
      "following_url": "https://api.github.com/users/rjl493456442/following{/other_user}",
      "gists_url": "https://api.github.com/users/rjl493456442/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/rjl493456442/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/rjl493456442/subscriptions",
      "organizations_url": "https://api.github.com/users/rjl493456442/orgs",
      "repos_url": "https://api.github.com/users/rjl493456442/repos",
      "events_url": "https://api.github.com/users/rjl493456442/events{/privacy}",
      "received_events_url": "https://api.github.com/users/rjl493456442/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-09-10T07:14:58Z",
    "updated_at": "2021-09-10T07:14:58Z",
    "author_association": "MEMBER",
    "body": "One more thing about the new state scheme is: how can we support the archive mode, or should we still support the archive mode.\r\n\r\nIn order to support the archive mode, Geth needs to store all the state reverse diffs and some state checkpoints in order to regenerate the target state fast. But it's not scalable since the cost for maintaining the state checkpoints is too high. And also it's not \"archive\" in this sense.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/916685974/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/917675371",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/23427#issuecomment-917675371",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/23427",
    "id": 917675371,
    "node_id": "IC_kwDOAOvK9842sp1r",
    "user": {
      "login": "qianbin",
      "id": 494645,
      "node_id": "MDQ6VXNlcjQ5NDY0NQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/494645?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/qianbin",
      "html_url": "https://github.com/qianbin",
      "followers_url": "https://api.github.com/users/qianbin/followers",
      "following_url": "https://api.github.com/users/qianbin/following{/other_user}",
      "gists_url": "https://api.github.com/users/qianbin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/qianbin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/qianbin/subscriptions",
      "organizations_url": "https://api.github.com/users/qianbin/orgs",
      "repos_url": "https://api.github.com/users/qianbin/repos",
      "events_url": "https://api.github.com/users/qianbin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/qianbin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-09-12T17:15:54Z",
    "updated_at": "2021-09-12T17:16:24Z",
    "author_association": "CONTRIBUTOR",
    "body": "> One more thing about the new state scheme is: how can we support the archive mode, or should we still support the archive mode.\r\n> \r\n> In order to support the archive mode, Geth needs to store all the state reverse diffs and some state checkpoints in order to regenerate the target state fast. But it's not scalable since the cost for maintaining the state checkpoints is too high. And also it's not \"archive\" in this sense.\r\n\r\nHave you benchmarked leaf iteration for a node-deduped trie which takes node path as key prefix? I think it's no much slower than traverse its snapshot. If it's true, state snapshots can be replaced by trie checkpoints (at least in case of snap sync).",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/917675371/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/917808462",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/23427#issuecomment-917808462",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/23427",
    "id": 917808462,
    "node_id": "IC_kwDOAOvK9842tKVO",
    "user": {
      "login": "rjl493456442",
      "id": 5959481,
      "node_id": "MDQ6VXNlcjU5NTk0ODE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5959481?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/rjl493456442",
      "html_url": "https://github.com/rjl493456442",
      "followers_url": "https://api.github.com/users/rjl493456442/followers",
      "following_url": "https://api.github.com/users/rjl493456442/following{/other_user}",
      "gists_url": "https://api.github.com/users/rjl493456442/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/rjl493456442/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/rjl493456442/subscriptions",
      "organizations_url": "https://api.github.com/users/rjl493456442/orgs",
      "repos_url": "https://api.github.com/users/rjl493456442/repos",
      "events_url": "https://api.github.com/users/rjl493456442/events{/privacy}",
      "received_events_url": "https://api.github.com/users/rjl493456442/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-09-13T03:28:44Z",
    "updated_at": "2021-09-13T03:28:44Z",
    "author_association": "MEMBER",
    "body": "@qianbin Yes, the path based state scheme will group the trie nodes so theoretically the trie accessing and iteration should be fast. \r\nRegarding retiring the snapshot, I'm not sure about it. Since we still need to resolve the internal trie nodes in order to access the leaves, while for snapshot it's unnecessary. The read amplification should also be considered.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/917808462/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/918223785",
    "html_url": "https://github.com/ethereum/go-ethereum/issues/23427#issuecomment-918223785",
    "issue_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/23427",
    "id": 918223785,
    "node_id": "IC_kwDOAOvK9842uvup",
    "user": {
      "login": "qianbin",
      "id": 494645,
      "node_id": "MDQ6VXNlcjQ5NDY0NQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/494645?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/qianbin",
      "html_url": "https://github.com/qianbin",
      "followers_url": "https://api.github.com/users/qianbin/followers",
      "following_url": "https://api.github.com/users/qianbin/following{/other_user}",
      "gists_url": "https://api.github.com/users/qianbin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/qianbin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/qianbin/subscriptions",
      "organizations_url": "https://api.github.com/users/qianbin/orgs",
      "repos_url": "https://api.github.com/users/qianbin/repos",
      "events_url": "https://api.github.com/users/qianbin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/qianbin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-09-13T14:02:41Z",
    "updated_at": "2021-09-13T14:02:41Z",
    "author_association": "CONTRIBUTOR",
    "body": "> @qianbin Yes, the path based state scheme will group the trie nodes so theoretically the trie accessing and iteration should be fast.\r\n> Regarding retiring the snapshot, I'm not sure about it. Since we still need to resolve the internal trie nodes in order to access the leaves, while for snapshot it's unnecessary. The read amplification should also be considered.\r\n\r\nIn my previous comment, there's an idea to put the block number onto the node (extends the hash pointer with the additional block number). If this idea is acceptable, then accurate snapshot is not necessary, instead, accumulated leaves is enough(easy to maintain).  each leaf also has the corresponding block number. when access a state, and the block number of the current trie root node is larger than or equal to the leaf's, then further sub node lookups can be skipped once find a sub node whose block number is less than or equal to leaf's. \r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/comments/918223785/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
