{
  "url": "https://api.github.com/repos/ethereum/solidity/issues/12964",
  "repository_url": "https://api.github.com/repos/ethereum/solidity",
  "labels_url": "https://api.github.com/repos/ethereum/solidity/issues/12964/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/solidity/issues/12964/comments",
  "events_url": "https://api.github.com/repos/ethereum/solidity/issues/12964/events",
  "html_url": "https://github.com/ethereum/solidity/issues/12964",
  "id": 1217757377,
  "node_id": "I_kwDOAm_5kc5IlYDB",
  "number": 12964,
  "title": "Yul: Constant-complexity switch statement jump table targeting enums",
  "user": {
    "login": "jaa2",
    "id": 43010335,
    "node_id": "MDQ6VXNlcjQzMDEwMzM1",
    "avatar_url": "https://avatars.githubusercontent.com/u/43010335?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/jaa2",
    "html_url": "https://github.com/jaa2",
    "followers_url": "https://api.github.com/users/jaa2/followers",
    "following_url": "https://api.github.com/users/jaa2/following{/other_user}",
    "gists_url": "https://api.github.com/users/jaa2/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/jaa2/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/jaa2/subscriptions",
    "organizations_url": "https://api.github.com/users/jaa2/orgs",
    "repos_url": "https://api.github.com/users/jaa2/repos",
    "events_url": "https://api.github.com/users/jaa2/events{/privacy}",
    "received_events_url": "https://api.github.com/users/jaa2/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [

  ],
  "state": "open",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 2,
  "created_at": "2022-04-27T18:52:27Z",
  "updated_at": "2022-08-17T13:48:53Z",
  "closed_at": null,
  "author_association": "CONTRIBUTOR",
  "active_lock_reason": null,
  "body": "## Abstract\r\nThe current switch statement control graph builder, for Yul to EVM specifically, is fine when switching between only a few values. To decide which path to take, a switch statement is turned into a `(DUP + PUSH + EQ + PUSH + JUMPI)` pattern for each case, and the default case is handled at the end. This is fine when handling up to three values, but the execution gas cost increases linearly with the number of cases. With four or more cases that are handled uniformly, a jump table performs better on average, and we can create a simple jump table that works specifically with switch statements containing all cases from `0...n`.\r\n\r\nThis is what it looks like today for a switch statement with cases `0...4`:\r\n```\r\nDUP1 PUSH1 0x0 EQ PUSH2 0x29C JUMPI\r\nDUP1 PUSH1 0x1 EQ PUSH2 0x121 JUMPI\r\nDUP1 PUSH1 0x2 EQ PUSH2 0x177 JUMPI\r\nDUP1 PUSH1 0x3 EQ PUSH2 0x34D JUMPI\r\nPUSH1 0x4 EQ PUSH2 0x134 JUMPI ...\r\n```\r\n\r\n## Motivation\r\n\r\nFor enums in particular - that is, switch statements that contain cases ranging from 0 to some number, there is a rather straightforward jump table implementation that not only makes the execution gas cost constant, but with more than five cases will also decrease the deployment cost.\r\n\r\nRather than checking each value individually and then branching on every check, in the enum case, we should calculate the jump table offset using the enum value itself and jump there.\r\nIt would work something like this:\r\n* Check if the value to compare is greater than the maximum case value; if so, jump to the default case if it exists, or to the end of the switch statement otherwise\r\n* Otherwise, calculate the jump table offset: `jumptable + 3 * value_to_compare`\r\n* At the jump table offset, jump to the target destination, which is where the code for handling the case is\r\n\r\nAs it is currently, after the case is handled, jump to the end of the switch statement.\r\n\r\nUltimately, any work done for this could pave the way for more robust dispatchers in the future.\r\n\r\n## Specification\r\nIn the case of a switch statement handling all cases 0...n with n >= 4, turn the current dispatch method for switch statements into a jump table, which should look something like this:\r\n```\r\nDUP1\r\nPUSH1 max       // Maximum case value for the enum\r\nGT              // Check if the value is within the range of the enum\r\nPUSH2 default_case\r\nJUMPI           // Jump to default case if the value is out of bounds\r\nDUP1\r\nPUSH1 0x3\r\nMUL\r\nPUSH2 jumptable\r\nADD\r\nJUMP            // Jump to a position in the jump table\r\n\r\njumptable:\r\nJUMPDEST\r\nPUSH2 0x29C\r\nJUMP\r\nJUMPDEST\r\nPUSH2 0x121\r\nJUMP\r\n...\r\n\r\ndefault_case:\r\n...\r\n```\r\n\r\nMy pen-and-paper execution gas cost comparison looks like this:\r\n```\r\nCurrent state:\r\nVal     Gas\r\n0       DUP + PUSH + EQ + PUSH + JUMPI = 3+3+3+3+10 = 22\r\n1       DUP + PUSH + EQ + PUSH + JUMPI + (DUP + PUSH + EQ + PUSH + JUMPI) = 44\r\n2       66\r\n3       88\r\n4       110\r\n\r\nEnum jump table:\r\nVal     Gas\r\n0       DUP + PUSH + GT + PUSH + JUMPI + DUP + PUSH + MUL + PUSH + ADD + JUMP + JUMPDEST + PUSH + JUMP = 59\r\n1       DUP + PUSH + GT + PUSH + JUMPI + DUP + PUSH + MUL + PUSH + ADD + JUMP + JUMPDEST + PUSH + JUMP = 59\r\n2       59\r\n3       59\r\n4       59\r\n```\r\n\r\n## Backwards Compatibility\r\n\r\nThis is a Yul to EVM optimization, so I don't anticipate any backward compatibility issues. That said, this proposal only targets switch statements with 0...n values, with n >= 4.\r\n\r\nThis could be an optional optimization to be added onto the Yul compiler.\r\n\r\nRelated: #12650 ",
  "closed_by": null,
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/12964/reactions",
    "total_count": 1,
    "+1": 1,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/solidity/issues/12964/timeline",
  "performed_via_github_app": null,
  "state_reason": null
}
[
  {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1112111742",
    "html_url": "https://github.com/ethereum/solidity/issues/12964#issuecomment-1112111742",
    "issue_url": "https://api.github.com/repos/ethereum/solidity/issues/12964",
    "id": 1112111742,
    "node_id": "IC_kwDOAm_5kc5CSXp-",
    "user": {
      "login": "chriseth",
      "id": 9073706,
      "node_id": "MDQ6VXNlcjkwNzM3MDY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/9073706?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/chriseth",
      "html_url": "https://github.com/chriseth",
      "followers_url": "https://api.github.com/users/chriseth/followers",
      "following_url": "https://api.github.com/users/chriseth/following{/other_user}",
      "gists_url": "https://api.github.com/users/chriseth/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/chriseth/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/chriseth/subscriptions",
      "organizations_url": "https://api.github.com/users/chriseth/orgs",
      "repos_url": "https://api.github.com/users/chriseth/repos",
      "events_url": "https://api.github.com/users/chriseth/events{/privacy}",
      "received_events_url": "https://api.github.com/users/chriseth/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-04-28T11:53:02Z",
    "updated_at": "2022-04-28T11:53:02Z",
    "author_association": "MEMBER",
    "body": "There are multiple ways to do this. You can store the jump targets in a \"code table\" like you did, but we can also store them in code and use codecopy to retrieve it. Furthermore, we could use a `push32` to store 16 jump targets and use a shift/mask combination to retrieve the right one. All of them require a change to Assembly in order to store the jump targets at the right page after the assembly phase (the one where the acutal byte offsets of tags are determined).\r\nWould be nice to experiment which way is the best, so your help is really appreciated!",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1112111742/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1112546025",
    "html_url": "https://github.com/ethereum/solidity/issues/12964#issuecomment-1112546025",
    "issue_url": "https://api.github.com/repos/ethereum/solidity/issues/12964",
    "id": 1112546025,
    "node_id": "IC_kwDOAm_5kc5CUBrp",
    "user": {
      "login": "jaa2",
      "id": 43010335,
      "node_id": "MDQ6VXNlcjQzMDEwMzM1",
      "avatar_url": "https://avatars.githubusercontent.com/u/43010335?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jaa2",
      "html_url": "https://github.com/jaa2",
      "followers_url": "https://api.github.com/users/jaa2/followers",
      "following_url": "https://api.github.com/users/jaa2/following{/other_user}",
      "gists_url": "https://api.github.com/users/jaa2/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jaa2/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jaa2/subscriptions",
      "organizations_url": "https://api.github.com/users/jaa2/orgs",
      "repos_url": "https://api.github.com/users/jaa2/repos",
      "events_url": "https://api.github.com/users/jaa2/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jaa2/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-04-28T18:48:25Z",
    "updated_at": "2022-04-28T19:15:34Z",
    "author_association": "CONTRIBUTOR",
    "body": "I like the idea of storing the jump targets in a single word. I was able to get the execution cost down to 48 gas using the `push` technique, taking advantage of the fact that a right shift of more than the range of the pushed value will result in zero. If the result of the shift is 0, it jumps to the default case instead.\r\n\r\n**Push technique (48 gas):**\r\n```\r\nPUSH2 0xffff    // Byte mask\r\nPUSH10 0x0034002e00280022001c   // Every two bytes is a destination\r\nDUP3            // Get enum value\r\nPUSH1 0x04\r\nSHL             // Calculate shift amount: 16 * enum value\r\nSHR\r\nAND             // Apply two-byte mask\r\nDUP1\r\nISZERO\r\nPUSH default_case\r\nJUMPI           // Jump to default case if the value is out of bounds\r\nJUMP            // Jump to destination offset\r\n```\r\n\r\nThe two assumptions it has to make are that (a) all offsets can be represented with two bytes and (b) the offset 0 is not a valid jump destination.\r\n\r\nI have an idea for an even stronger optimization: if we can guarantee that the jump destinations of the individual cases are always greater than the offset of the default case, we can skip the out-of-bounds check entirely and instead just store the offsets from the default case location in the \"jump table\". I assume this might be difficult to guarantee in practice, but if we could do it, the execution gas cost would come all the way down to 35. As an example, if the default case is at offset 0x45, and case 0 is at 0x4d, we would store 0x08 in the jump table and just add 0x45 to it.\r\n\r\n**Offsets from the default case (35 gas):**\r\n```\r\nPUSH2 0xffff    // Byte mask\r\nPUSH10 0x0020001a0014000e0008   // Every two bytes is a destination\r\nDUP3            // Get enum value\r\nPUSH1 0x04\r\nSHL             // Calculate shift amount: 16 * enum value\r\nSHR\r\nAND             // Apply two-byte mask\r\nPUSH default_case\r\nADD\r\nJUMP            // Jump to destination offset\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1112546025/reactions",
      "total_count": 1,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 1,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
