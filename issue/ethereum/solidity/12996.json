{
  "url": "https://api.github.com/repos/ethereum/solidity/issues/12996",
  "repository_url": "https://api.github.com/repos/ethereum/solidity",
  "labels_url": "https://api.github.com/repos/ethereum/solidity/issues/12996/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/solidity/issues/12996/comments",
  "events_url": "https://api.github.com/repos/ethereum/solidity/issues/12996/events",
  "html_url": "https://github.com/ethereum/solidity/issues/12996",
  "id": 1230779423,
  "node_id": "I_kwDOAm_5kc5JXDQf",
  "number": 12996,
  "title": "Language feature: disallow state-changing effects after an external call by default",
  "user": {
    "login": "pcaversaccio",
    "id": 25297591,
    "node_id": "MDQ6VXNlcjI1Mjk3NTkx",
    "avatar_url": "https://avatars.githubusercontent.com/u/25297591?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/pcaversaccio",
    "html_url": "https://github.com/pcaversaccio",
    "followers_url": "https://api.github.com/users/pcaversaccio/followers",
    "following_url": "https://api.github.com/users/pcaversaccio/following{/other_user}",
    "gists_url": "https://api.github.com/users/pcaversaccio/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/pcaversaccio/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/pcaversaccio/subscriptions",
    "organizations_url": "https://api.github.com/users/pcaversaccio/orgs",
    "repos_url": "https://api.github.com/users/pcaversaccio/repos",
    "events_url": "https://api.github.com/users/pcaversaccio/events{/privacy}",
    "received_events_url": "https://api.github.com/users/pcaversaccio/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 467898404,
      "node_id": "MDU6TGFiZWw0Njc4OTg0MDQ=",
      "url": "https://api.github.com/repos/ethereum/solidity/labels/breaking%20change%20:warning:",
      "name": "breaking change :warning:",
      "color": "b60205",
      "default": false,
      "description": ""
    },
    {
      "id": 785717317,
      "node_id": "MDU6TGFiZWw3ODU3MTczMTc=",
      "url": "https://api.github.com/repos/ethereum/solidity/labels/language%20design%20:rage4:",
      "name": "language design :rage4:",
      "color": "9d76d3",
      "default": false,
      "description": "Any changes to the language, e.g. new features"
    },
    {
      "id": 4438003076,
      "node_id": "LA_kwDOAm_5kc8AAAABCIaNhA",
      "url": "https://api.github.com/repos/ethereum/solidity/labels/medium%20effort",
      "name": "medium effort",
      "color": "ff7df7",
      "default": false,
      "description": "Default level of effort"
    },
    {
      "id": 4438153180,
      "node_id": "LA_kwDOAm_5kc8AAAABCIjX3A",
      "url": "https://api.github.com/repos/ethereum/solidity/labels/high%20impact",
      "name": "high impact",
      "color": "001dff",
      "default": false,
      "description": "Changes are very prominent and affect users or the project in a major way."
    },
    {
      "id": 4525128519,
      "node_id": "LA_kwDOAm_5kc8AAAABDbf7Rw",
      "url": "https://api.github.com/repos/ethereum/solidity/labels/needs%20design",
      "name": "needs design",
      "color": "18F737",
      "default": false,
      "description": "The proposal is too vague to be implemented right away"
    }
  ],
  "state": "open",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 23,
  "created_at": "2022-05-10T08:08:39Z",
  "updated_at": "2022-10-03T14:39:25Z",
  "closed_at": null,
  "author_association": "NONE",
  "active_lock_reason": null,
  "body": "## Abstract\r\n\r\nGenerally disallowing state-changing effects after an `external` function call and enabling the possibility to mark functions that specifically do this.\r\n\r\n## Motivation\r\n\r\nI started this discussion on [Twitter](https://twitter.com/pcaversaccio/status/1523231260721975296) after another reentrancy attack (Cc: @chriseth). Reentrancy attacks are ubiquitous and even though there are toolings available (e.g. Slither) that conduct a static analysis it requires an initial setup as well as a proper understanding of how to interpret the results. In order to make the Solidity development more secure and sustainable I feel it's time to finally introduce such a language feature that disallows state-changing effects after an `external` function call and mark functions that specifically do this.\r\n\r\n## Specification\r\n\r\nAll state-changing effects after an `external` function call are disallowed. If you want to allow however such a possibility, we introduce a new modifier `unprotected` whose default value is `false`.\r\n\r\n## Backwards Compatibility\r\n\r\nThe code that previously compiled fine will not compile anymore if there is a state-change effect after an `external` call and the new modifier `unprotected` is unknown, so it's a breaking change.\r\n\r\n",
  "closed_by": null,
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/12996/reactions",
    "total_count": 5,
    "+1": 5,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/solidity/issues/12996/timeline",
  "performed_via_github_app": null,
  "state_reason": null
}
[
  {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1122093106",
    "html_url": "https://github.com/ethereum/solidity/issues/12996#issuecomment-1122093106",
    "issue_url": "https://api.github.com/repos/ethereum/solidity/issues/12996",
    "id": 1122093106,
    "node_id": "IC_kwDOAm_5kc5C4cgy",
    "user": {
      "login": "chriseth",
      "id": 9073706,
      "node_id": "MDQ6VXNlcjkwNzM3MDY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/9073706?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/chriseth",
      "html_url": "https://github.com/chriseth",
      "followers_url": "https://api.github.com/users/chriseth/followers",
      "following_url": "https://api.github.com/users/chriseth/following{/other_user}",
      "gists_url": "https://api.github.com/users/chriseth/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/chriseth/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/chriseth/subscriptions",
      "organizations_url": "https://api.github.com/users/chriseth/orgs",
      "repos_url": "https://api.github.com/users/chriseth/repos",
      "events_url": "https://api.github.com/users/chriseth/events{/privacy}",
      "received_events_url": "https://api.github.com/users/chriseth/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-05-10T08:32:24Z",
    "updated_at": "2022-05-10T08:32:24Z",
    "author_association": "MEMBER",
    "body": "Just a comment on the name of the modifier: I don't like opinionated words like \"safe\" or \"protected\" because they give a false impression of safety or protection, we should find a more neutral one.\r\n\r\nAlso more generally: Also wrt. free functions, it might be a good idea to explicitly pass/provide something like a \"context\" as a parameter to functions that allows external calls (or maybe even state changes without external calls). In this case, we could have a special property on this context that allows state changes after an external call. By default, the context would transform into a \"constant state\" context after an external call - there are the linear types again.\r\n\r\nAlso something to consider more specifically to this issue: Is it OK to do another external call after the first external call? What about a delegatecall? Even if we do not use delegatecall, how do we distinguish a \"data contract\" that is associated to the current contract from a potentially malicious external contract?\r\n\r\nAfter all these questions, I'm more and more inclined that this should rather be \"off-loaded\" to user code and the compiler should instead provide the required features for the type system.\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1122093106/reactions",
      "total_count": 4,
      "+1": 4,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1122854036",
    "html_url": "https://github.com/ethereum/solidity/issues/12996#issuecomment-1122854036",
    "issue_url": "https://api.github.com/repos/ethereum/solidity/issues/12996",
    "id": 1122854036,
    "node_id": "IC_kwDOAm_5kc5C7WSU",
    "user": {
      "login": "pcaversaccio",
      "id": 25297591,
      "node_id": "MDQ6VXNlcjI1Mjk3NTkx",
      "avatar_url": "https://avatars.githubusercontent.com/u/25297591?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/pcaversaccio",
      "html_url": "https://github.com/pcaversaccio",
      "followers_url": "https://api.github.com/users/pcaversaccio/followers",
      "following_url": "https://api.github.com/users/pcaversaccio/following{/other_user}",
      "gists_url": "https://api.github.com/users/pcaversaccio/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/pcaversaccio/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/pcaversaccio/subscriptions",
      "organizations_url": "https://api.github.com/users/pcaversaccio/orgs",
      "repos_url": "https://api.github.com/users/pcaversaccio/repos",
      "events_url": "https://api.github.com/users/pcaversaccio/events{/privacy}",
      "received_events_url": "https://api.github.com/users/pcaversaccio/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-05-10T20:58:58Z",
    "updated_at": "2022-05-10T20:58:58Z",
    "author_association": "NONE",
    "body": "You are right about the name of the modifier - after thinking through it today maybe we even do not need a modifier but can use the `unchecked` block syntax directly. I think in a _broader sense_ this language feature is consistent with the checked arithmetic introduced in solc version `0.8.0` since it also wants to prevent unwanted behaviour that could be exploited (one of the major reasons behind introducing libraries such as `SafeMath` were smart contract exploits based on overflow/underflow vulnerabilities).\r\n\r\nThere are three types of reentrancy:\r\n- Single Function Reentrancy\r\n- Cross-Function Reentrancy\r\n- Cross-Contract Reentrancy\r\n\r\nFor the cross-contract reentrancy, this one can happen when a state from one contract is used in another contract, but that state is not fully updated before getting called.\r\n\r\nThe conditions required for the cross-contract reentrancy to be possible are as follows:\r\n- The execution flow can be controlled by the attacker to manipulate the contract state.\r\n- The value of the state in the contract is shared or used in another contract.\r\n\r\nThe best outcome for this language feature would be that one could write the contracts without bothering about these three types by _default_. Of course, we can always argue to \"offload\" all the responsibility to the developers but past experience and events showcase blatantly that this does not work as intended.\r\n\r\nComing back to your context idea - I really like it but couldn't we simply achieve that via the `unchecked` block syntax. I.e. an `unchecked` block does not only _not_ control for an unrestricted integer that falls outside the range of the result type but also allows for a \"non-constant state\". By default, however, the context is a \"constant state\".\r\n\r\n> Also something to consider more specifically to this issue: Is it OK to do another external call after the first external call? What about a delegatecall? Even if we do not use delegatecall, how do we distinguish a \"data contract\" that is associated to the current contract from a potentially malicious external contract?\r\n\r\nI'm not yet sure what would be the best design here tbh.\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1122854036/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1128887596",
    "html_url": "https://github.com/ethereum/solidity/issues/12996#issuecomment-1128887596",
    "issue_url": "https://api.github.com/repos/ethereum/solidity/issues/12996",
    "id": 1128887596,
    "node_id": "IC_kwDOAm_5kc5DSXUs",
    "user": {
      "login": "pcaversaccio",
      "id": 25297591,
      "node_id": "MDQ6VXNlcjI1Mjk3NTkx",
      "avatar_url": "https://avatars.githubusercontent.com/u/25297591?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/pcaversaccio",
      "html_url": "https://github.com/pcaversaccio",
      "followers_url": "https://api.github.com/users/pcaversaccio/followers",
      "following_url": "https://api.github.com/users/pcaversaccio/following{/other_user}",
      "gists_url": "https://api.github.com/users/pcaversaccio/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/pcaversaccio/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/pcaversaccio/subscriptions",
      "organizations_url": "https://api.github.com/users/pcaversaccio/orgs",
      "repos_url": "https://api.github.com/users/pcaversaccio/repos",
      "events_url": "https://api.github.com/users/pcaversaccio/events{/privacy}",
      "received_events_url": "https://api.github.com/users/pcaversaccio/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-05-17T13:42:35Z",
    "updated_at": "2022-05-17T13:42:35Z",
    "author_association": "NONE",
    "body": "I would like to quickly add some further thoughts behind this language feature: The main question is whether we should build the language in a _via negativa_ or _via positiva_ way. I strongly tend based on the experience and events over the last 6 years to the first one. If you look at all the exploits that happened over the last 6 years (including DAO) we haven't got really smarter w.r.t. to reentrancy attacks as it seems (I also blame a little bit the auditors who push for the low-level calls instead e.g. transfer). Too many devs are still not paranoid enough! And Solidity already started implementing such safety features via `unchecked` for over/underflows. It's definitely a tradeoff here and my reasoning is practice-driven.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1128887596/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1149579731",
    "html_url": "https://github.com/ethereum/solidity/issues/12996#issuecomment-1149579731",
    "issue_url": "https://api.github.com/repos/ethereum/solidity/issues/12996",
    "id": 1149579731,
    "node_id": "IC_kwDOAm_5kc5EhTHT",
    "user": {
      "login": "pcaversaccio",
      "id": 25297591,
      "node_id": "MDQ6VXNlcjI1Mjk3NTkx",
      "avatar_url": "https://avatars.githubusercontent.com/u/25297591?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/pcaversaccio",
      "html_url": "https://github.com/pcaversaccio",
      "followers_url": "https://api.github.com/users/pcaversaccio/followers",
      "following_url": "https://api.github.com/users/pcaversaccio/following{/other_user}",
      "gists_url": "https://api.github.com/users/pcaversaccio/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/pcaversaccio/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/pcaversaccio/subscriptions",
      "organizations_url": "https://api.github.com/users/pcaversaccio/orgs",
      "repos_url": "https://api.github.com/users/pcaversaccio/repos",
      "events_url": "https://api.github.com/users/pcaversaccio/events{/privacy}",
      "received_events_url": "https://api.github.com/users/pcaversaccio/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-06-08T07:47:45Z",
    "updated_at": "2022-06-08T07:47:45Z",
    "author_association": "NONE",
    "body": "@cameel @hrkrshnn what are your opinions on my thoughts here?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1149579731/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1173550008",
    "html_url": "https://github.com/ethereum/solidity/issues/12996#issuecomment-1173550008",
    "issue_url": "https://api.github.com/repos/ethereum/solidity/issues/12996",
    "id": 1173550008,
    "node_id": "IC_kwDOAm_5kc5F8vO4",
    "user": {
      "login": "leonardoalt",
      "id": 504195,
      "node_id": "MDQ6VXNlcjUwNDE5NQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/504195?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/leonardoalt",
      "html_url": "https://github.com/leonardoalt",
      "followers_url": "https://api.github.com/users/leonardoalt/followers",
      "following_url": "https://api.github.com/users/leonardoalt/following{/other_user}",
      "gists_url": "https://api.github.com/users/leonardoalt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/leonardoalt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/leonardoalt/subscriptions",
      "organizations_url": "https://api.github.com/users/leonardoalt/orgs",
      "repos_url": "https://api.github.com/users/leonardoalt/repos",
      "events_url": "https://api.github.com/users/leonardoalt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/leonardoalt/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-07-04T09:00:48Z",
    "updated_at": "2022-07-04T09:01:28Z",
    "author_association": "MEMBER",
    "body": "I think this shouldn't go into the language with `safe/protected` keywords and such, and should rather have similar behavior as checked arithmetic.\r\n\r\nIMO, reentrancy guards could be added by default for every external call, and bypassed if the call is in an `unchecked` block. This also follows Rust's `unsafe` style which seems popular.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1173550008/reactions",
      "total_count": 3,
      "+1": 3,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1173557794",
    "html_url": "https://github.com/ethereum/solidity/issues/12996#issuecomment-1173557794",
    "issue_url": "https://api.github.com/repos/ethereum/solidity/issues/12996",
    "id": 1173557794,
    "node_id": "IC_kwDOAm_5kc5F8xIi",
    "user": {
      "login": "leonardoalt",
      "id": 504195,
      "node_id": "MDQ6VXNlcjUwNDE5NQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/504195?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/leonardoalt",
      "html_url": "https://github.com/leonardoalt",
      "followers_url": "https://api.github.com/users/leonardoalt/followers",
      "following_url": "https://api.github.com/users/leonardoalt/following{/other_user}",
      "gists_url": "https://api.github.com/users/leonardoalt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/leonardoalt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/leonardoalt/subscriptions",
      "organizations_url": "https://api.github.com/users/leonardoalt/orgs",
      "repos_url": "https://api.github.com/users/leonardoalt/repos",
      "events_url": "https://api.github.com/users/leonardoalt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/leonardoalt/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-07-04T09:07:27Z",
    "updated_at": "2022-07-04T09:07:27Z",
    "author_association": "MEMBER",
    "body": "https://github.com/ethereum/solidity/issues/13124 is a dup of this issue in general but offers two different approaches:\r\n\r\n- Aggressive: basically what I said above\r\n- Conservative: try to detect whether state changes are performed after external calls, and if yes add the reentrancy guards.\r\n\r\nCopying what I said in the other issue:\r\n\r\nYou could combine both approaches, eg have the aggressive approach by default which can be bypassed by the user if the external call is in an unchecked block, and the compiler can also choose to optimize it away if it detects the conditions in the conservative approach.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1173557794/reactions",
      "total_count": 4,
      "+1": 4,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1173634143",
    "html_url": "https://github.com/ethereum/solidity/issues/12996#issuecomment-1173634143",
    "issue_url": "https://api.github.com/repos/ethereum/solidity/issues/12996",
    "id": 1173634143,
    "node_id": "IC_kwDOAm_5kc5F9Dxf",
    "user": {
      "login": "lukehutch",
      "id": 811305,
      "node_id": "MDQ6VXNlcjgxMTMwNQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/811305?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/lukehutch",
      "html_url": "https://github.com/lukehutch",
      "followers_url": "https://api.github.com/users/lukehutch/followers",
      "following_url": "https://api.github.com/users/lukehutch/following{/other_user}",
      "gists_url": "https://api.github.com/users/lukehutch/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/lukehutch/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/lukehutch/subscriptions",
      "organizations_url": "https://api.github.com/users/lukehutch/orgs",
      "repos_url": "https://api.github.com/users/lukehutch/repos",
      "events_url": "https://api.github.com/users/lukehutch/events{/privacy}",
      "received_events_url": "https://api.github.com/users/lukehutch/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-07-04T10:16:19Z",
    "updated_at": "2022-07-04T10:17:38Z",
    "author_association": "CONTRIBUTOR",
    "body": "Standard reachability analysis should be able to determine quite easily whether any given line can modify state or call a function in another contract. Then Solidity just needs to ensure that every function has a partition between state modification first, and external calls second.\r\n\r\nIf you want the user to have to explicitly signify whether a function updates state, you already have that: non-`pure`/`view`. If you want the user to have to explicitly signify which functions can call other contracts, you could add a `caller` modifier or something. Then you could not call a state modifier function or modify state after a `caller` function or an `address.call` within any function -- and any function that calls a `caller` function or calls `address.call` also itself becomes a `caller` function.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1173634143/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1173641610",
    "html_url": "https://github.com/ethereum/solidity/issues/12996#issuecomment-1173641610",
    "issue_url": "https://api.github.com/repos/ethereum/solidity/issues/12996",
    "id": 1173641610,
    "node_id": "IC_kwDOAm_5kc5F9FmK",
    "user": {
      "login": "leonardoalt",
      "id": 504195,
      "node_id": "MDQ6VXNlcjUwNDE5NQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/504195?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/leonardoalt",
      "html_url": "https://github.com/leonardoalt",
      "followers_url": "https://api.github.com/users/leonardoalt/followers",
      "following_url": "https://api.github.com/users/leonardoalt/following{/other_user}",
      "gists_url": "https://api.github.com/users/leonardoalt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/leonardoalt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/leonardoalt/subscriptions",
      "organizations_url": "https://api.github.com/users/leonardoalt/orgs",
      "repos_url": "https://api.github.com/users/leonardoalt/repos",
      "events_url": "https://api.github.com/users/leonardoalt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/leonardoalt/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-07-04T10:23:21Z",
    "updated_at": "2022-07-04T10:27:29Z",
    "author_association": "MEMBER",
    "body": "I personally really dislike the idea of function modifiers for reentrancy. It's too binary and does not represent the amount of different use cases. Moreover:\r\n\r\n- the strategy you mention first can yield false positives for safe cases that do not conform exactly to this pattern\r\n- I understand your second paragraph but it sounds really confusing. Imagine documenting/implementing this, it's gonna be full of edge cases and potentially make the analysis more dangerous/confusing.\r\n\r\nEdit:\r\n\r\n- I'm not against the reachability analysis. I think it is useful as an optimization for cases that are safe for sure.\r\n- I just think the simplest would be to add a guard to every call by default with the possibility of removing it. No extra keyword, no complicated analysis besides the optimization above, no edge cases. Plus it conforms to a standard that the language already has.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1173641610/reactions",
      "total_count": 3,
      "+1": 3,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1173648701",
    "html_url": "https://github.com/ethereum/solidity/issues/12996#issuecomment-1173648701",
    "issue_url": "https://api.github.com/repos/ethereum/solidity/issues/12996",
    "id": 1173648701,
    "node_id": "IC_kwDOAm_5kc5F9HU9",
    "user": {
      "login": "lukehutch",
      "id": 811305,
      "node_id": "MDQ6VXNlcjgxMTMwNQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/811305?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/lukehutch",
      "html_url": "https://github.com/lukehutch",
      "followers_url": "https://api.github.com/users/lukehutch/followers",
      "following_url": "https://api.github.com/users/lukehutch/following{/other_user}",
      "gists_url": "https://api.github.com/users/lukehutch/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/lukehutch/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/lukehutch/subscriptions",
      "organizations_url": "https://api.github.com/users/lukehutch/orgs",
      "repos_url": "https://api.github.com/users/lukehutch/repos",
      "events_url": "https://api.github.com/users/lukehutch/events{/privacy}",
      "received_events_url": "https://api.github.com/users/lukehutch/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-07-04T10:29:42Z",
    "updated_at": "2022-07-04T10:33:40Z",
    "author_association": "CONTRIBUTOR",
    "body": "What I proposed is already basically what Slither does (minus the modifiers), but Solidity should give these warnings rather than Slither, because this is such a serious source of security vulnerabilities.\r\n\r\nYes, in the general case precise reachability analysis is uncomputable, unless you use conservative logic that looks to see whether something *might* be reachable given some specific runtime control flow (then reachability analysis becomes simple and computable).\r\n\r\nRe. the modifiers, there's a reason why Solidity made visibility modifiers and mutation modifiers required a few versions ago. Being explicit establishes a contract between the programmer and the compiler. And what I explained in my 2nd paragraph is exactly what Solidity already does (albeit with inverted logic) with mutation modifiers for pure/view functions. So basically the machinery is all already there in the compiler to implement this simply.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1173648701/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1186290000",
    "html_url": "https://github.com/ethereum/solidity/issues/12996#issuecomment-1186290000",
    "issue_url": "https://api.github.com/repos/ethereum/solidity/issues/12996",
    "id": 1186290000,
    "node_id": "IC_kwDOAm_5kc5GtVlQ",
    "user": {
      "login": "lukehutch",
      "id": 811305,
      "node_id": "MDQ6VXNlcjgxMTMwNQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/811305?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/lukehutch",
      "html_url": "https://github.com/lukehutch",
      "followers_url": "https://api.github.com/users/lukehutch/followers",
      "following_url": "https://api.github.com/users/lukehutch/following{/other_user}",
      "gists_url": "https://api.github.com/users/lukehutch/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/lukehutch/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/lukehutch/subscriptions",
      "organizations_url": "https://api.github.com/users/lukehutch/orgs",
      "repos_url": "https://api.github.com/users/lukehutch/repos",
      "events_url": "https://api.github.com/users/lukehutch/events{/privacy}",
      "received_events_url": "https://api.github.com/users/lukehutch/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-07-16T20:54:38Z",
    "updated_at": "2022-07-16T20:54:38Z",
    "author_association": "CONTRIBUTOR",
    "body": "It will be much easier to implement robust automatic runtime protections against reentrancy attacks at runtime once [EIP-1153](https://eips.ethereum.org/EIPS/eip-1153) is merged, because it will allow for flags to be set whose lifecycle is bound to a transaction.\r\n\r\nHowever, I believe the vast majority of reentrancy attack vulnerabilities can be detected and prevented through static analysis.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1186290000/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1186443428",
    "html_url": "https://github.com/ethereum/solidity/issues/12996#issuecomment-1186443428",
    "issue_url": "https://api.github.com/repos/ethereum/solidity/issues/12996",
    "id": 1186443428,
    "node_id": "IC_kwDOAm_5kc5Gt7Ck",
    "user": {
      "login": "leonardoalt",
      "id": 504195,
      "node_id": "MDQ6VXNlcjUwNDE5NQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/504195?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/leonardoalt",
      "html_url": "https://github.com/leonardoalt",
      "followers_url": "https://api.github.com/users/leonardoalt/followers",
      "following_url": "https://api.github.com/users/leonardoalt/following{/other_user}",
      "gists_url": "https://api.github.com/users/leonardoalt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/leonardoalt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/leonardoalt/subscriptions",
      "organizations_url": "https://api.github.com/users/leonardoalt/orgs",
      "repos_url": "https://api.github.com/users/leonardoalt/repos",
      "events_url": "https://api.github.com/users/leonardoalt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/leonardoalt/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-07-17T08:23:13Z",
    "updated_at": "2022-07-17T08:23:13Z",
    "author_association": "MEMBER",
    "body": "> It will be much easier to implement robust automatic runtime protections against reentrancy attacks at runtime once [EIP-1153](https://eips.ethereum.org/EIPS/eip-1153) is merged, because it will allow for flags to be set whose lifecycle is bound to a transaction.\n\nAre you confident that's gonna go in? I personally am not.\n\n> However, I believe the vast majority of reentrancy attack vulnerabilities can be detected and prevented through static analysis.\n\nAgree that potential reentrancy can be detected with syntactic static analysis. But what about false positives?\n\nI think there are multiple ideas here that are complementary and provide different levels of safety and user experience. We need to get more people into this discussion, not only from the team. We also need to gather actual data on how many / what type of contracts would benefit from each proposed solution, and how many would be made worse / more annoying.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1186443428/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1187381059",
    "html_url": "https://github.com/ethereum/solidity/issues/12996#issuecomment-1187381059",
    "issue_url": "https://api.github.com/repos/ethereum/solidity/issues/12996",
    "id": 1187381059,
    "node_id": "IC_kwDOAm_5kc5Gxf9D",
    "user": {
      "login": "pcaversaccio",
      "id": 25297591,
      "node_id": "MDQ6VXNlcjI1Mjk3NTkx",
      "avatar_url": "https://avatars.githubusercontent.com/u/25297591?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/pcaversaccio",
      "html_url": "https://github.com/pcaversaccio",
      "followers_url": "https://api.github.com/users/pcaversaccio/followers",
      "following_url": "https://api.github.com/users/pcaversaccio/following{/other_user}",
      "gists_url": "https://api.github.com/users/pcaversaccio/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/pcaversaccio/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/pcaversaccio/subscriptions",
      "organizations_url": "https://api.github.com/users/pcaversaccio/orgs",
      "repos_url": "https://api.github.com/users/pcaversaccio/repos",
      "events_url": "https://api.github.com/users/pcaversaccio/events{/privacy}",
      "received_events_url": "https://api.github.com/users/pcaversaccio/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-07-18T13:09:39Z",
    "updated_at": "2022-10-01T08:52:56Z",
    "author_association": "NONE",
    "body": "As quickly discussed with @leonardoalt it would be good to compile a list of reentrancy attacks and to understand what kind of code design pattern would fit best. Also, IMHO we should not rely on EIP-1153 to be finalised and implemented soon - let's take the current status quo of the EVM and solc as the valid principles for the solution-finding process. Furthermore, I also think we need to be careful to jump to conclusions too fast. Past code patterns should not necessarily imply what future code patterns will look like (also wrt what is planned for e.g. solc `0.9.0`). Maybe to some extent, engineers must \"unlearn\" certain design patterns for the greater good.\r\n\r\nLet me try to share a common, chronological list of reentrancy attacks including their (mostly) detailed analyses:\r\n\r\n- [WETH white hat attack](https://github.com/pcaversaccio/reentrancy-attacks/issues/1#issuecomment-1188680199) – June 11, 2016\r\n- [The DAO attack](https://medium.com/@zhongqiangc/smart-contract-reentrancy-thedao-f2da1d25180c) – June 17, 2016\r\n- [SpankChain attack](https://medium.com/swlh/how-spankchain-got-hacked-af65b933393c) – October 9, 2018\r\n- [imBTC Uniswap pool attack](https://defirate.com/imbtc-uniswap-hack) – April 18, 2020\r\n- [Lendf.Me attack](https://slowmist.medium.com/slowmist-details-of-lendf-me-reentrancy-attack-3e168ab5f2b1) – April 19, 2020\r\n- [Akropolis attack](https://peckshield.medium.com/akropolis-incident-root-cause-analysis-c11ee59e05d4) – November 12, 2020\r\n- [ValueDeFi attack](https://inspexco.medium.com/value-defis-invalid-share-calculation-exploit-in-depth-analysis-1c8f97c1416e) – May 7, 2021\r\n- [Rari Capital attack](https://nipunp.medium.com/5-8-21-rari-capital-exploit-timeline-analysis-8beda31cbc1a) – May 8, 2021\r\n- [BurgerSwap attack](https://quillhashteam.medium.com/burgerswap-flash-loan-attack-analysis-888b1911daef) – May 27, 2021\r\n- [Iron Finance attack](https://thedefiant.io/not-just-a-bank-run-new-evidence-shows-iron-finance-crashed-due-to-code-exploit) – June 16, 2021\r\n- [PolyDEX attack](https://polydex.medium.com/plx-locker-smart-contract-incident-post-mortem-75342124a3e8) – June 20, 2021\r\n- [DeFiPie attack](https://medium.com/defipie/hacking-investigation-85e07454f1c9) – July 12, 2021\r\n- [Sanshu Inu attack](https://sanshunft.medium.com/woofdate-2-2-0-keanu-compensation-mfund-rebase-update-bcac09707e19) – July 20, 2021\r\n- [C.R.E.A.M. Finance attack](https://inspexco.medium.com/reentrancy-attack-on-cream-finance-incident-analysis-1c629686b6f5) – August 30, 2021\r\n- [Grim Finance attack](https://rekt.news/grim-finance-rekt) – December 18, 2021\r\n- [Visor Finance attack](https://medium.com/visorfinance/post-mortem-for-vvisr-staking-contract-exploit-and-upcoming-migration-7920e1dee55a) – December 21, 2021\r\n- [HypeBears attack](https://blocksecteam.medium.com/when-safemint-becomes-unsafe-lessons-from-the-hypebears-security-incident-2965209bda2a) – February 3, 2022\r\n- [Bacon Protocol attack](https://coincodecap.com/bacon-protocol-hacked-reportedly-1m-lost) – March 5, 2022\r\n- [Paraluni attack](https://coincodecap.com/paraluni-hacked-reportedly-1-7m-lost) – March 13, 2022\r\n- [Hundred Finance attack](https://twitter.com/danielvf/status/1503756428212936710) – March 15, 2022\r\n- [Agave Finance attack](https://twitter.com/Mudit__Gupta/status/1503783633877827586) – March 16, 2022\r\n- [Revest Finance attack](https://slowmist.medium.com/revest-finance-incident-analysis-6fcd9b6be207) – March 27, 2022\r\n- [Voltage Finance attack](https://rekt.news/voltage-finance-rekt) – March 31, 2022\r\n- [BNB Brokers attack](https://twitter.com/BlockSecTeam/status/1519249933832171520) – April 27, 2022\r\n- [Fei Protocol attack](https://certik.medium.com/fei-protocol-incident-analysis-8527440696cc) – April 30, 2022\r\n- [Bistroo attack](https://bistroo.medium.com/post-incident-review-bist-single-asset-staking-binancesmartchain-security-breach-5194590605f) – May 7, 2022\r\n- [Ownly attack](https://twitter.com/ownlyio/status/1524362090940895234) – May 10, 2022\r\n- [Omni attack](https://twitter.com/BlockSecTeam/status/1546141457933025280) – July 10, 2022\r\n- [Thunder Brawl attack](https://twitter.com/peckshield/status/1575890733373849601) – September 30, 2022\r\n\r\n_Edit:_ I tweeted about it [here](https://twitter.com/pcaversaccio/status/1549019584824590336) and will add further incidents if reported by the community.\r\n\r\n_Update:_ Due to the overwhelming positive feedback I have received on Twitter, I decided to create my own repository [here](https://github.com/pcaversaccio/reentrancy-attacks) that tracks all of the reentrancy attacks. I will try my best to keep everything up to date.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1187381059/reactions",
      "total_count": 46,
      "+1": 30,
      "-1": 0,
      "laugh": 0,
      "hooray": 4,
      "confused": 0,
      "heart": 12,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1187447819",
    "html_url": "https://github.com/ethereum/solidity/issues/12996#issuecomment-1187447819",
    "issue_url": "https://api.github.com/repos/ethereum/solidity/issues/12996",
    "id": 1187447819,
    "node_id": "IC_kwDOAm_5kc5GxwQL",
    "user": {
      "login": "Genysys",
      "id": 33553806,
      "node_id": "MDQ6VXNlcjMzNTUzODA2",
      "avatar_url": "https://avatars.githubusercontent.com/u/33553806?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Genysys",
      "html_url": "https://github.com/Genysys",
      "followers_url": "https://api.github.com/users/Genysys/followers",
      "following_url": "https://api.github.com/users/Genysys/following{/other_user}",
      "gists_url": "https://api.github.com/users/Genysys/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Genysys/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Genysys/subscriptions",
      "organizations_url": "https://api.github.com/users/Genysys/orgs",
      "repos_url": "https://api.github.com/users/Genysys/repos",
      "events_url": "https://api.github.com/users/Genysys/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Genysys/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-07-18T13:35:24Z",
    "updated_at": "2022-07-18T13:35:41Z",
    "author_association": "NONE",
    "body": "This is a great idea. Omni NFT was also an reentrancy attack and it would be great to have it here.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1187447819/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1187492897",
    "html_url": "https://github.com/ethereum/solidity/issues/12996#issuecomment-1187492897",
    "issue_url": "https://api.github.com/repos/ethereum/solidity/issues/12996",
    "id": 1187492897,
    "node_id": "IC_kwDOAm_5kc5Gx7Qh",
    "user": {
      "login": "0xalpharush",
      "id": 87383155,
      "node_id": "MDQ6VXNlcjg3MzgzMTU1",
      "avatar_url": "https://avatars.githubusercontent.com/u/87383155?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/0xalpharush",
      "html_url": "https://github.com/0xalpharush",
      "followers_url": "https://api.github.com/users/0xalpharush/followers",
      "following_url": "https://api.github.com/users/0xalpharush/following{/other_user}",
      "gists_url": "https://api.github.com/users/0xalpharush/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/0xalpharush/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/0xalpharush/subscriptions",
      "organizations_url": "https://api.github.com/users/0xalpharush/orgs",
      "repos_url": "https://api.github.com/users/0xalpharush/repos",
      "events_url": "https://api.github.com/users/0xalpharush/events{/privacy}",
      "received_events_url": "https://api.github.com/users/0xalpharush/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-07-18T13:54:02Z",
    "updated_at": "2022-07-18T14:01:20Z",
    "author_association": "CONTRIBUTOR",
    "body": "Adding a mutex to functions that write after external calls would not address cases where separate functions read from stale values or overwrite the same storage value. \r\n\r\nTake an example from the SAILFISH paper where adding a mutex is insufficient: \r\n```\r\ncontract Test { \r\n\tmapping(uint => uint) splits;\r\n\tmapping(uint => uint) deposits;\r\n\tmapping(uint => address payable) payee1;\r\n\tmapping(uint => address payable) payee2;\r\n\tuint lock;\r\n\tmodifier nonReentrant() {\r\n\t\tlock = 1;\r\n\t\t_;\r\n\t\tlock = 0;\r\n\t}\r\n\tfunction updateSplit(uint id, uint split) public{\r\n\t\trequire(split <= 100);\r\n\t\tsplits[id] = split;\r\n\t}\r\n\t// [Step 1]: Set split of ’a’ (id = 0) to 100(%)\r\n        // [Step 4]: Set split of ’a’ (id = 0) to 0(%)\r\n\tfunction splitFunds(uint id) public nonReentrant {\r\n\t\taddress payable a = payee1[id];\r\n\t\taddress payable b = payee2[id];\r\n\t\tuint depo = deposits[id];\r\n\t\tdeposits[id] = 0;\r\n\r\n                // [Step 2]: Transfer 100% fund to ’a’\r\n                // [Step 3]: Reenter updateSplit\r\n\t\ta.call{value:(depo * splits[id] / 100)}(\"\");\r\n                 \r\n                 // [Step 5]: Transfer 100% fund to ’b’\r\n\t\tb.transfer(depo * (100 - splits[id]) / 100);\r\n \t}\r\n}\r\n```\r\nRather than strictly identifying instances that do not follow check-effects-interact, it would make sense to look for function calls that allow for control flow to be controlled externally (as opposed to explicitly indicated like an if-else statement). I think this is clear if one examines the output of `slither Test.sol --print slithir-ssa`:\r\n```\r\nContract Test\r\n        Function Test.updateSplit(uint256,uint256)\r\n                Expression: require(bool)(split <= 100)\r\n                IRs:\r\n                        TMP_0(bool) = split_1 <= 100\r\n                        TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)\r\n                Expression: splits[id] = split\r\n                IRs:\r\n                        REF_0(uint256) -> splits_0[id_1]\r\n                        splits_1(mapping(uint256 => uint256)) := ϕ(['splits_0'])\r\n                        REF_0 (->splits_1) := split_1(uint256)\r\n        Function Test.splitFunds(uint256)\r\n                IRs:\r\n                        splits_2(mapping(uint256 => uint256)) := ϕ(['splits_4', 'splits_1', 'splits_0'])\r\n                        deposits_1(mapping(uint256 => uint256)) := ϕ(['deposits_0', 'deposits_3'])\r\n                        payee1_1(mapping(uint256 => address)) := ϕ(['payee1_2', 'payee1_0'])\r\n                        payee2_1(mapping(uint256 => address)) := ϕ(['payee2_0', 'payee2_2'])\r\n                Expression: a = payee1[id]\r\n                IRs:\r\n                        REF_1(address) -> payee1_2[id_1]\r\n                        a_1(address) := REF_1(address)\r\n                Expression: b = payee2[id]\r\n                IRs:\r\n                        REF_2(address) -> payee2_2[id_1]\r\n                        b_1(address) := REF_2(address)\r\n                Expression: depo = deposits[id]\r\n                IRs:\r\n                        REF_3(uint256) -> deposits_2[id_1]\r\n                        depo_1(uint256) := REF_3(uint256)\r\n                Expression: deposits[id] = 0\r\n                IRs:\r\n                        REF_4(uint256) -> deposits_2[id_1]\r\n                        deposits_3(mapping(uint256 => uint256)) := ϕ(['deposits_2'])\r\n                        REF_4 (->deposits_3) := 0(uint256)\r\n                Expression: a.call{value: (depo * splits[id] / 100)}()\r\n                IRs:\r\n                        REF_6(uint256) -> splits_3[id_1]\r\n                        TMP_2(uint256) = depo_1 (c)* REF_6\r\n                        TMP_3(uint256) = TMP_2 (c)/ 100\r\n                        TUPLE_0(bool,bytes) = LOW_LEVEL_CALL, dest:a_1, function:call, arguments:[''] value:TMP_3 \r\n                        splits_4(mapping(uint256 => uint256)) := ϕ(['splits_3', 'splits_1', 'splits_4'])\r\n                Expression: b.transfer(depo * (100 - splits[id]) / 100)\r\n                IRs:\r\n                        REF_8(uint256) -> splits_4[id_1]\r\n                        TMP_4(uint256) = 100 (c)- REF_8\r\n                        TMP_5(uint256) = depo_1 (c)* TMP_4\r\n                        TMP_6(uint256) = TMP_5 (c)/ 100\r\n                        Transfer dest:b_1 value:TMP_6\r\n                Expression: nonReentrant()\r\n                IRs:\r\n                        MODIFIER_CALL, Test.nonReentrant()()\r\n```\r\nUpon examination, after `a.call` the mapping, `splits`, has a phi value, `splits_1`, that indicates the value can be updated during an external call in `updateSplit` and used to withdraw more funds than intended. This is essentially a source of \"undefined behavior\" that results from a developer not being explicit enough about the anticipated control flow. For background, Slither's SSA form creates phi variables after external calls (non STATICCALL) because it is a point where control flow merges. \r\n\r\nIf we treat reentrancy as an undefined behavior problem, I think we could find a happy medium that is not cumbersome for developers yet eliminates undefined behavior. This would encourage specification and hopefully reduce false positives/ fighting the compiler.\r\n\r\nIn order to introduce these sort of enhancements, I think it would make sense to consider the points raised in this [issue](https://github.com/ethereum/solidity/issues/13247#issuecomment-1175297584) and move towards a modular compiler design. People could opt in to passes that have more advanced analysis than the Solidity compiler and harden their code as they see fit (this is a common practice for other compiled languages). In addition, pruning infeasible paths would likely be slow and only required to run on \"release\" builds.\r\n\r\n\r\nP.S. I also like the use of TLOAD for reentrancy protection and think it would give developers less of a reason to circumvent compiler-generated protections, e.g. turning off reentrancy mitigations to reduce SLOADs. ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1187492897/reactions",
      "total_count": 4,
      "+1": 4,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1187821841",
    "html_url": "https://github.com/ethereum/solidity/issues/12996#issuecomment-1187821841",
    "issue_url": "https://api.github.com/repos/ethereum/solidity/issues/12996",
    "id": 1187821841,
    "node_id": "IC_kwDOAm_5kc5GzLkR",
    "user": {
      "login": "lukehutch",
      "id": 811305,
      "node_id": "MDQ6VXNlcjgxMTMwNQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/811305?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/lukehutch",
      "html_url": "https://github.com/lukehutch",
      "followers_url": "https://api.github.com/users/lukehutch/followers",
      "following_url": "https://api.github.com/users/lukehutch/following{/other_user}",
      "gists_url": "https://api.github.com/users/lukehutch/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/lukehutch/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/lukehutch/subscriptions",
      "organizations_url": "https://api.github.com/users/lukehutch/orgs",
      "repos_url": "https://api.github.com/users/lukehutch/repos",
      "events_url": "https://api.github.com/users/lukehutch/events{/privacy}",
      "received_events_url": "https://api.github.com/users/lukehutch/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-07-18T17:18:06Z",
    "updated_at": "2022-07-18T17:51:04Z",
    "author_association": "CONTRIBUTOR",
    "body": "> Let me try to share a common, chronological list of reentrancy attacks including their (mostly) detailed analyses:\r\n\r\n@pcaversaccio an awesome list -- thanks for compiling this!\r\n\r\n> Adding a mutex to functions that write after external calls would not address cases where separate functions read from stale values or overwrite the same storage value.\r\n\r\n@0xalpharush Correct, it's insufficient to prevent state changes if a parent frame in the call stack is a call to an external contract. You have to prevent state changes if a call was made to an external contract _at any previous point in the same transaction_. This is why I referred to EIP-1153, since it will provide a supported mechanism for binding state to the life of a transaction.\r\n\r\nHowever, perhaps this can be approximated by calculating\r\n\r\n```solidity\r\nbytes32 transactionId = keccak256(abi.encode(block.chainid, block.number));\r\n```\r\n\r\nthen modifiers could be created for functions that call external contracts and functions that update internal state as follows:\r\n\r\n```solidity\r\ncontract X {\r\n    bytes32 private extContractLastCalled_transactionId;\r\n\r\n    modifier extContractCaller() {\r\n        extContractLastCalled_transactionId = keccak256(abi.encode(block.chainid, block.number));\r\n        _;\r\n    }\r\n\r\n    modifier updateState() {\r\n        require (keccak256(abi.encode(block.chainid, block.number)) != extContractLastCalled_transactionId,\r\n                    \"Can't update state after calling external contract in the same transaction\");\r\n        _;\r\n    }\r\n}\r\n```\r\n\r\nI think this would work, but it's not ideal, because\r\n\r\n1. It is coarse-grained (applying at the level of function definitions, rather than per-line). This means the programmer has to be careful to segregate functions into external caller functions and state updater functions. If function modification is done automatically by the compiler using the above pattern, it will have to fail if a function both updates state and calls an external contract.\r\n2. It fails at runtime, not compiletime (I'm pretty sure 99% of relevant cases could be caught statically, through control flow analysis -- basically anything that is computable, which excludes cases where e.g. you call a data-derived function selector or something).\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1187821841/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1187924559",
    "html_url": "https://github.com/ethereum/solidity/issues/12996#issuecomment-1187924559",
    "issue_url": "https://api.github.com/repos/ethereum/solidity/issues/12996",
    "id": 1187924559,
    "node_id": "IC_kwDOAm_5kc5GzkpP",
    "user": {
      "login": "Genysys",
      "id": 33553806,
      "node_id": "MDQ6VXNlcjMzNTUzODA2",
      "avatar_url": "https://avatars.githubusercontent.com/u/33553806?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Genysys",
      "html_url": "https://github.com/Genysys",
      "followers_url": "https://api.github.com/users/Genysys/followers",
      "following_url": "https://api.github.com/users/Genysys/following{/other_user}",
      "gists_url": "https://api.github.com/users/Genysys/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Genysys/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Genysys/subscriptions",
      "organizations_url": "https://api.github.com/users/Genysys/orgs",
      "repos_url": "https://api.github.com/users/Genysys/repos",
      "events_url": "https://api.github.com/users/Genysys/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Genysys/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-07-18T17:48:08Z",
    "updated_at": "2022-07-18T17:49:15Z",
    "author_association": "NONE",
    "body": "> However, perhaps this can be approximated by calculating\r\n> \r\n> ```solidity\r\n> bytes32 transactionId = keccak256(abi.encode(block.chainid, block.number));\r\n> ```\r\n> \r\n\r\nWould replacing the mutex modifier with this and having the compiler automatically include it in every call be a reasonable compromise?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1187924559/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1188714924",
    "html_url": "https://github.com/ethereum/solidity/issues/12996#issuecomment-1188714924",
    "issue_url": "https://api.github.com/repos/ethereum/solidity/issues/12996",
    "id": 1188714924,
    "node_id": "IC_kwDOAm_5kc5G2lms",
    "user": {
      "login": "lukehutch",
      "id": 811305,
      "node_id": "MDQ6VXNlcjgxMTMwNQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/811305?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/lukehutch",
      "html_url": "https://github.com/lukehutch",
      "followers_url": "https://api.github.com/users/lukehutch/followers",
      "following_url": "https://api.github.com/users/lukehutch/following{/other_user}",
      "gists_url": "https://api.github.com/users/lukehutch/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/lukehutch/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/lukehutch/subscriptions",
      "organizations_url": "https://api.github.com/users/lukehutch/orgs",
      "repos_url": "https://api.github.com/users/lukehutch/repos",
      "events_url": "https://api.github.com/users/lukehutch/events{/privacy}",
      "received_events_url": "https://api.github.com/users/lukehutch/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-07-19T07:46:31Z",
    "updated_at": "2022-07-19T07:46:31Z",
    "author_association": "CONTRIBUTOR",
    "body": "Actually I think `transactionId` may need to also hash `tx.origin`, i.e.\r\n\r\n```solidity\r\nbytes32 transactionId = keccak256(abi.encode(block.chainid, block.number, tx.origin));\r\n```\r\n\r\nAlthough this still doesn't handle the case of a single EOA submitting multiple transactions to be mined in a single block.\r\n\r\nIs there any other way to reliably differentiate different transactions?",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1188714924/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1194118127",
    "html_url": "https://github.com/ethereum/solidity/issues/12996#issuecomment-1194118127",
    "issue_url": "https://api.github.com/repos/ethereum/solidity/issues/12996",
    "id": 1194118127,
    "node_id": "IC_kwDOAm_5kc5HLMvv",
    "user": {
      "login": "pcaversaccio",
      "id": 25297591,
      "node_id": "MDQ6VXNlcjI1Mjk3NTkx",
      "avatar_url": "https://avatars.githubusercontent.com/u/25297591?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/pcaversaccio",
      "html_url": "https://github.com/pcaversaccio",
      "followers_url": "https://api.github.com/users/pcaversaccio/followers",
      "following_url": "https://api.github.com/users/pcaversaccio/following{/other_user}",
      "gists_url": "https://api.github.com/users/pcaversaccio/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/pcaversaccio/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/pcaversaccio/subscriptions",
      "organizations_url": "https://api.github.com/users/pcaversaccio/orgs",
      "repos_url": "https://api.github.com/users/pcaversaccio/repos",
      "events_url": "https://api.github.com/users/pcaversaccio/events{/privacy}",
      "received_events_url": "https://api.github.com/users/pcaversaccio/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-07-25T14:23:36Z",
    "updated_at": "2022-07-25T14:24:44Z",
    "author_association": "NONE",
    "body": "Just as a quick reference for comparison, Vyper uses a simple [`@nonreentrant(<key>)`](https://vyper.readthedocs.io/en/latest/control-structures.html#re-entrancy-locks) decorator (which equals a modifier in Solidity) to prevent reentrancies. I haven't investigated in detail the decorator's behaviour but from the first sight, it would still allow for cross-contract reentrancies as well as for the above example shared by @0xalpharush in case `updateSplit` would not be protected by such a decorator.\r\n\r\nThe main point is the following:\r\n> Nonreentrancy locks work by setting a specially allocated storage slot to a <locked> value on function entrance, and setting it to an <unlocked> value on function exit. On function entrance, if the storage slot is detected to be the <locked> value, execution reverts.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1194118127/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1199036226",
    "html_url": "https://github.com/ethereum/solidity/issues/12996#issuecomment-1199036226",
    "issue_url": "https://api.github.com/repos/ethereum/solidity/issues/12996",
    "id": 1199036226,
    "node_id": "IC_kwDOAm_5kc5Hd9dC",
    "user": {
      "login": "pcaversaccio",
      "id": 25297591,
      "node_id": "MDQ6VXNlcjI1Mjk3NTkx",
      "avatar_url": "https://avatars.githubusercontent.com/u/25297591?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/pcaversaccio",
      "html_url": "https://github.com/pcaversaccio",
      "followers_url": "https://api.github.com/users/pcaversaccio/followers",
      "following_url": "https://api.github.com/users/pcaversaccio/following{/other_user}",
      "gists_url": "https://api.github.com/users/pcaversaccio/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/pcaversaccio/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/pcaversaccio/subscriptions",
      "organizations_url": "https://api.github.com/users/pcaversaccio/orgs",
      "repos_url": "https://api.github.com/users/pcaversaccio/repos",
      "events_url": "https://api.github.com/users/pcaversaccio/events{/privacy}",
      "received_events_url": "https://api.github.com/users/pcaversaccio/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-07-29T08:53:14Z",
    "updated_at": "2022-07-29T08:53:14Z",
    "author_association": "NONE",
    "body": "Linking this [EIP initiative](https://github.com/SergioDemianLerner/EIPs-Semaphore/blob/36c0f795deceee205023da4968549a7a8e86d511/EIPS/eip-semaphore.md) by @SergioDemianLerner since it can be relevant to this discussion. The proposal is to implement (through a hard fork) a reentrancy guard as a precompile. I don't think we should solve this issue via a hard fork. It's not an EVM problem but a compiler problem. Even if we had such a pre-compile, the discussed issue would still exist by _default_. ",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1199036226/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1199352257",
    "html_url": "https://github.com/ethereum/solidity/issues/12996#issuecomment-1199352257",
    "issue_url": "https://api.github.com/repos/ethereum/solidity/issues/12996",
    "id": 1199352257,
    "node_id": "IC_kwDOAm_5kc5HfKnB",
    "user": {
      "login": "lukehutch",
      "id": 811305,
      "node_id": "MDQ6VXNlcjgxMTMwNQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/811305?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/lukehutch",
      "html_url": "https://github.com/lukehutch",
      "followers_url": "https://api.github.com/users/lukehutch/followers",
      "following_url": "https://api.github.com/users/lukehutch/following{/other_user}",
      "gists_url": "https://api.github.com/users/lukehutch/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/lukehutch/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/lukehutch/subscriptions",
      "organizations_url": "https://api.github.com/users/lukehutch/orgs",
      "repos_url": "https://api.github.com/users/lukehutch/repos",
      "events_url": "https://api.github.com/users/lukehutch/events{/privacy}",
      "received_events_url": "https://api.github.com/users/lukehutch/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-07-29T14:11:37Z",
    "updated_at": "2022-07-29T14:11:37Z",
    "author_association": "CONTRIBUTOR",
    "body": "@pcaversaccio right, a hard fork would solve the problem in the wrong way. Reentrance can and should be statically determined. Slither already does this (although I don't know what degree of complexity it handles).",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1199352257/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1201178506",
    "html_url": "https://github.com/ethereum/solidity/issues/12996#issuecomment-1201178506",
    "issue_url": "https://api.github.com/repos/ethereum/solidity/issues/12996",
    "id": 1201178506,
    "node_id": "IC_kwDOAm_5kc5HmIeK",
    "user": {
      "login": "gpersoon",
      "id": 5469459,
      "node_id": "MDQ6VXNlcjU0Njk0NTk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5469459?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gpersoon",
      "html_url": "https://github.com/gpersoon",
      "followers_url": "https://api.github.com/users/gpersoon/followers",
      "following_url": "https://api.github.com/users/gpersoon/following{/other_user}",
      "gists_url": "https://api.github.com/users/gpersoon/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gpersoon/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gpersoon/subscriptions",
      "organizations_url": "https://api.github.com/users/gpersoon/orgs",
      "repos_url": "https://api.github.com/users/gpersoon/repos",
      "events_url": "https://api.github.com/users/gpersoon/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gpersoon/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-08-01T13:07:30Z",
    "updated_at": "2022-08-01T13:07:40Z",
    "author_association": "NONE",
    "body": "With ERC777 it can be the other way around see: https://twitter.com/transmissions11/status/1496944873760428058",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1201178506/reactions",
      "total_count": 1,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 1
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1201622750",
    "html_url": "https://github.com/ethereum/solidity/issues/12996#issuecomment-1201622750",
    "issue_url": "https://api.github.com/repos/ethereum/solidity/issues/12996",
    "id": 1201622750,
    "node_id": "IC_kwDOAm_5kc5Hn07e",
    "user": {
      "login": "lukehutch",
      "id": 811305,
      "node_id": "MDQ6VXNlcjgxMTMwNQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/811305?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/lukehutch",
      "html_url": "https://github.com/lukehutch",
      "followers_url": "https://api.github.com/users/lukehutch/followers",
      "following_url": "https://api.github.com/users/lukehutch/following{/other_user}",
      "gists_url": "https://api.github.com/users/lukehutch/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/lukehutch/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/lukehutch/subscriptions",
      "organizations_url": "https://api.github.com/users/lukehutch/orgs",
      "repos_url": "https://api.github.com/users/lukehutch/repos",
      "events_url": "https://api.github.com/users/lukehutch/events{/privacy}",
      "received_events_url": "https://api.github.com/users/lukehutch/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-08-01T19:28:39Z",
    "updated_at": "2022-08-01T19:28:39Z",
    "author_association": "CONTRIBUTOR",
    "body": "> With ERC777 it can be the other way around see: https://twitter.com/transmissions11/status/1496944873760428058\r\n\r\nGood point, and correct, I pointed that out here: https://github.com/OpenZeppelin/openzeppelin-contracts/issues/2620#issuecomment-1156118047\r\n\r\nThe ERC777 standard is insecure by default, and needs to be deprecated. But presumably there should be a compiler directive in case anyone really wanted to turn off Checks-Effects-Interactions order checking for a given function.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1201622750/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1203296364",
    "html_url": "https://github.com/ethereum/solidity/issues/12996#issuecomment-1203296364",
    "issue_url": "https://api.github.com/repos/ethereum/solidity/issues/12996",
    "id": 1203296364,
    "node_id": "IC_kwDOAm_5kc5HuNhs",
    "user": {
      "login": "SergioDemianLerner",
      "id": 1752347,
      "node_id": "MDQ6VXNlcjE3NTIzNDc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1752347?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/SergioDemianLerner",
      "html_url": "https://github.com/SergioDemianLerner",
      "followers_url": "https://api.github.com/users/SergioDemianLerner/followers",
      "following_url": "https://api.github.com/users/SergioDemianLerner/following{/other_user}",
      "gists_url": "https://api.github.com/users/SergioDemianLerner/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/SergioDemianLerner/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/SergioDemianLerner/subscriptions",
      "organizations_url": "https://api.github.com/users/SergioDemianLerner/orgs",
      "repos_url": "https://api.github.com/users/SergioDemianLerner/repos",
      "events_url": "https://api.github.com/users/SergioDemianLerner/events{/privacy}",
      "received_events_url": "https://api.github.com/users/SergioDemianLerner/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-08-02T23:05:17Z",
    "updated_at": "2022-08-02T23:05:17Z",
    "author_association": "NONE",
    "body": "My [EIP-5283](https://github.com/ethereum/EIPs/blob/0ac341a39e3927b0cb51aa4d2e96fc19475f1bc8/EIPS/eip-5283.md) represents the simplest hard-fork that provides the mutex functionality that is future-proof for EVM parallel tx execution with fine-grained parallelization. The sooner we introduce such a feature, the higher the number of deployed contracts will be parallelizable.\r\nI would also prefer the transient opcodes TLOAD and TSTORE to be used, but adding opcodes is not as easy, since it impacts a lot of tooling.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1203296364/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
