{
  "url": "https://api.github.com/repos/ethereum/solidity/issues/13335",
  "repository_url": "https://api.github.com/repos/ethereum/solidity",
  "labels_url": "https://api.github.com/repos/ethereum/solidity/issues/13335/labels{/name}",
  "comments_url": "https://api.github.com/repos/ethereum/solidity/issues/13335/comments",
  "events_url": "https://api.github.com/repos/ethereum/solidity/issues/13335/events",
  "html_url": "https://github.com/ethereum/solidity/issues/13335",
  "id": 1323383262,
  "node_id": "I_kwDOAm_5kc5O4Tne",
  "number": 13335,
  "title": "Some possible arithmetic issues/optimizations in the generated #utility.yul ",
  "user": {
    "login": "minhhn2910",
    "id": 7065814,
    "node_id": "MDQ6VXNlcjcwNjU4MTQ=",
    "avatar_url": "https://avatars.githubusercontent.com/u/7065814?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/minhhn2910",
    "html_url": "https://github.com/minhhn2910",
    "followers_url": "https://api.github.com/users/minhhn2910/followers",
    "following_url": "https://api.github.com/users/minhhn2910/following{/other_user}",
    "gists_url": "https://api.github.com/users/minhhn2910/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/minhhn2910/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/minhhn2910/subscriptions",
    "organizations_url": "https://api.github.com/users/minhhn2910/orgs",
    "repos_url": "https://api.github.com/users/minhhn2910/repos",
    "events_url": "https://api.github.com/users/minhhn2910/events{/privacy}",
    "received_events_url": "https://api.github.com/users/minhhn2910/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [

  ],
  "state": "open",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 1,
  "created_at": "2022-07-31T07:16:52Z",
  "updated_at": "2022-08-04T18:37:04Z",
  "closed_at": null,
  "author_association": "NONE",
  "active_lock_reason": null,
  "body": "## Description\r\n\r\nWhen testing with migrating some simple contracts from solc-7 to solc-8, our in-house evm bytecode fuzzing tool starts to complain about arithmetic bugs in `#utility.yul`  that is injected since solc-8. Although these alerts actually do not affect the output, we want to ask if these behaviors are all intended or they will be optimized in the future ?\r\n\r\n## Environment\r\n\r\n- Compiler version: 0.8.15+commit.e14f2714  --optimize.\r\n- Target EVM version : default\r\n- Framework/IDE : N/A\r\n- EVM execution environment / backend / blockchain client: py-evm\r\n\r\n## Steps to Reproduce\r\n\r\n```\r\npragma solidity ^0.8.15;\r\ncontract example{\r\n    uint8 a; uint8 b;\r\n    function test() public{\r\n        a++;\r\n\tb = b*a;\r\n    }\r\n}\r\n```\r\n---\r\n```\r\nBug1: division by zero\r\n#utility.yul 486:500\r\nline 19:         if and(iszero(iszero(x_1)), gt(y_1, div(0xff, x_1))) { panic_error_0x11() }\r\narithmetic log: 0 = 255 / 0\r\n----------------------------------------------------------------------------------\r\nPotential bug2: Integer underflow \r\n#utility.yul 244:261\r\nline 12:         if eq(value_1, 0xff) { panic_error_0x11() }\r\narithmetic log : 115792089237316195423570985008687907853269984665640564039457584007913129639681 == 0 - 255\r\n```\r\n---\r\n## Comments \r\nBug1 happens whenever a multiplication is used with `x=0`, the `checked_mul_t_uint8(x, y)` in yul code:\r\n```\r\nfunction checked_mul_t_uint8(x, y) -> product {\r\n                x := cleanup_t_uint8(x)\r\n                y := cleanup_t_uint8(y)\r\n                // overflow, if x != 0 and y > (maxValue / x)\r\n                if and(iszero(iszero(x)), gt(y, div(0xff, x))) { panic_error_0x11() }\r\n                product := mul(x, y)\r\n            }\r\n```\r\n\r\nIf the `x/0 = 0` is intended following Ethereum yellow paper, non-orthodox evm or  web-assembly runtime implementations (where they throw exception with div/0) will revert tx if we do checked_multiply with 0\r\n\r\n---\r\nPotential Bug2 is not a bug and actually is the compiler generating the check for `increment_t_uint8` for `a++`\r\n```\r\nfunction increment_t_uint8(value) -> ret {\r\n                value := cleanup_t_uint8(value)\r\n                if eq(value, 0xff) { panic_error_0x11() }\r\n                ret := add(value, 1)\r\n            }\r\n```\r\nThe `eq(value, 0xff) ` is implemented by subtraction which does`value - 0xff` everytime the function is called with the trace\r\n\r\n```\r\nOPCODE: 0x60 (PUSH1) | pc: 166 | stack: [... '0x00', '0x45', '0x0'] \r\nOPCODE: 0x60 (PUSH1) | pc: 168 | stack: [... '0x45', '0x0', '0x00'] \r\nOPCODE: 0x82 (DUP3) | pc: 170 | stack: [..., '0x0', '0x00', '0xff'] \r\nOPCODE: 0x16 (AND) | pc: 171 | stack: [..., '0x0', '0x00', '0xff', '0x0'] \r\nOPCODE: 0x60 (PUSH1) | pc: 172 | stack: [..., '0x0', '0x00', '0x0'] \r\nOPCODE: 0x81 (DUP2) | pc: 174 | stack: [..., '0x00', '0x0', '0xff'] \r\nOPCODE: 0x3 (SUB) | pc: 175 | stack: [..., '0xff', '0x0'] \r\nOPCODE: 0x60 (PUSH1) | pc: 176 | stack: [..., '0x0', '0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff01'] \r\nOPCODE: 0x57 (JUMPI) | pc: 178 | stack: [..., '0x00', '0x0', '0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff01', '0xb8'] \r\n```\r\nPlease correct me if I'm wrong, isn't it more gas efficient to do a `GT` check on 0xfe to replace ` eq(value, 0xff) ` instead of the above sequence ? It may save significant gas in the for loops using increment value.\r\n ",
  "closed_by": null,
  "reactions": {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/13335/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/ethereum/solidity/issues/13335/timeline",
  "performed_via_github_app": null,
  "state_reason": null
}
[
  {
    "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1205628780",
    "html_url": "https://github.com/ethereum/solidity/issues/13335#issuecomment-1205628780",
    "issue_url": "https://api.github.com/repos/ethereum/solidity/issues/13335",
    "id": 1205628780,
    "node_id": "IC_kwDOAm_5kc5H3G9s",
    "user": {
      "login": "ekpyron",
      "id": 1347491,
      "node_id": "MDQ6VXNlcjEzNDc0OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1347491?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ekpyron",
      "html_url": "https://github.com/ekpyron",
      "followers_url": "https://api.github.com/users/ekpyron/followers",
      "following_url": "https://api.github.com/users/ekpyron/following{/other_user}",
      "gists_url": "https://api.github.com/users/ekpyron/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ekpyron/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ekpyron/subscriptions",
      "organizations_url": "https://api.github.com/users/ekpyron/orgs",
      "repos_url": "https://api.github.com/users/ekpyron/repos",
      "events_url": "https://api.github.com/users/ekpyron/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ekpyron/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-08-04T18:37:04Z",
    "updated_at": "2022-08-04T18:37:04Z",
    "author_association": "MEMBER",
    "body": "The EVM defines division by zero to be zero, not as a revert (as you say yourself) - since our code generation targets an EVM following that specification, I'd not consider divisions by zero a bug - I don't think it's really practical for us to take any potential \"non-orthodox\" EVM implementation into account :-).\r\nThat being said, for those particular multiplication overflow checks, we may change the code generation to a division-free version in the near future - at least in some cases, but even then I couldn't guarantee that the generated bytecode will never contain a division by zero, since given the EVM spec it's perfectly valid.\r\n\r\nRegarding the second point: the reason why we need masking before the equality comparison is that the generated code is meant to be robust against dirty higher-order bits in ``value``. Consider\r\n```\r\nfunction f() public {\r\n  uint8 x;\r\n  assembly { x := 0x0100 }\r\n  x++;\r\n}\r\n```\r\nHere ``x`` is treated as having an effective value of zero, even after the inline assembly write and therefore the increment does *not* overflow. If the overflow check was implemented using ``gt(x,0xfe)``, however, it would kick in and would revert.\r\n\r\nIt is an arguable design choice to prefer robustness against dirty values - but that's how things worked traditionally and changing that would be a breaking change...\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/ethereum/solidity/issues/comments/1205628780/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
