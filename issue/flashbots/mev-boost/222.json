{
  "url": "https://api.github.com/repos/flashbots/mev-boost/issues/222",
  "repository_url": "https://api.github.com/repos/flashbots/mev-boost",
  "labels_url": "https://api.github.com/repos/flashbots/mev-boost/issues/222/labels{/name}",
  "comments_url": "https://api.github.com/repos/flashbots/mev-boost/issues/222/comments",
  "events_url": "https://api.github.com/repos/flashbots/mev-boost/issues/222/events",
  "html_url": "https://github.com/flashbots/mev-boost/issues/222",
  "id": 1313296647,
  "node_id": "I_kwDOGZSKs85OR1EH",
  "number": 222,
  "title": "Safeguards and mitigations to preserve liveness",
  "user": {
    "login": "come-maiz",
    "id": 617831,
    "node_id": "MDQ6VXNlcjYxNzgzMQ==",
    "avatar_url": "https://avatars.githubusercontent.com/u/617831?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/come-maiz",
    "html_url": "https://github.com/come-maiz",
    "followers_url": "https://api.github.com/users/come-maiz/followers",
    "following_url": "https://api.github.com/users/come-maiz/following{/other_user}",
    "gists_url": "https://api.github.com/users/come-maiz/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/come-maiz/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/come-maiz/subscriptions",
    "organizations_url": "https://api.github.com/users/come-maiz/orgs",
    "repos_url": "https://api.github.com/users/come-maiz/repos",
    "events_url": "https://api.github.com/users/come-maiz/events{/privacy}",
    "received_events_url": "https://api.github.com/users/come-maiz/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 4246664397,
      "node_id": "LA_kwDOGZSKs879HvTN",
      "url": "https://api.github.com/repos/flashbots/mev-boost/labels/security",
      "name": "security",
      "color": "bfd4f2",
      "default": false,
      "description": ""
    }
  ],
  "state": "open",
  "locked": false,
  "assignee": null,
  "assignees": [

  ],
  "milestone": null,
  "comments": 22,
  "created_at": "2022-07-21T13:51:37Z",
  "updated_at": "2022-08-05T17:54:17Z",
  "closed_at": null,
  "author_association": "CONTRIBUTOR",
  "active_lock_reason": null,
  "body": "We want to document the conditions related to mev-boost and the Flashbots relay that would affect the liveness of the blockchain, to make sure that they are prevented or mitigated.\r\n\r\nWe want to test these conditions live in a testnet.",
  "closed_by": null,
  "reactions": {
    "url": "https://api.github.com/repos/flashbots/mev-boost/issues/222/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/flashbots/mev-boost/issues/222/timeline",
  "performed_via_github_app": null,
  "state_reason": null
}
[
  {
    "url": "https://api.github.com/repos/flashbots/mev-boost/issues/comments/1191531834",
    "html_url": "https://github.com/flashbots/mev-boost/issues/222#issuecomment-1191531834",
    "issue_url": "https://api.github.com/repos/flashbots/mev-boost/issues/222",
    "id": 1191531834,
    "node_id": "IC_kwDOGZSKs85HBVU6",
    "user": {
      "login": "come-maiz",
      "id": 617831,
      "node_id": "MDQ6VXNlcjYxNzgzMQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/617831?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/come-maiz",
      "html_url": "https://github.com/come-maiz",
      "followers_url": "https://api.github.com/users/come-maiz/followers",
      "following_url": "https://api.github.com/users/come-maiz/following{/other_user}",
      "gists_url": "https://api.github.com/users/come-maiz/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/come-maiz/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/come-maiz/subscriptions",
      "organizations_url": "https://api.github.com/users/come-maiz/orgs",
      "repos_url": "https://api.github.com/users/come-maiz/repos",
      "events_url": "https://api.github.com/users/come-maiz/events{/privacy}",
      "received_events_url": "https://api.github.com/users/come-maiz/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-07-21T14:08:08Z",
    "updated_at": "2022-07-21T14:08:08Z",
    "author_association": "CONTRIBUTOR",
    "body": "- The relay is offline or overloaded.\r\n\r\nThe main part of the sidecar design is to be able to use the local execution client to produce blocks. If the relay doesn't reply to mev-boost, the proposer will still be able to get a valid block, get attestations, and earn rewards. \r\n\r\nTODO: check that all the consensus clients fall back to the local execution client when they get no reply to the `getHeader` or `registerValidator` calls.\r\n\r\nquestion: what is the expected reply time from the relay? How much time will the proposer wait for an answer? Will there be plenty of time to execute the fallback code path?\r\n\r\nquestion: should the local execution client build a block in parallel so it is ready in case the relay fails?",
    "reactions": {
      "url": "https://api.github.com/repos/flashbots/mev-boost/issues/comments/1191531834/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/flashbots/mev-boost/issues/comments/1191536560",
    "html_url": "https://github.com/flashbots/mev-boost/issues/222#issuecomment-1191536560",
    "issue_url": "https://api.github.com/repos/flashbots/mev-boost/issues/222",
    "id": 1191536560,
    "node_id": "IC_kwDOGZSKs85HBWew",
    "user": {
      "login": "djrtwo",
      "id": 1433595,
      "node_id": "MDQ6VXNlcjE0MzM1OTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1433595?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/djrtwo",
      "html_url": "https://github.com/djrtwo",
      "followers_url": "https://api.github.com/users/djrtwo/followers",
      "following_url": "https://api.github.com/users/djrtwo/following{/other_user}",
      "gists_url": "https://api.github.com/users/djrtwo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/djrtwo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/djrtwo/subscriptions",
      "organizations_url": "https://api.github.com/users/djrtwo/orgs",
      "repos_url": "https://api.github.com/users/djrtwo/repos",
      "events_url": "https://api.github.com/users/djrtwo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/djrtwo/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-07-21T14:12:18Z",
    "updated_at": "2022-07-21T14:12:48Z",
    "author_association": "NONE",
    "body": "not just fall-back in event of no reply, but I would suggest running the build process in parallel and just not \"getting the local block\" if mev-boost is working properly. otherwise, abort mev-boost and get the locally built block\r\n\r\nEDIT: just saw your last question. that's what I would suggest ðŸ‘ ",
    "reactions": {
      "url": "https://api.github.com/repos/flashbots/mev-boost/issues/comments/1191536560/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/flashbots/mev-boost/issues/comments/1191541175",
    "html_url": "https://github.com/flashbots/mev-boost/issues/222#issuecomment-1191541175",
    "issue_url": "https://api.github.com/repos/flashbots/mev-boost/issues/222",
    "id": 1191541175,
    "node_id": "IC_kwDOGZSKs85HBXm3",
    "user": {
      "login": "come-maiz",
      "id": 617831,
      "node_id": "MDQ6VXNlcjYxNzgzMQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/617831?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/come-maiz",
      "html_url": "https://github.com/come-maiz",
      "followers_url": "https://api.github.com/users/come-maiz/followers",
      "following_url": "https://api.github.com/users/come-maiz/following{/other_user}",
      "gists_url": "https://api.github.com/users/come-maiz/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/come-maiz/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/come-maiz/subscriptions",
      "organizations_url": "https://api.github.com/users/come-maiz/orgs",
      "repos_url": "https://api.github.com/users/come-maiz/repos",
      "events_url": "https://api.github.com/users/come-maiz/events{/privacy}",
      "received_events_url": "https://api.github.com/users/come-maiz/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-07-21T14:16:08Z",
    "updated_at": "2022-07-21T14:16:08Z",
    "author_association": "CONTRIBUTOR",
    "body": "- A trusted relay has a bug.\r\n\r\nBecause of the previous point, and since the relay is trusted, the relay team can just disconnect it while the bug is solved.\r\n\r\nFor the flashbots relay we will have two devops to cover most timezones, with their respective backup humans, and alerts to notify them when things are suspicious. When things are weird, the process should start with putting the relay offline while we understand the problem.\r\n\r\nquestion: what are the conditions we should monitor to identify problems?\r\n\r\nquestion: what weird things could start to happen if there is no trusted relay available for mev extraction?\r\n\r\nquestion: what happens if the relay was trusted but now goes rogue or just can't or won't shut down?",
    "reactions": {
      "url": "https://api.github.com/repos/flashbots/mev-boost/issues/comments/1191541175/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/flashbots/mev-boost/issues/comments/1191558893",
    "html_url": "https://github.com/flashbots/mev-boost/issues/222#issuecomment-1191558893",
    "issue_url": "https://api.github.com/repos/flashbots/mev-boost/issues/222",
    "id": 1191558893,
    "node_id": "IC_kwDOGZSKs85HBb7t",
    "user": {
      "login": "come-maiz",
      "id": 617831,
      "node_id": "MDQ6VXNlcjYxNzgzMQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/617831?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/come-maiz",
      "html_url": "https://github.com/come-maiz",
      "followers_url": "https://api.github.com/users/come-maiz/followers",
      "following_url": "https://api.github.com/users/come-maiz/following{/other_user}",
      "gists_url": "https://api.github.com/users/come-maiz/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/come-maiz/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/come-maiz/subscriptions",
      "organizations_url": "https://api.github.com/users/come-maiz/orgs",
      "repos_url": "https://api.github.com/users/come-maiz/repos",
      "events_url": "https://api.github.com/users/come-maiz/events{/privacy}",
      "received_events_url": "https://api.github.com/users/come-maiz/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-07-21T14:31:19Z",
    "updated_at": "2022-07-21T14:31:19Z",
    "author_association": "CONTRIBUTOR",
    "body": "- proposers start using untrusted relays.\r\n\r\nWe have to inform everybody of the risks of using a relay that is not trustworthy either because their intentions are not clear, they are profit-maximizing above all else, they have no reliable uptime, or they are not careful enforcing that the builders are providing valid and sensible blocks.\r\n\r\nWe want all the people interested in running a relay to start by running a builder, so they understand all the challenges and get our support. See #145.\r\n\r\nWe can have a relay monitor, so when one proposer is affected, they can share the information and warn the others. See #142.\r\n\r\nquestion: what makes a relay not trustworthy?\r\n\r\nquestion: if a relay repeatedly misbehaves, should mev-boost or the consensus client discard it and force the operator to run a command to enable it again? How often will mev-boost interact with the relay? If this is not often, then the permanent disconnection could be too slow.\r\n\r\nquestion: what metrics should be monitor? How do we translate this into a number that lets proposers evaluate the risk of using a specific relay.\r\n\r\nquestion: what happens if the relay monitor fails or goes rogue?",
    "reactions": {
      "url": "https://api.github.com/repos/flashbots/mev-boost/issues/comments/1191558893/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/flashbots/mev-boost/issues/comments/1191585919",
    "html_url": "https://github.com/flashbots/mev-boost/issues/222#issuecomment-1191585919",
    "issue_url": "https://api.github.com/repos/flashbots/mev-boost/issues/222",
    "id": 1191585919,
    "node_id": "IC_kwDOGZSKs85HBih_",
    "user": {
      "login": "come-maiz",
      "id": 617831,
      "node_id": "MDQ6VXNlcjYxNzgzMQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/617831?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/come-maiz",
      "html_url": "https://github.com/come-maiz",
      "followers_url": "https://api.github.com/users/come-maiz/followers",
      "following_url": "https://api.github.com/users/come-maiz/following{/other_user}",
      "gists_url": "https://api.github.com/users/come-maiz/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/come-maiz/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/come-maiz/subscriptions",
      "organizations_url": "https://api.github.com/users/come-maiz/orgs",
      "repos_url": "https://api.github.com/users/come-maiz/repos",
      "events_url": "https://api.github.com/users/come-maiz/events{/privacy}",
      "received_events_url": "https://api.github.com/users/come-maiz/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-07-21T14:54:23Z",
    "updated_at": "2022-07-21T14:54:23Z",
    "author_association": "CONTRIBUTOR",
    "body": "- a relay serves valid and sensible blocks, but they are slowly manipulating things that will build up to a take over :fire: :fire: :fire: \r\n\r\nThe relays have to be very strongly and constantly scrutinized by the searchers, builders and proposers. \r\nFor a relay to be trusted it has to publish the data necessary for verifying its operation.\r\nhttps://flashbots.notion.site/Relay-API-Spec-5fb0819366954962bc02e81cb33840f5#38a21c8a40e64970904500eb7b373ea5 and https://github.com/flashbots/flashbots-data-transparency\r\n\r\nA relay should get the blocks from a trusted builder or from a network of competing builders that is stable and not centralized.\r\n\r\nquestion: what happens if the most profitable builder is shady? Like anonymous and not trustworthy, solely profit oriented. The short term economic incentive would be to use it, then it will get a majority and will own the blockchain.\r\n\r\n:thinking: maybe the relay can rotate the builders, so none of them produces more than X% of the blocks. Not the best idea for profitability, but makes sense for long-term stability.",
    "reactions": {
      "url": "https://api.github.com/repos/flashbots/mev-boost/issues/comments/1191585919/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/flashbots/mev-boost/issues/comments/1191588278",
    "html_url": "https://github.com/flashbots/mev-boost/issues/222#issuecomment-1191588278",
    "issue_url": "https://api.github.com/repos/flashbots/mev-boost/issues/222",
    "id": 1191588278,
    "node_id": "IC_kwDOGZSKs85HBjG2",
    "user": {
      "login": "come-maiz",
      "id": 617831,
      "node_id": "MDQ6VXNlcjYxNzgzMQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/617831?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/come-maiz",
      "html_url": "https://github.com/come-maiz",
      "followers_url": "https://api.github.com/users/come-maiz/followers",
      "following_url": "https://api.github.com/users/come-maiz/following{/other_user}",
      "gists_url": "https://api.github.com/users/come-maiz/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/come-maiz/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/come-maiz/subscriptions",
      "organizations_url": "https://api.github.com/users/come-maiz/orgs",
      "repos_url": "https://api.github.com/users/come-maiz/repos",
      "events_url": "https://api.github.com/users/come-maiz/events{/privacy}",
      "received_events_url": "https://api.github.com/users/come-maiz/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-07-21T14:56:17Z",
    "updated_at": "2022-07-21T14:56:17Z",
    "author_association": "CONTRIBUTOR",
    "body": "Important to note that not all validators will be using mev-boost. But there's a strong economic incentive for them to use it, so I expect the majority will. Will the percentage of clueless or not profit-maximizing validators be relevant for preventing collapse? How many of them should there be to play a relevant role on stability?",
    "reactions": {
      "url": "https://api.github.com/repos/flashbots/mev-boost/issues/comments/1191588278/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/flashbots/mev-boost/issues/comments/1192535174",
    "html_url": "https://github.com/flashbots/mev-boost/issues/222#issuecomment-1192535174",
    "issue_url": "https://api.github.com/repos/flashbots/mev-boost/issues/222",
    "id": 1192535174,
    "node_id": "IC_kwDOGZSKs85HFKSG",
    "user": {
      "login": "thegostep",
      "id": 15959632,
      "node_id": "MDQ6VXNlcjE1OTU5NjMy",
      "avatar_url": "https://avatars.githubusercontent.com/u/15959632?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/thegostep",
      "html_url": "https://github.com/thegostep",
      "followers_url": "https://api.github.com/users/thegostep/followers",
      "following_url": "https://api.github.com/users/thegostep/following{/other_user}",
      "gists_url": "https://api.github.com/users/thegostep/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/thegostep/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/thegostep/subscriptions",
      "organizations_url": "https://api.github.com/users/thegostep/orgs",
      "repos_url": "https://api.github.com/users/thegostep/repos",
      "events_url": "https://api.github.com/users/thegostep/events{/privacy}",
      "received_events_url": "https://api.github.com/users/thegostep/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-07-22T12:44:21Z",
    "updated_at": "2022-07-22T12:44:21Z",
    "author_association": "CONTRIBUTOR",
    "body": "Last January, I prepared a document outlining a set of proposed [mev-boost security features](https://hackmd.io/@flashbots/r1CuVl86Y) that aim to address potential relay faults which can lead to liveness issues. \r\n\r\nmev-boost in its current state does not mitigate these faults. Given they have the potential to lead to the chain stalling and failing to propose new blocks, I have put together in this post my thoughts on high priority mitigation paths ahead of the upcoming merge.\r\n\r\nPlease read the original document before continuing to read this post!\r\n\r\n### worst case scenario analysis\r\n\r\nLet's look at a worse case scenario. We assume that at the merge, >90% of validators are running mev-boost and are exclusively connected to the Flashbots relay, and mev-boost is deployed in its current state.\r\n\r\nA bug in the Flashbots relay could possibly lead it to have the following faults. Each fault can be analyzed as being \"cascading\" and \"attributable\". A cascading fault means that the validator of the current slot is not aware if the fault occurred to the validator in the previous slot. A non-attributable fault means that it is not possible to prove if the fault originated from validator or from relay misbehavior. Cascading faults are the most dangerous as they have the potential to impact chain liveness for extended periods of time. Attribution helps in mitigating cascading faults as fraud proofs can be constructed and programmatically used in a reputation system or circuit breaker, but it does not prevent the fault from occurring.\r\n\r\n1. Reveal Withholding aka \"missing data\" (cascading, non-attributable)\r\n\r\nA bug or degraded performance due to DOS or other infrastructure outage in the relay causes it to propose block headers to validators, but fail to reveal the block body in time for inclusion in the chain. This is non-attributable because it is impossible for the network to differentiate if it is the validator or the relay that is causing the reveal delay.\r\n\r\n2. Invalid Block aka \"invalid payload\" (cascading, attributable)\r\n\r\nA faulty relay simulation may cause it to send blocks that break consensus rules. This means it would reveal blocks to the network on time, but the blocks are not accepted by the attestation committees. This is an attributable fault because relays sign all the blocks they submit to validators. \r\n\r\n3. Incorrect Block aka \"inaccurate value\" (cascading, attributable)\r\n\r\nA faulty relay simulation may cause it to send blocks that have valid consensus rules, but misrepresent the value of the blocks. An extreme case of this fault would lead to validators proposing empty blocks, or for the relay or block builder not to pay the feeRecipient. This fault could cause deteriorated user experience, but would not cause a consensus liveness issue for the network. This is an attributable fault because relays sign all the blocks they submit to validators.\r\n\r\nQuestions:\r\n- For each of these faults, what is the worse case impact on the network and on validator's stake? Does reveal withholding have a different worse case impact than invalid blocks?\r\n- What is a tolerable network impact? How many missed slots is considered OK for a worst case scenario?\r\n- Which faults should be prioritized? Is an attributable liveness fault really better than a non-attributable liveness fault?\r\n\r\n### potential mitigations\r\n\r\nValidators need a way to identify these faults and disconnect from the offending relay programmatically. This means turning worse case scenarios into attributable non-cascading faults.\r\n\r\nReveal Withholding appears to be the greatest threat and therefore priority to mitigate. The following mitigations will focus on this fault, but can be used for the other faults too.\r\n\r\n1. Circuit breaker\r\n\r\nA circuit breaker would be code implemented by the consensus client which says \"disconnect from mev-boost if the network has not produced a block in X number of blocks\". This requires the consensus clients to be able to inspect network traffic to identify when missed slots occur. In theory this should mitigate block withholding and invalid block faults by making them non-cascading. It does not make block withholding attributable.\r\n\r\nQuestions:\r\n- do consensus clients have the necessary information to identify when slots are missed? can it tell withholding apart from invalid payloads?\r\n- does this create an incentive for malicious validators to \"grief\" the system by deliberately producing X invalid blocks and causing the rest of the network to disconnect from mev-boost?\r\n- what X value should be selected?\r\n- when should consensus clients reconnection to mev-boost after the circuit breaker is triggered?\r\n\r\n2. Relay monitoring\r\n\r\nA relay monitor is a third party system that a validator connects to and delegates the responsibility of monitoring relay performance. If the relay monitor identifies a relay has induced any of the three faults, it can send a message to mev-boost of all validators to disconnect from this relay. The clear advantage of this approach over the circuit break on the consensus client is that is solves for all three faults types without limitation on the data that can be accessed. The obvious drawback is that it adds an additional trusted party to the system who can have faults and outages of its own. This additional trust can be mitigated by connecting to multiple independent relay monitors with an 1/n policy.\r\n\r\nQuestions:\r\n- can relay monitors be bribed to disconnect from certain relays?\r\n\r\n3. Relay multi-sig\r\n\r\nA relay multi-sig means that mev-boost would implement some logic which requires x/n policy or more relays to propose the same block header for the header to be considered valid and be released to the consensus client. In theory, this should reduce the risk of faults from occurring if relays are run by independent parties and have independent implementations. This does not however seem to help improve cascading fault or attribution in the worse case scenario if multiple relays have correlated faults.\r\n\r\nQuestions:\r\n- what could cause multiple relays to have simultaneous faults?\r\n- what is the impact of the incentive for relays to induce faults in each other?\r\n\r\n4. Fraud proofs\r\n\r\nFraud proofs or payment proofs involve taking an attributable fault and generating a proof that is submitted to all other validators in the network to notify them to disconnect from a relay. It can be used to turn cascading, attributable faults into non-cascading faults. This means it is not helpful for the withholding issue but can be used alongside other mitigation techniques.\r\n\r\nQuestions:\r\n- which other mitigation techniques can fraud proofs or payment proofs be coupled with?\r\n\r\n### worse case fault recovery testing\r\n\r\nWhichever mitigation is selected, it should be deployed and tested in a production environment by a super majority of mainnet node operators on diverse consensus clients. The test should simulate the worse case fault described above with 100% of node operators connected to the faulty relay and monitor that the chain is able to successfully recover and continue producing blocks.\r\n\r\nNode operators should only whitelist a relay once it has successfully completed this test.",
    "reactions": {
      "url": "https://api.github.com/repos/flashbots/mev-boost/issues/comments/1192535174/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/flashbots/mev-boost/issues/comments/1192590738",
    "html_url": "https://github.com/flashbots/mev-boost/issues/222#issuecomment-1192590738",
    "issue_url": "https://api.github.com/repos/flashbots/mev-boost/issues/222",
    "id": 1192590738,
    "node_id": "IC_kwDOGZSKs85HFX2S",
    "user": {
      "login": "come-maiz",
      "id": 617831,
      "node_id": "MDQ6VXNlcjYxNzgzMQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/617831?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/come-maiz",
      "html_url": "https://github.com/come-maiz",
      "followers_url": "https://api.github.com/users/come-maiz/followers",
      "following_url": "https://api.github.com/users/come-maiz/following{/other_user}",
      "gists_url": "https://api.github.com/users/come-maiz/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/come-maiz/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/come-maiz/subscriptions",
      "organizations_url": "https://api.github.com/users/come-maiz/orgs",
      "repos_url": "https://api.github.com/users/come-maiz/repos",
      "events_url": "https://api.github.com/users/come-maiz/events{/privacy}",
      "received_events_url": "https://api.github.com/users/come-maiz/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-07-22T13:44:03Z",
    "updated_at": "2022-07-22T13:44:36Z",
    "author_association": "CONTRIBUTOR",
    "body": "I'm interested on how we can design that worse case fault recovery testing.\r\n\r\nSepolia could have a representative sample of the node operators proportional to their stake in mainnet. And then we could coordinate all the known big node operators for this kind of testing. Would that make sense?\r\n\r\nOr this would only be feasible in a lab simulated testnet?\r\n\r\n@parithosh @lightclient @yoavw, any thoughts? Anybody else from your teams that would want to collaborate on this?",
    "reactions": {
      "url": "https://api.github.com/repos/flashbots/mev-boost/issues/comments/1192590738/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/flashbots/mev-boost/issues/comments/1192704540",
    "html_url": "https://github.com/flashbots/mev-boost/issues/222#issuecomment-1192704540",
    "issue_url": "https://api.github.com/repos/flashbots/mev-boost/issues/222",
    "id": 1192704540,
    "node_id": "IC_kwDOGZSKs85HFzoc",
    "user": {
      "login": "come-maiz",
      "id": 617831,
      "node_id": "MDQ6VXNlcjYxNzgzMQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/617831?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/come-maiz",
      "html_url": "https://github.com/come-maiz",
      "followers_url": "https://api.github.com/users/come-maiz/followers",
      "following_url": "https://api.github.com/users/come-maiz/following{/other_user}",
      "gists_url": "https://api.github.com/users/come-maiz/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/come-maiz/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/come-maiz/subscriptions",
      "organizations_url": "https://api.github.com/users/come-maiz/orgs",
      "repos_url": "https://api.github.com/users/come-maiz/repos",
      "events_url": "https://api.github.com/users/come-maiz/events{/privacy}",
      "received_events_url": "https://api.github.com/users/come-maiz/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-07-22T15:42:14Z",
    "updated_at": "2022-07-22T15:42:14Z",
    "author_association": "CONTRIBUTOR",
    "body": "Here's one case in the category of trusted relay going rogue that we can't shut down.\r\n\r\nWhat happens if the flashbots DNS is attacked and we lose control over the domain?\r\n\r\n@sukoneck can we define and implement a policy for DNS changes on the mainnet relay that prevents a single employee for changing it, that prevents any customer support from the provider to change it, and that alerts of any changes? I've reported it in https://github.com/flashbots/infra/issues/105\r\n\r\nmev-boost has to register the validator with the URL and the public key, and verify that every block received is signed with the corresponding private key.",
    "reactions": {
      "url": "https://api.github.com/repos/flashbots/mev-boost/issues/comments/1192704540/reactions",
      "total_count": 1,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 1,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/flashbots/mev-boost/issues/comments/1193111344",
    "html_url": "https://github.com/flashbots/mev-boost/issues/222#issuecomment-1193111344",
    "issue_url": "https://api.github.com/repos/flashbots/mev-boost/issues/222",
    "id": 1193111344,
    "node_id": "IC_kwDOGZSKs85HHW8w",
    "user": {
      "login": "metachris",
      "id": 116939,
      "node_id": "MDQ6VXNlcjExNjkzOQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/116939?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/metachris",
      "html_url": "https://github.com/metachris",
      "followers_url": "https://api.github.com/users/metachris/followers",
      "following_url": "https://api.github.com/users/metachris/following{/other_user}",
      "gists_url": "https://api.github.com/users/metachris/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/metachris/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/metachris/subscriptions",
      "organizations_url": "https://api.github.com/users/metachris/orgs",
      "repos_url": "https://api.github.com/users/metachris/repos",
      "events_url": "https://api.github.com/users/metachris/events{/privacy}",
      "received_events_url": "https://api.github.com/users/metachris/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-07-23T11:38:49Z",
    "updated_at": "2022-07-23T11:38:49Z",
    "author_association": "COLLABORATOR",
    "body": "> I'm interested on how we can design that worse case fault recovery testing.\r\n\r\n1. First we need the mitigation mechanism agreed and implemented in the CL clients.\r\n2. Triggering the error is easy -- we can simply configure our relay to withhold every block on the `submitBlindedBlock` call. This test should happen on a testnet (or shadowfork) where 80% or more of the network uses the relay, and all CL clients would be represented. cc/ @paritosh",
    "reactions": {
      "url": "https://api.github.com/repos/flashbots/mev-boost/issues/comments/1193111344/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/flashbots/mev-boost/issues/comments/1194283890",
    "html_url": "https://github.com/flashbots/mev-boost/issues/222#issuecomment-1194283890",
    "issue_url": "https://api.github.com/repos/flashbots/mev-boost/issues/222",
    "id": 1194283890,
    "node_id": "IC_kwDOGZSKs85HL1Ny",
    "user": {
      "login": "parithosh",
      "id": 17509050,
      "node_id": "MDQ6VXNlcjE3NTA5MDUw",
      "avatar_url": "https://avatars.githubusercontent.com/u/17509050?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/parithosh",
      "html_url": "https://github.com/parithosh",
      "followers_url": "https://api.github.com/users/parithosh/followers",
      "following_url": "https://api.github.com/users/parithosh/following{/other_user}",
      "gists_url": "https://api.github.com/users/parithosh/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/parithosh/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/parithosh/subscriptions",
      "organizations_url": "https://api.github.com/users/parithosh/orgs",
      "repos_url": "https://api.github.com/users/parithosh/repos",
      "events_url": "https://api.github.com/users/parithosh/events{/privacy}",
      "received_events_url": "https://api.github.com/users/parithosh/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-07-25T16:01:08Z",
    "updated_at": "2022-07-25T16:01:08Z",
    "author_association": "NONE",
    "body": "> Sepolia could have a representative sample of the node operators proportional to their stake in mainnet. And then we could coordinate all the known big node operators for this kind of testing. Would that make sense?\r\n\r\nSepolia has a permissioned validator set and while some of the staking pools are represented, I wouldn't say its proportional to mainnet. We'd like to keep the validator set small, so onboarding a lot of validators would be out of the question. \r\n\r\nI'd say an ephermeral testnet or a shadow fork is probably the easiest way to co-ordinate this sort of testing. I'd be happy to help with either. I'm assuming your team is already in touch with all potential participants and I'd mainly have to provide configs and validator keys? \r\n",
    "reactions": {
      "url": "https://api.github.com/repos/flashbots/mev-boost/issues/comments/1194283890/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/flashbots/mev-boost/issues/comments/1197326006",
    "html_url": "https://github.com/flashbots/mev-boost/issues/222#issuecomment-1197326006",
    "issue_url": "https://api.github.com/repos/flashbots/mev-boost/issues/222",
    "id": 1197326006,
    "node_id": "IC_kwDOGZSKs85HXb62",
    "user": {
      "login": "ralexstokes",
      "id": 3113781,
      "node_id": "MDQ6VXNlcjMxMTM3ODE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3113781?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ralexstokes",
      "html_url": "https://github.com/ralexstokes",
      "followers_url": "https://api.github.com/users/ralexstokes/followers",
      "following_url": "https://api.github.com/users/ralexstokes/following{/other_user}",
      "gists_url": "https://api.github.com/users/ralexstokes/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ralexstokes/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ralexstokes/subscriptions",
      "organizations_url": "https://api.github.com/users/ralexstokes/orgs",
      "repos_url": "https://api.github.com/users/ralexstokes/repos",
      "events_url": "https://api.github.com/users/ralexstokes/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ralexstokes/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-07-27T20:21:56Z",
    "updated_at": "2022-07-27T20:21:56Z",
    "author_association": "COLLABORATOR",
    "body": "> question: should the local execution client build a block in parallel so it is ready in case the relay fails?\r\n\r\nthere is currently a 1 second timeout for mev-boost to fail to produce a block before the proposer moves to a local pathway: https://github.com/ethereum/builder-specs/blob/main/specs/validator.md#relation-to-local-block-building\r\n\r\nmy only hesitation with local building in parallel is if the resource cost hinders those who would otherwise run nodes, e.g. at-home stakers\r\n\r\nalthough we should assume any proposer is sufficiently resourced to produce a block w/o the builder network and this kind of suggests we should update the directive in the builder-specs",
    "reactions": {
      "url": "https://api.github.com/repos/flashbots/mev-boost/issues/comments/1197326006/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/flashbots/mev-boost/issues/comments/1197813878",
    "html_url": "https://github.com/flashbots/mev-boost/issues/222#issuecomment-1197813878",
    "issue_url": "https://api.github.com/repos/flashbots/mev-boost/issues/222",
    "id": 1197813878,
    "node_id": "IC_kwDOGZSKs85HZTB2",
    "user": {
      "login": "parithosh",
      "id": 17509050,
      "node_id": "MDQ6VXNlcjE3NTA5MDUw",
      "avatar_url": "https://avatars.githubusercontent.com/u/17509050?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/parithosh",
      "html_url": "https://github.com/parithosh",
      "followers_url": "https://api.github.com/users/parithosh/followers",
      "following_url": "https://api.github.com/users/parithosh/following{/other_user}",
      "gists_url": "https://api.github.com/users/parithosh/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/parithosh/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/parithosh/subscriptions",
      "organizations_url": "https://api.github.com/users/parithosh/orgs",
      "repos_url": "https://api.github.com/users/parithosh/repos",
      "events_url": "https://api.github.com/users/parithosh/events{/privacy}",
      "received_events_url": "https://api.github.com/users/parithosh/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-07-28T08:13:28Z",
    "updated_at": "2022-07-28T08:13:28Z",
    "author_association": "NONE",
    "body": "> my only hesitation with local building in parallel is if the resource cost hinders those who would otherwise run nodes, e.g. at-home stakers\r\n\r\nWould that really be the case? My understanding is that `mev boost` would just fire off a request to fetch the payload. Once the request is sent, there's no extra processing overhead. In the meantime, requesting the EL to generate the payload shouldn't be an extra overhead (considering that it's what needs to happen if `mev boost` didn't exist). \r\n\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/flashbots/mev-boost/issues/comments/1197813878/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/flashbots/mev-boost/issues/comments/1202401149",
    "html_url": "https://github.com/flashbots/mev-boost/issues/222#issuecomment-1202401149",
    "issue_url": "https://api.github.com/repos/flashbots/mev-boost/issues/222",
    "id": 1202401149,
    "node_id": "IC_kwDOGZSKs85Hqy99",
    "user": {
      "login": "StefanBratanov",
      "id": 14827647,
      "node_id": "MDQ6VXNlcjE0ODI3NjQ3",
      "avatar_url": "https://avatars.githubusercontent.com/u/14827647?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/StefanBratanov",
      "html_url": "https://github.com/StefanBratanov",
      "followers_url": "https://api.github.com/users/StefanBratanov/followers",
      "following_url": "https://api.github.com/users/StefanBratanov/following{/other_user}",
      "gists_url": "https://api.github.com/users/StefanBratanov/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/StefanBratanov/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/StefanBratanov/subscriptions",
      "organizations_url": "https://api.github.com/users/StefanBratanov/orgs",
      "repos_url": "https://api.github.com/users/StefanBratanov/repos",
      "events_url": "https://api.github.com/users/StefanBratanov/events{/privacy}",
      "received_events_url": "https://api.github.com/users/StefanBratanov/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-08-02T12:08:03Z",
    "updated_at": "2022-08-02T12:08:19Z",
    "author_association": "NONE",
    "body": "> > question: should the local execution client build a block in parallel so it is ready in case the relay fails?\r\n> \r\n> there is currently a 1 second timeout for mev-boost to fail to produce a block before the proposer moves to a local pathway: https://github.com/ethereum/builder-specs/blob/main/specs/validator.md#relation-to-local-block-building\r\n> \r\n> my only hesitation with local building in parallel is if the resource cost hinders those who would otherwise run nodes, e.g. at-home stakers\r\n> \r\n> although we should assume any proposer is sufficiently resourced to produce a block w/o the builder network and this kind of suggests we should update the directive in the builder-specs\r\n\r\nActually currently in Teku we make an async request for an `ExecutionPayload` to the execution layer before requesting a header from builders. That way we can quickly fallback to a local block in case things go wrong with the builder flow. (timeouts, exceptions, validator not registered)\r\n\r\nI am wondering shouldn't there be a timeout in the builder spec similar to BUILDER_PROPOSAL_DELAY_TOLERANCE (1s) for getting the payload from the builders? That way worst case scenario, block wouldn't get delayed too much and if a local `ExecutionPayload` is already available, the proposal could still happen in time.",
    "reactions": {
      "url": "https://api.github.com/repos/flashbots/mev-boost/issues/comments/1202401149/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/flashbots/mev-boost/issues/comments/1202478059",
    "html_url": "https://github.com/flashbots/mev-boost/issues/222#issuecomment-1202478059",
    "issue_url": "https://api.github.com/repos/flashbots/mev-boost/issues/222",
    "id": 1202478059,
    "node_id": "IC_kwDOGZSKs85HrFvr",
    "user": {
      "login": "thegostep",
      "id": 15959632,
      "node_id": "MDQ6VXNlcjE1OTU5NjMy",
      "avatar_url": "https://avatars.githubusercontent.com/u/15959632?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/thegostep",
      "html_url": "https://github.com/thegostep",
      "followers_url": "https://api.github.com/users/thegostep/followers",
      "following_url": "https://api.github.com/users/thegostep/following{/other_user}",
      "gists_url": "https://api.github.com/users/thegostep/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/thegostep/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/thegostep/subscriptions",
      "organizations_url": "https://api.github.com/users/thegostep/orgs",
      "repos_url": "https://api.github.com/users/thegostep/repos",
      "events_url": "https://api.github.com/users/thegostep/events{/privacy}",
      "received_events_url": "https://api.github.com/users/thegostep/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-08-02T12:53:08Z",
    "updated_at": "2022-08-02T12:53:08Z",
    "author_association": "CONTRIBUTOR",
    "body": "I think there an interesting case to be made for each client to implement mitigation as they see fit rather than the entire network adopting the same mitigation technique. Diverse mitigations might mean more network resilience against accidental outages, and higher cost of deliberate attacks. It would be great to keep a reference of the mitigations used by each client in this issue or in the mev-boost documentation (cc @0xpanoramix).\r\n\r\nHere are some links to lighthouse and prysm:\r\nhttps://github.com/sigp/lighthouse/issues/3355\r\nhttps://github.com/prysmaticlabs/prysm/issues/11109",
    "reactions": {
      "url": "https://api.github.com/repos/flashbots/mev-boost/issues/comments/1202478059/reactions",
      "total_count": 1,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 1
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/flashbots/mev-boost/issues/comments/1202793062",
    "html_url": "https://github.com/flashbots/mev-boost/issues/222#issuecomment-1202793062",
    "issue_url": "https://api.github.com/repos/flashbots/mev-boost/issues/222",
    "id": 1202793062,
    "node_id": "IC_kwDOGZSKs85HsSpm",
    "user": {
      "login": "ralexstokes",
      "id": 3113781,
      "node_id": "MDQ6VXNlcjMxMTM3ODE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3113781?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ralexstokes",
      "html_url": "https://github.com/ralexstokes",
      "followers_url": "https://api.github.com/users/ralexstokes/followers",
      "following_url": "https://api.github.com/users/ralexstokes/following{/other_user}",
      "gists_url": "https://api.github.com/users/ralexstokes/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ralexstokes/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ralexstokes/subscriptions",
      "organizations_url": "https://api.github.com/users/ralexstokes/orgs",
      "repos_url": "https://api.github.com/users/ralexstokes/repos",
      "events_url": "https://api.github.com/users/ralexstokes/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ralexstokes/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-08-02T15:14:31Z",
    "updated_at": "2022-08-02T15:14:31Z",
    "author_association": "COLLABORATOR",
    "body": "> I am wondering shouldn't there be a timeout in the builder spec similar to BUILDER_PROPOSAL_DELAY_TOLERANCE (1s) for getting the payload from the builders? That way worst case scenario, block wouldn't get delayed too much and if a local ExecutionPayload is already available, the proposal could still happen in time.\r\n\r\nif I'm following you, you are referring to a timeout on the call to get the complete payload from the builder after having already signed the bid\r\n\r\nin this scenario, a proposer does not want to publish a competing block as it would be a slashable offence \r\n\r\nI think building in parallel makes sense but the proposer should only ever make one (1) signature for a given slot",
    "reactions": {
      "url": "https://api.github.com/repos/flashbots/mev-boost/issues/comments/1202793062/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/flashbots/mev-boost/issues/comments/1203674800",
    "html_url": "https://github.com/flashbots/mev-boost/issues/222#issuecomment-1203674800",
    "issue_url": "https://api.github.com/repos/flashbots/mev-boost/issues/222",
    "id": 1203674800,
    "node_id": "IC_kwDOGZSKs85Hvp6w",
    "user": {
      "login": "StefanBratanov",
      "id": 14827647,
      "node_id": "MDQ6VXNlcjE0ODI3NjQ3",
      "avatar_url": "https://avatars.githubusercontent.com/u/14827647?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/StefanBratanov",
      "html_url": "https://github.com/StefanBratanov",
      "followers_url": "https://api.github.com/users/StefanBratanov/followers",
      "following_url": "https://api.github.com/users/StefanBratanov/following{/other_user}",
      "gists_url": "https://api.github.com/users/StefanBratanov/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/StefanBratanov/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/StefanBratanov/subscriptions",
      "organizations_url": "https://api.github.com/users/StefanBratanov/orgs",
      "repos_url": "https://api.github.com/users/StefanBratanov/repos",
      "events_url": "https://api.github.com/users/StefanBratanov/events{/privacy}",
      "received_events_url": "https://api.github.com/users/StefanBratanov/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-08-03T08:57:11Z",
    "updated_at": "2022-08-03T08:57:11Z",
    "author_association": "NONE",
    "body": "> > I am wondering shouldn't there be a timeout in the builder spec similar to BUILDER_PROPOSAL_DELAY_TOLERANCE (1s) for getting the payload from the builders? That way worst case scenario, block wouldn't get delayed too much and if a local ExecutionPayload is already available, the proposal could still happen in time.\r\n> \r\n> if I'm following you, you are referring to a timeout on the call to get the complete payload from the builder after having already signed the bid\r\n> \r\n> in this scenario, a proposer does not want to publish a competing block as it would be a slashable offence\r\n> \r\n> I think building in parallel makes sense but the proposer should only ever make one (1) signature for a given slot\r\n\r\nYeah, I was referring to the payload call. \r\n\r\nAs for the building in parallel, when the proposer asks for a block, it should be either MEV or a local one depending on timeouts or any exceptions. There will be only one signature. The additional timeout for the payload call could help potentially with mitigating any malicious delays when requesting the payload.",
    "reactions": {
      "url": "https://api.github.com/repos/flashbots/mev-boost/issues/comments/1203674800/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/flashbots/mev-boost/issues/comments/1203862544",
    "html_url": "https://github.com/flashbots/mev-boost/issues/222#issuecomment-1203862544",
    "issue_url": "https://api.github.com/repos/flashbots/mev-boost/issues/222",
    "id": 1203862544,
    "node_id": "IC_kwDOGZSKs85HwXwQ",
    "user": {
      "login": "metachris",
      "id": 116939,
      "node_id": "MDQ6VXNlcjExNjkzOQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/116939?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/metachris",
      "html_url": "https://github.com/metachris",
      "followers_url": "https://api.github.com/users/metachris/followers",
      "following_url": "https://api.github.com/users/metachris/following{/other_user}",
      "gists_url": "https://api.github.com/users/metachris/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/metachris/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/metachris/subscriptions",
      "organizations_url": "https://api.github.com/users/metachris/orgs",
      "repos_url": "https://api.github.com/users/metachris/repos",
      "events_url": "https://api.github.com/users/metachris/events{/privacy}",
      "received_events_url": "https://api.github.com/users/metachris/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-08-03T12:06:16Z",
    "updated_at": "2022-08-03T12:07:15Z",
    "author_association": "COLLABORATOR",
    "body": "> mitigating any malicious delays when requesting the payload\r\n\r\nI don't see how an additional timeout on the BN would help here. mev-boost tries to get the payload from all the relays, and as soon as it gets the payload from one it cancels the requests to other relays. This alone should mitigate any malicious delays from other relays. Otherwise mev-boost is using a 2 second relay timeout by default, configurable with `-request-timeout`. Perhaps that should be longer for getPayload calls ðŸ¤” ",
    "reactions": {
      "url": "https://api.github.com/repos/flashbots/mev-boost/issues/comments/1203862544/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/flashbots/mev-boost/issues/comments/1204008241",
    "html_url": "https://github.com/flashbots/mev-boost/issues/222#issuecomment-1204008241",
    "issue_url": "https://api.github.com/repos/flashbots/mev-boost/issues/222",
    "id": 1204008241,
    "node_id": "IC_kwDOGZSKs85Hw7Ux",
    "user": {
      "login": "terencechain",
      "id": 21316537,
      "node_id": "MDQ6VXNlcjIxMzE2NTM3",
      "avatar_url": "https://avatars.githubusercontent.com/u/21316537?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/terencechain",
      "html_url": "https://github.com/terencechain",
      "followers_url": "https://api.github.com/users/terencechain/followers",
      "following_url": "https://api.github.com/users/terencechain/following{/other_user}",
      "gists_url": "https://api.github.com/users/terencechain/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/terencechain/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/terencechain/subscriptions",
      "organizations_url": "https://api.github.com/users/terencechain/orgs",
      "repos_url": "https://api.github.com/users/terencechain/repos",
      "events_url": "https://api.github.com/users/terencechain/events{/privacy}",
      "received_events_url": "https://api.github.com/users/terencechain/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-08-03T14:14:51Z",
    "updated_at": "2022-08-03T14:14:51Z",
    "author_association": "COLLABORATOR",
    "body": "> mev-boost tries to get the payload from all the relays, and as soon as it gets the payload from one it cancels the requests to other relays.\r\n\r\nShouldn't this relationship be 1:1? My understanding is payload should come from the relay where mev-boost is called `getHeader`.   Are we assuming builders broadcast the same payload to multiple relays so more than one relay? \r\n",
    "reactions": {
      "url": "https://api.github.com/repos/flashbots/mev-boost/issues/comments/1204008241/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/flashbots/mev-boost/issues/comments/1204019931",
    "html_url": "https://github.com/flashbots/mev-boost/issues/222#issuecomment-1204019931",
    "issue_url": "https://api.github.com/repos/flashbots/mev-boost/issues/222",
    "id": 1204019931,
    "node_id": "IC_kwDOGZSKs85Hw-Lb",
    "user": {
      "login": "ralexstokes",
      "id": 3113781,
      "node_id": "MDQ6VXNlcjMxMTM3ODE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3113781?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ralexstokes",
      "html_url": "https://github.com/ralexstokes",
      "followers_url": "https://api.github.com/users/ralexstokes/followers",
      "following_url": "https://api.github.com/users/ralexstokes/following{/other_user}",
      "gists_url": "https://api.github.com/users/ralexstokes/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ralexstokes/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ralexstokes/subscriptions",
      "organizations_url": "https://api.github.com/users/ralexstokes/orgs",
      "repos_url": "https://api.github.com/users/ralexstokes/repos",
      "events_url": "https://api.github.com/users/ralexstokes/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ralexstokes/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-08-03T14:24:30Z",
    "updated_at": "2022-08-03T14:24:30Z",
    "author_association": "COLLABORATOR",
    "body": "> mitigating any malicious delays when requesting the payload.\r\nall this would really do is make sure the one caller is not affected, which I guess is worth considering but to my knowledge clients have timeouts across the entire proposal process so that would catch this already (?)\r\n\r\nthis feels like a thing that doesn't go into the *spec*\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/flashbots/mev-boost/issues/comments/1204019931/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/flashbots/mev-boost/issues/comments/1204161086",
    "html_url": "https://github.com/flashbots/mev-boost/issues/222#issuecomment-1204161086",
    "issue_url": "https://api.github.com/repos/flashbots/mev-boost/issues/222",
    "id": 1204161086,
    "node_id": "IC_kwDOGZSKs85Hxgo-",
    "user": {
      "login": "StefanBratanov",
      "id": 14827647,
      "node_id": "MDQ6VXNlcjE0ODI3NjQ3",
      "avatar_url": "https://avatars.githubusercontent.com/u/14827647?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/StefanBratanov",
      "html_url": "https://github.com/StefanBratanov",
      "followers_url": "https://api.github.com/users/StefanBratanov/followers",
      "following_url": "https://api.github.com/users/StefanBratanov/following{/other_user}",
      "gists_url": "https://api.github.com/users/StefanBratanov/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/StefanBratanov/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/StefanBratanov/subscriptions",
      "organizations_url": "https://api.github.com/users/StefanBratanov/orgs",
      "repos_url": "https://api.github.com/users/StefanBratanov/repos",
      "events_url": "https://api.github.com/users/StefanBratanov/events{/privacy}",
      "received_events_url": "https://api.github.com/users/StefanBratanov/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-08-03T16:08:11Z",
    "updated_at": "2022-08-03T16:08:11Z",
    "author_association": "NONE",
    "body": "> > mitigating any malicious delays when requesting the payload\r\n> \r\n> I don't see how an additional timeout on the BN would help here. mev-boost tries to get the payload from all the relays, and as soon as it gets the payload from one it cancels the requests to other relays. This alone should mitigate any malicious delays from other relays. Otherwise mev-boost is using a 2 second relay timeout by default, configurable with `-request-timeout`. Perhaps that should be longer for getPayload calls ðŸ¤”\r\n\r\nI was referring to the **Reveal Withholding aka \"missing data\"** problem described above. If the beacon node is connected to a relay or has set a higher `--request-timeout` in the mev-boost component, and also haven't set a specific timeout for the payload request, It could lead to a missed block whether the delay from mev-boost/relays was malicious or not.",
    "reactions": {
      "url": "https://api.github.com/repos/flashbots/mev-boost/issues/comments/1204161086/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/flashbots/mev-boost/issues/comments/1206705189",
    "html_url": "https://github.com/flashbots/mev-boost/issues/222#issuecomment-1206705189",
    "issue_url": "https://api.github.com/repos/flashbots/mev-boost/issues/222",
    "id": 1206705189,
    "node_id": "IC_kwDOGZSKs85H7Nwl",
    "user": {
      "login": "come-maiz",
      "id": 617831,
      "node_id": "MDQ6VXNlcjYxNzgzMQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/617831?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/come-maiz",
      "html_url": "https://github.com/come-maiz",
      "followers_url": "https://api.github.com/users/come-maiz/followers",
      "following_url": "https://api.github.com/users/come-maiz/following{/other_user}",
      "gists_url": "https://api.github.com/users/come-maiz/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/come-maiz/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/come-maiz/subscriptions",
      "organizations_url": "https://api.github.com/users/come-maiz/orgs",
      "repos_url": "https://api.github.com/users/come-maiz/repos",
      "events_url": "https://api.github.com/users/come-maiz/events{/privacy}",
      "received_events_url": "https://api.github.com/users/come-maiz/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2022-08-05T17:54:17Z",
    "updated_at": "2022-08-05T17:54:17Z",
    "author_association": "CONTRIBUTOR",
    "body": "https://writings.flashbots.net/writings/understanding-mev-boost-liveness-risks/",
    "reactions": {
      "url": "https://api.github.com/repos/flashbots/mev-boost/issues/comments/1206705189/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  }
]
